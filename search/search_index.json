{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to \ud83d\ude80LeetPattern","text":"<p>Thank you for visiting this project! If you find it helpful or interesting, please consider giving it a \u2b50\ufe0f on GitHub. It helps others discover the project and motivates me to keep improving it. Your support means a lot! \ud83d\ude0a</p>      \ud83d\udcda This is a collection of patterns for solving LeetCode problems. The goal is to provide a structured approach to solving problems and to help you build a strong foundation in algorithms and data structures."},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python Basics: Python Distilled</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>\u7b97\u6cd5\u7ade\u8d5b\u6a21\u677f\u5e93 by \u7075\u8336\u5c71\u827e\u5e9c</li> <li>[Leetcode Discuss] Solved all two pointers problems in 100 days</li> <li>[Leetcode Discuss] Solved all dynamic programming (dp) problems in 7 months</li> <li>liquidslr/leetcode-company-wise-problems</li> </ul>"},{"location":"#steps-to-solve-dp-problems","title":"Steps to Solve DP Problems","text":"<ol> <li>Define the <code>dp</code> array and its meaning.</li> <li>Define the <code>dp</code> formula.</li> <li>Initialize the <code>dp</code> array.</li> <li>Determine the traversal direction.</li> <li>Derive the <code>dp</code> array.</li> </ol>"},{"location":"about/","title":"Meet your Instructor","text":"Hi, I am Sihan. Connect with me on    <p>I've spent my career diving into the world of AI and machine learning, working on everything from optimizing DNN algorithms to deploying AI models on hardware. Right now, I'm at Sony, where I get to play with TensorRT, ONNX, and OpenVINO to create some pretty cool stuff. I\u2019ve built full-stack systems, set up MLOps pipelines, and delivered high-performance models for AI camera chips.</p> <p>Before Sony, I did a bunch of internships and research gigs, working on things like fine-tuning language models and industrial anomaly detection. I also have a Master\u2019s in Electrical and Electronic Engineering from Tokyo Tech, where I focused on self-supervised learning and edge computing.</p> <p>I love tackling tough problems and pushing the boundaries of what AI can do. It's been a fun ride so far, and I'm excited to keep making an impact in the AI world.</p>"},{"location":"blind75/","title":"Blind 75","text":""},{"location":"blind75/1d_dynamic_programming/","title":"1D Dynamic Programming","text":""},{"location":"blind75/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, dynamic programming, memoization</li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 <pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 <pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 12\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 <pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string, dynamic programming</li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> <pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string, dynamic programming</li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 <pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, breadth first search</li> </ul> <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, dynamic programming, trie, memoization</li> </ul> <pre><code>from typing import List\n\n\n# DP - Knapsack Unbounded\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - LIS\ndef lengthOfLIS(nums: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(n)\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # 4\n</code></pre>"},{"location":"blind75/2d_dynamic_programming/","title":"2D Dynamic Programming","text":""},{"location":"blind75/2d_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, dynamic programming, combinatorics</li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"blind75/2d_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n            if res &lt; dp[i][j]:\n                res = dp[i][j]\n\n    return res\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"blind75/advanced_graphs/","title":"Advanced Graphs","text":""},{"location":"blind75/advanced_graphs/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, depth first search, breadth first search, graph, topological sort</li> <li>Return the correct order of characters in the alien language.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"blind75/arrays_hashing/","title":"Arrays Hashing","text":""},{"location":"blind75/arrays_hashing/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, sorting</li> <li>Return True if the array contains any duplicates, otherwise return False.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"blind75/arrays_hashing/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, string, sorting</li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> <pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"blind75/arrays_hashing/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table</li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) <pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"blind75/arrays_hashing/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, sorting</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"blind75/arrays_hashing/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect</li> </ul> <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"blind75/arrays_hashing/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, design</li> </ul> <pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"blind75/arrays_hashing/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# 2. Prefix - Optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |    Prefix   |    O(n)     |    O(n)      |\n# |Prefix - Opt |    O(n)     |    O(1)      |\n# |-------------|-------------|--------------|\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"blind75/arrays_hashing/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, union find</li> </ul> <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"blind75/backtracking/","title":"Backtracking","text":""},{"location":"blind75/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"blind75/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, backtracking, depth first search, matrix</li> </ul> <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"blind75/binary_search/","title":"Binary Search","text":""},{"location":"blind75/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> </ul>"},{"location":"blind75/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> </ul>"},{"location":"blind75/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"blind75/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: divide and conquer, bit manipulation</li> </ul> <pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre>"},{"location":"blind75/bit_manipulation/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: dynamic programming, bit manipulation</li> </ul> <pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"blind75/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: divide and conquer, bit manipulation</li> </ul> <pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"blind75/bit_manipulation/#268-missing-number","title":"268. Missing Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, math, binary search, bit manipulation, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre>"},{"location":"blind75/bit_manipulation/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, bit manipulation</li> </ul> <pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"blind75/graphs/","title":"Graphs","text":""},{"location":"blind75/graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"blind75/graphs/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, depth first search, breadth first search, graph</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre>"},{"location":"blind75/graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"blind75/graphs/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"blind75/graphs/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"blind75/graphs/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"blind75/greedy/","title":"Greedy","text":""},{"location":"blind75/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"blind75/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True <pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    maxReach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= maxReach:\n        maxReach = max(maxReach, i + nums[i])\n        if maxReach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"blind75/heap/","title":"Heap","text":""},{"location":"blind75/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: two pointers, design, sorting, heap priority queue, data stream</li> </ul> <pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"blind75/intervals/","title":"Intervals","text":""},{"location":"blind75/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array</li> </ul> <pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"blind75/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, sorting</li> <li>Merge all overlapping intervals.</li> </ul> <pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"blind75/intervals/#252-meeting-rooms","title":"252. Meeting Rooms","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(canAttendMeetings(intervals))  # False\n</code></pre>"},{"location":"blind75/intervals/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    heap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= heap[0]:\n            heapq.heappop(heap)\n        heapq.heappush(heap, intervals[i][1])\n\n    return len(heap)\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(minMeetingRooms(intervals))  # 2\n</code></pre>"},{"location":"blind75/intervals/#254-factor-combinations","title":"254. Factor Combinations","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: backtracking</li> </ul>"},{"location":"blind75/linked_list/","title":"Linked List","text":""},{"location":"blind75/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: linked list, recursion</li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[3]\nC --&gt; D[4]\nD --&gt; E[5]</code></pre> <pre><code>graph RL\nE[5] --&gt; D[4]\nD --&gt; C[3]\nC --&gt; B[2]\nB --&gt; A[1]</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"blind75/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: linked list, recursion</li> <li>Merge the two lists into one sorted list.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre>"},{"location":"blind75/linked_list/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, two pointers, stack, recursion</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\nhead = ListNode.create([1, 2, 3, 4, 5, 6])\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nreorderList(head)\nprint(head)  # 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n</code></pre>"},{"location":"blind75/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, two pointers</li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"blind75/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, linked list, two pointers</li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]</code></pre> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"blind75/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: linked list, divide and conquer, heap priority queue, merge sort</li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> <pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"blind75/math_geometry/","title":"Math Geometry","text":""},{"location":"blind75/math_geometry/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, math, matrix</li> </ul> <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"blind75/math_geometry/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, matrix, simulation</li> <li>Return all elements of the matrix in spiral order.</li> </ul> <pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"blind75/math_geometry/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, matrix</li> </ul> <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre>"},{"location":"blind75/sliding_window/","title":"Sliding Window","text":""},{"location":"blind75/sliding_window/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"blind75/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(len(s)):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"blind75/sliding_window/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"blind75/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"blind75/stack/","title":"Stack","text":""},{"location":"blind75/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, stack</li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" <pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"blind75/trees/","title":"Trees","text":""},{"location":"blind75/trees/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"blind75/trees/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return depth\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    return 1 + max(maxDepthRecursive(root.left), maxDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthRecursive(root))  # 4\n</code></pre>"},{"location":"blind75/trees/#100-same-tree","title":"100. Same Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"blind75/trees/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, string matching, binary tree, hash function</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre>"},{"location":"blind75/trees/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"blind75/trees/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"blind75/trees/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"blind75/trees/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"blind75/trees/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, tree, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"blind75/trees/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: dynamic programming, tree, depth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"blind75/trees/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary tree</li> </ul>"},{"location":"blind75/tries/","title":"Tries","text":""},{"location":"blind75/tries/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, design, trie</li> </ul>"},{"location":"blind75/tries/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"blind75/tries/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, backtracking, trie, matrix</li> </ul> <pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"blind75/tries/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, depth first search, design, trie</li> </ul> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"blind75/two_pointers/","title":"Two Pointers","text":""},{"location":"blind75/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string</li> </ul> <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"blind75/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# |-----------|---------|---------|\n# | Approach  |   Time  |  Space  |\n# |-----------|---------|---------|\n# | LR Pointer|  O(n^2) |   O(1)  |\n# |-----------|---------|---------|\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))  # [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"blind75/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, greedy</li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"company/","title":"Company Wise","text":"<ul> <li>liquidslr/leetcode-company-wise-problems</li> </ul>"},{"location":"company/amazon/","title":"Amazon","text":""},{"location":"company/amazon/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table</li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) <pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"company/amazon/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list, design, doubly linked list</li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. Approach Time Complexity Space Complexity LRU O(1) O(n) <pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre>"},{"location":"company/amazon/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"company/amazon/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, two pointers, dynamic programming, stack, monotonic stack</li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) <pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"company/amazon/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, sorting</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"company/amazon/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"company/amazon/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, sorting</li> <li>Merge all overlapping intervals.</li> </ul> <pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"company/amazon/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"company/amazon/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: linked list, divide and conquer, heap priority queue, merge sort</li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> <pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"company/amazon/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect</li> </ul> <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"company/amazon/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    \"\"\"Merges two sorted arrays in-place.\"\"\"\n    p1, p2, t = m - 1, n - 1, m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n\n        t -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre>"},{"location":"company/amazon/#15-3sum","title":"15. 3Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# |-----------|---------|---------|\n# | Approach  |   Time  |  Space  |\n# |-----------|---------|---------|\n# | LR Pointer|  O(n^2) |   O(1)  |\n# |-----------|---------|---------|\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))  # [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"company/amazon/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, breadth first search</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # Edge case\n    if endWord not in wordList:\n        return 0\n\n    # Init\n    graph = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    # BFS\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\n# |------------|---------|---------|\n# |  Approach  |  Time   |  Space  |\n# |------------|---------|---------|\n# |    BFS     | O(n*m^2)| O(n*m)  |\n# |------------|---------|---------|\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"company/amazon/#55-jump-game","title":"55. Jump Game","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True <pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    maxReach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= maxReach:\n        maxReach = max(maxReach, i + nums[i])\n        if maxReach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"company/amazon/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(len(s)):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"company/amazon/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, trie</li> </ul> <pre><code>from typing import List\n\n\n# Horizontal Scanning\ndef longestCommonPrefixHorizontal(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while not strs[i].startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n\n    return prefix\n\n\n# Vertical Scanning\ndef longestCommonPrefixVertical(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for j in range(1, len(strs)):\n            if i &gt;= len(strs[j]) or strs[j][i] != char:\n                return strs[0][:i]\n\n    return strs[0]\n\n\n# Divide and Conquer\ndef longestCommonPrefixDivideConquer(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def merge(left, right):\n        n = min(len(left), len(right))\n        for i in range(n):\n            if left[i] != right[i]:\n                return left[:i]\n        return left[:n]\n\n    def helper(strs, start, end):\n        if start == end:\n            return strs[start]\n        mid = start + (end - start) // 2\n        left = helper(strs, start, mid)\n        right = helper(strs, mid + 1, end)\n        return merge(left, right)\n\n    return helper(strs, 0, len(strs) - 1)\n\n\n# Binary Search\ndef longestCommonPrefixBinarySearch(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def isCommonPrefix(strs, length):\n        prefix = strs[0][:length]\n        return all(s.startswith(prefix) for s in strs)\n\n    minLen = min(len(s) for s in strs)\n    low, high = 0, minLen\n    while low &lt; high:\n        mid = low + (high - low) // 2\n        if isCommonPrefix(strs, mid + 1):\n            low = mid + 1\n        else:\n            high = mid\n\n    return strs[0][:low]\n\n\nstrs = [\"flower\", \"flow\", \"flight\"]\nprint(longestCommonPrefixHorizontal(strs))  # \"fl\"\nprint(longestCommonPrefixVertical(strs))  # \"fl\"\nprint(longestCommonPrefixDivideConquer(strs))  # \"fl\"\nprint(longestCommonPrefixBinarySearch(strs))  # \"fl\"\n</code></pre>"},{"location":"company/amazon/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"company/amazon/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list</li> </ul> <pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"company/amazon/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, stack</li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" <pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"company/amazon/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, math, recursion</li> <li>Represent the sum of two numbers as a linked list.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre>"},{"location":"company/amazon/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, dynamic programming, memoization</li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 <pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"company/amazon/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# 2. Prefix - Optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |    Prefix   |    O(n)     |    O(n)      |\n# |Prefix - Opt |    O(n)     |    O(1)      |\n# |-------------|-------------|--------------|\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"company/amazon/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"company/amazon/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, divide and conquer</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"company/amazon/#79-word-search","title":"79. Word Search","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, backtracking, depth first search, matrix</li> </ul> <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"company/amazon/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming, backtracking</li> </ul> <pre><code>from typing import List\n\n\n# Stack\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"company/amazon/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, sorting, heap priority queue, quickselect</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    heap = nums[:k]\n    heapq.heapify(heap)  # min heap\n\n    for num in nums[k:]:\n        if num &gt; heap[0]:\n            heapq.heappop(heap)  # pop the smallest element\n            heapq.heappush(heap, num)  # push the new element\n\n    return heap[0]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\nnums = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(findKthLargest(nums, k))  # 5\n</code></pre>"},{"location":"company/amazon/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: two pointers, design, sorting, heap priority queue, data stream</li> </ul> <pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"company/amazon/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string, dynamic programming</li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> <pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"graph_theory/","title":"Graph Theory","text":""},{"location":"graph_theory/#resources","title":"Resources","text":"<ul> <li>Graph Editor: Create and visualize graphs.</li> <li>\u3010\u9898\u5355\u3011\u56fe\u8bba\u7b97\u6cd5\uff08DFS/BFS/\u62d3\u6251\u6392\u5e8f/\u6700\u77ed\u8def/\u6700\u5c0f\u751f\u6210\u6811/\u4e8c\u5206\u56fe/\u57fa\u73af\u6811/\u6b27\u62c9\u8def\u5f84\uff09</li> </ul>"},{"location":"graph_theory/#concepts","title":"Concepts","text":"<ul> <li>Graph</li> <li>Vertex (Node)</li> <li>Edge</li> <li>Weight</li> </ul>"},{"location":"graph_theory/#types","title":"Types","text":"<ul> <li> <p>Undirected graph: A graph in which edges have no direction.</p> </li> <li> <p></p> </li> <li> <p>Directed graph: A graph in which edges have direction.</p> </li> <li><code>mermaid       flowchart LR       A((1)) --&gt; B((2)) &amp; C((3))       C --&gt; B &amp; D((4))       D --&gt; C</code></li> <li> <p>Cyclic graph: A graph in which there is a cycle. A cycle is a path of edges that starts and ends at the same vertex, e.g., <code>1 -&gt; 3 -&gt; 4 -&gt; 1</code>.</p> </li> <li> <p><code>mermaid     flowchart LR     A((1)) --&gt; B((2)) &amp; C((3))     B --&gt; C     C --&gt; D((4))     D --&gt; A</code></p> </li> <li> <p>Acyclic graph: A graph in which there is no cycle.</p> </li> </ul> <p></p> <ul> <li>Directed Acyclic Graph (DAG): A directed graph with no cycles.<ul> <li>Topological sort</li> </ul> </li> </ul> <p></p> <ul> <li>Weighted graph: A graph in which edges have weights.</li> </ul> <p></p> <ul> <li>Connected Graph: A graph in which there is a path between every pair of vertices.</li> </ul> <p></p> <ul> <li>Disconnected Graph: A graph in which there is no path between some pairs of vertices.</li> </ul> <p></p> <ul> <li>Eulerian path: A path that visits every edge exactly once, e.g., <code>5 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 3</code>.</li> </ul> <p></p>"},{"location":"graph_theory/#representation","title":"Representation","text":"<ol> <li>Adjacency Matrix</li> <li>Adjacency List</li> </ol> <pre><code>flowchart LR\n1((1))\n2((2))\n3((3))\n4((4))\n1 --&gt; 3\n1 --&gt; 2\n3 --&gt; 4\n2 --&gt; 3</code></pre> <p>Adjacency Matrix</p> Node 1 Node 2 Node 3 Node 4 Node 1 0 1 1 0 Node 2 0 0 1 0 Node 3 0 0 0 1 Node 4 0 0 0 0 <pre><code>grid = [\n    [0, 1, 1, 0],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1],\n    [0, 0, 0, 0]\n]\n</code></pre> <p>Adjacency List</p> <pre><code>classDiagram\ndirection LR\nclass 1{2, 3}\nclass 2{3}\nclass 3{4}\nclass 4{-}\n1 -- 2\n2 -- 3\n3 -- 4</code></pre> <pre><code>graph = {\n    1: [2, 3],\n    2: [3],\n    3: [4],\n    4: []\n}\n</code></pre>"},{"location":"graph_theory/#degree","title":"Degree","text":"<ol> <li>Degree: Number of edges connected to a node</li> <li>In-degree: Number of edges coming into a node</li> <li>Out-degree: Number of edges going out of a node</li> </ol> <pre><code>flowchart LR\n1((1))\n2((2))\n3((3))\n4((4))\n1 --&gt; 3\n1 --&gt; 2\n3 --&gt; 4\n2 --&gt; 3</code></pre> <ul> <li>In-degree of Node 1: 0</li> <li>Out-degree of Node 1: 2</li> <li>In-degree of Node 2: 1</li> <li>Out-degree of Node 2: 1</li> </ul> <pre><code># List\nin_degree = [0, 1, 2, 1]\nout_degree = [2, 1, 1, 0]\n\n# Dict\nin_degree = {1: 0, 2: 1, 3: 2, 4: 1}\nout_degree = {1: 2, 2: 1, 3: 1, 4: 0}\n</code></pre>"},{"location":"graph_theory/#graph-bellman-ford-algorithm","title":"Graph - Bellman-Ford Algorithm","text":"<ul> <li>The Bellman-Ford algorithm is used to find the shortest path from a source vertex to all other vertices in a weighted graph.</li> <li>It is slower than Dijkstra's algorithm, but it is more versatile, as it is able to handle graphs with negative edge weights.</li> <li>Time Complexity: O(V x E), where V is the number of vertices and E is the number of edges in the graph.</li> <li>Space Complexity: O(V), where V is the number of vertices in the graph.</li> </ul>"},{"location":"graph_theory/bfs/","title":"BFS","text":""},{"location":"graph_theory/bfs/#1926-nearest-exit-from-entrance-in-maze","title":"1926. Nearest Exit from Entrance in Maze","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef nearestExit(maze: List[List[str]], entrance: List[int]) -&gt; int:\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque([(entrance[0], entrance[1], 0)])\n    maze[entrance[0]][entrance[1]] = \"+\"\n\n    while q:\n        r, c, steps = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and maze[nr][nc] == \".\":\n                if nr in [0, m - 1] or nc in [0, n - 1]:\n                    return steps + 1\n                q.append((nr, nc, steps + 1))\n                maze[nr][nc] = \"+\"\n\n    return -1\n\n\nmaze = [[\"+\", \"+\", \".\", \"+\"], [\".\", \".\", \".\", \"+\"], [\"+\", \"+\", \"+\", \".\"]]\nentrance = [1, 2]\nprint(nearestExit(maze, entrance))  # 1\n</code></pre>"},{"location":"graph_theory/bfs/#934-shortest-bridge","title":"934. Shortest Bridge","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS + DFS; Coloring\ndef shortestBridge(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c, queue):\n        grid[r][c] = 2\n        queue.append((r, c))\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr in range(n) and nc in range(n) and grid[nr][nc] == 1:\n                dfs(nr, nc, queue)\n\n    q = deque()\n    found = False\n    for r in range(n):\n        if found:\n            break\n        for c in range(n):\n            if grid[r][c] == 1:\n                dfs(r, c, q)\n                found = True\n                break\n\n    steps = 0\n    while q:\n        m = len(q)\n        for _ in range(m):\n            r, c = q.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if nr in range(n) and nc in range(n):\n                    if grid[nr][nc] == 1:\n                        return steps\n                    elif grid[nr][nc] == 0:\n                        grid[nr][nc] = 2\n                        q.append((nr, nc))\n        steps += 1\n\n    return -1\n\n\ngrid = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1],\n]\nprint(shortestBridge(grid))  # 1\n</code></pre>"},{"location":"graph_theory/bfs/#433-minimum-genetic-mutation","title":"433. Minimum Genetic Mutation","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, breadth first search</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef minMutation(startGene: str, endGene: str, bank: List[str]) -&gt; int:\n    if endGene not in bank:\n        return -1\n\n    bank = set(bank)\n    q = deque([(startGene, 0)])\n\n    while q:\n        gene, step = q.popleft()\n        if gene == endGene:\n            return step\n\n        for i in range(8):\n            for c in \"ACGT\":\n                if gene[i] == c:\n                    continue\n                newGene = gene[:i] + c + gene[i + 1 :]\n                if newGene in bank:\n                    bank.remove(newGene)\n                    q.append((newGene, step + 1))\n    return -1\n\n\nstartGene = \"AACCGGTT\"\nendGene = \"AAACGGTA\"\nbank = [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\nprint(minMutation(startGene, endGene, bank))  # 2\n</code></pre>"},{"location":"graph_theory/bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, breadth first search</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # Edge case\n    if endWord not in wordList:\n        return 0\n\n    # Init\n    graph = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    # BFS\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\n# |------------|---------|---------|\n# |  Approach  |  Time   |  Space  |\n# |------------|---------|---------|\n# |    BFS     | O(n*m^2)| O(n*m)  |\n# |------------|---------|---------|\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"graph_theory/bfs/#1306-jump-game-iii","title":"1306. Jump Game III","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef canReach(arr: List[int], start: int) -&gt; bool:\n    n = len(arr)\n    visited = [False for _ in range(n)]\n    q = deque([start])\n\n    while q:\n        i = q.popleft()\n\n        if arr[i] == 0:\n            return True\n\n        visited[i] = True\n\n        for j in [i - arr[i], i + arr[i]]:\n            if j in range(n) and not visited[j]:\n                q.append(j)\n\n    return False\n\n\narr = [4, 2, 3, 0, 3, 1, 2]\nstart = 5\nprint(canReach(arr, start))  # True\n</code></pre>"},{"location":"graph_theory/bfs/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre>"},{"location":"graph_theory/bfs/#1091-shortest-path-in-binary-matrix","title":"1091. Shortest Path in Binary Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    if n == 1:\n        return 1\n\n    directions = [\n        (0, 1),\n        (1, 0),\n        (0, -1),\n        (-1, 0),\n        (1, 1),\n        (-1, -1),\n        (1, -1),\n        (-1, 1),\n    ]\n    q = deque([(0, 0, 1)])  # (row, column, distance)\n    grid[0][0] = 1\n\n    while q:\n        r, c, d = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                if nr == nc == n - 1:\n                    return d + 1\n                q.append((nr, nc, d + 1))\n                grid[nr][nc] = 1\n\n    return -1\n\n\ngrid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]]\nprint(shortestPathBinaryMatrix(grid))  # 4\n</code></pre>"},{"location":"graph_theory/bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre>"},{"location":"graph_theory/bfs/#864-shortest-path-to-get-all-keys","title":"864. Shortest Path to Get All Keys","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, bit manipulation, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathAllKeys(grid: List[str]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    q = deque()\n    visited = set()\n    total = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"@\":\n                q.append((r, c, 0, 0))\n                visited.add((r, c, 0))\n            if grid[r][c].islower():\n                total += 1\n\n    while q:\n        r, c, keys, steps = q.popleft()\n\n        if keys == (1 &lt;&lt; total) - 1:\n            return steps\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                cell = grid[nr][nc]\n\n                if cell == \"#\":\n                    continue\n\n                new_keys = keys\n                if cell.islower():\n                    new_keys |= 1 &lt;&lt; (ord(cell) - ord(\"a\"))\n\n                if cell.isupper() and not (\n                    keys &amp; (1 &lt;&lt; (ord(cell) - ord(\"A\")))\n                ):\n                    continue\n\n                if (nr, nc, new_keys) not in visited:\n                    visited.add((nr, nc, new_keys))\n                    q.append((nr, nc, new_keys, steps + 1))\n\n    return -1\n\n\ngrid = [\"@.a..\", \"###.#\", \"b.A.B\"]\nprint(shortestPathAllKeys(grid))  # 8\n</code></pre>"},{"location":"graph_theory/dijkstra%27s/","title":"Dijkstra's","text":""},{"location":"graph_theory/dijkstra%27s/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"graph_theory/dijkstra%27s/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, graph, heap priority queue, shortest path</li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"graph_theory/dijkstra%27s/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"graph_theory/dijkstra%27s/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"graph_theory/graph_theory/","title":"Graph Theory","text":""},{"location":"graph_theory/graph_theory/#997-find-the-town-judge","title":"997. Find the Town Judge","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, graph</li> <li><code>trust = [[1, 3], [2, 3], [1, 2], [4, 3]]</code></li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 3((3))\n    2((2)) --&gt; 3((3))\n    1((1)) --&gt; 2((2))\n    4((4)) --&gt; 3((3))</code></pre> <pre><code>from typing import List\n\n\n# Graph\ndef findJudge(n: int, trust: List[List[int]]) -&gt; int:\n    indegree = {i: 0 for i in range(1, n + 1)}\n    outdegree = {i: 0 for i in range(1, n + 1)}\n\n    for a, b in trust:\n        outdegree[a] += 1\n        indegree[b] += 1\n\n    for i in range(1, n + 1):\n        if indegree[i] == n - 1 and outdegree[i] == 0:\n            return i\n\n    return -1\n\n\nn = 4\ntrust = [[1, 3], [2, 3], [1, 2], [4, 3]]\nprint(findJudge(n, trust))  # 4\n</code></pre>"},{"location":"graph_theory/graph_theory/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: graph</li> <li>Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.</li> <li>\u2705 Return the vertices with indegree 0.</li> </ul> <ul> <li><code>edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]</code></li> <li>Initialization</li> </ul> <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 0 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 1 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 2 0 1 1 <pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for a, b in edges:\n        indegree[b] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(findSmallestSetOfVertices(n, edges))  # [0, 3]\n</code></pre>"},{"location":"graph_theory/graph_theory/#1615-maximal-network-rank","title":"1615. Maximal Network Rank","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: graph</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef maximalNetworkRank(n: int, roads: List[List[int]]) -&gt; int:\n    degree = defaultdict(int)\n    roads_set = set(map(tuple, roads))\n\n    for a, b in roads_set:\n        degree[a] += 1\n        degree[b] += 1\n\n    rank = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (i, j) in roads_set or (j, i) in roads_set:\n                rank = max(rank, degree[i] + degree[j] - 1)\n            else:\n                rank = max(rank, degree[i] + degree[j])\n\n    return rank\n\n\nn = 4\nroads = [[0, 1], [0, 3], [1, 2], [1, 3]]\nprint(maximalNetworkRank(n, roads))  # 4\n</code></pre>"},{"location":"graph_theory/graph_theory/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> <li>Determine if a graph is bipartite.</li> </ul> <p>How to group</p> Uncolored Color 1 Color 2 Operation Method 1 -1 0 1 <code>1 - color</code> Method 2 0 1 -1 <code>-color</code> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"graph_theory/graph_theory/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"graph_theory/matrix_graphs/","title":"Matrix Graphs","text":""},{"location":"graph_theory/matrix_graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"graph_theory/matrix_graphs/#1020-number-of-enclaves","title":"1020. Number of Enclaves","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> </ul> <pre><code>from typing import List\n\n\n# DFS\ndef numEnclaves(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 0\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 1\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    count = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                count += 1\n\n    return count\n\n\ngrid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nprint(numEnclaves(grid))  # 3\n</code></pre>"},{"location":"graph_theory/matrix_graphs/#1254-number-of-closed-islands","title":"1254. Number of Closed Islands","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> </ul> <pre><code>from typing import List\n\n\n# DFS\ndef closedIsland(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 1\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 1\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 0\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    island = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 0 and (r, c) not in visited:\n                island += 1\n                dfs(r, c)\n\n    return island\n\n\ngrid = [\n    [1, 1, 1, 1, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 1, 0, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0],\n]\nprint(closedIsland(grid))  # 2\n</code></pre>"},{"location":"graph_theory/matrix_graphs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return 0\n\n        grid[r][c] = 2\n\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    area = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"graph_theory/matrix_graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"graph_theory/mst/","title":"MST","text":""},{"location":"graph_theory/mst/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: union find, graph, heap priority queue, minimum spanning tree</li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"graph_theory/mst/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, union find, graph, minimum spanning tree</li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm<ul> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Kruskal's Algorithm</p> <ul> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Demonstration</p> </li> </ul> <p>Example graph</p> <p></p> <p>MST</p> <p></p> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"graph_theory/mst/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: union find, graph, heap priority queue, minimum spanning tree </li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"graph_theory/mst/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: union find, graph, sorting, minimum spanning tree, strongly connected component</li> </ul> <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"graph_theory/standard_traversal/","title":"Standard Traversal","text":""},{"location":"graph_theory/standard_traversal/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> <li>Return the number of provinces.</li> </ul>"},{"location":"graph_theory/standard_traversal/#union-find","title":"Union Find","text":"<ul> <li>Find by Path Compression</li> <li>Union by Rank</li> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(n)</li> </ul> template/union_find.py<pre><code>class UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return None\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n    def connected(self, n1, n2):\n        return self.find(n1) == self.find(n2)\n</code></pre> <pre><code>from typing import List\n\nfrom template import UnionFind\n\n\n# Union Find\ndef findCircleNumUF(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                uf.union(i, j)\n\n    res = len(set(uf.find(i) for i in range(n)))\n\n    return res\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    connected_components = len(set(find(i) for i in range(n)))\n\n    return connected_components\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNum(isConnected))  # 2\nprint(findCircleNumUF(isConnected))  # 2\n</code></pre>"},{"location":"graph_theory/standard_traversal/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre>"},{"location":"graph_theory/standard_traversal/#841-keys-and-rooms","title":"841. Keys and Rooms","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef canVisitAllRoomsDFS(rooms: List[List[int]]) -&gt; bool:\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n\n    def dfs(room):\n        visited[room] = True\n        for key in rooms[room]:\n            if not visited[key]:\n                dfs(key)\n\n    dfs(0)\n\n    return all(visited)\n\n\n# BFS\ndef canVisitAllRoomsBFS(rooms):\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n    q = deque([0])\n    visited[0] = True\n\n    while q:\n        room = q.popleft()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                q.append(key)\n\n    return all(visited)\n\n\nrooms = [[1, 3], [3, 0, 1], [2], [0]]\nprint(canVisitAllRoomsDFS(rooms))  # False\nprint(canVisitAllRoomsBFS(rooms))  # False\n</code></pre>"},{"location":"graph_theory/standard_traversal/#1129-shortest-path-with-alternating-colors","title":"1129. Shortest Path with Alternating Colors","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: breadth first search, graph</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef shortestAlternatingPaths(\n    n: int, redEdges: List[List[int]], blueEdges: List[List[int]]\n) -&gt; List[int]:\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n\n    for u, v in redEdges:\n        red_graph[u].append(v)\n    for u, v in blueEdges:\n        blue_graph[u].append(v)\n\n    answer = [-1 for _ in range(n)]\n    q = deque([(0, 0, 0), (0, 0, 1)])  # (node, distance, color)\n    visited = set()\n\n    while q:\n        node, dist, color = q.popleft()\n        if (node, color) in visited:\n            continue\n        visited.add((node, color))\n        if answer[node] == -1:\n            answer[node] = dist\n        if color == 0:\n            for neighbor in blue_graph[node]:\n                q.append((neighbor, dist + 1, 1))\n        else:\n            for neighbor in red_graph[node]:\n                q.append((neighbor, dist + 1, 0))\n\n    return answer\n\n\nn = 3\nred_edges = [[0, 1], [1, 2]]\nblue_edges = []\nprint(shortestAlternatingPaths(n, red_edges, blue_edges))  # [0, 1, -1]\n</code></pre>"},{"location":"graph_theory/standard_traversal/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, breadth first search</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre>"},{"location":"graph_theory/standard_traversal/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph</li> <li></li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"graph_theory/standard_traversal/#797-all-paths-from-source-to-target","title":"797. All Paths From Source to Target","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: backtracking, depth first search, breadth first search, graph</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS - Backtracking\ndef allPathsSourceTargetDFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    result = []\n    n = len(graph)\n\n    def dfs(node, path):\n        if node == n - 1:\n            result.append(path.copy())\n            return None\n\n        for nei in graph[node]:\n            path.append(nei)\n            dfs(nei, path)\n            path.pop()\n\n    dfs(0, [0])\n\n    return result\n\n\n# BFS\ndef allPathsSourceTargetBFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    n = len(graph)\n    result = []\n    q = deque([(0, [0])])\n\n    while q:\n        node, path = q.popleft()\n\n        if node == n - 1:\n            result.append(path)\n\n        for nei in graph[node]:\n            q.append((nei, path + [nei]))\n\n    return result\n\n\ngraph = [[1, 2], [3], [3], []]\nprint(allPathsSourceTargetDFS(graph))  # [[0, 1, 3], [0, 2, 3]]\nprint(allPathsSourceTargetBFS(graph))  # [[0, 1, 3], [0, 2, 3]]\n</code></pre>"},{"location":"graph_theory/standard_traversal/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: depth first search, graph, biconnected component</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"graph_theory/topological_sort/","title":"Topological Sort","text":""},{"location":"graph_theory/topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"graph_theory/topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"graph_theory/topological_sort/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, depth first search, breadth first search, graph, topological sort</li> <li>Return the correct order of characters in the alien language.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"graph_theory/topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return any permutation of the items that satisfies the requirements.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"graph_theory/topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, dynamic programming, graph, topological sort, memoization, counting</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"graph_theory/union_find/","title":"Union Find","text":""},{"location":"graph_theory/union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"graph_theory/union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, union find, graph</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"graph_theory/union_find/#1061-lexicographically-smallest-equivalent-string","title":"1061. Lexicographically Smallest Equivalent String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, union find</li> </ul> <pre><code># Union Find\ndef smallestEquivalentString(s1: str, s2: str, baseStr: str) -&gt; str:\n    parent = {chr(i): chr(i) for i in range(ord(\"a\"), ord(\"z\") + 1)}\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if p1 &lt; p2:\n                parent[p2] = p1\n            else:\n                parent[p1] = p2\n\n    for i in range(len(s1)):\n        union(s1[i], s2[i])\n\n    result = []\n    for c in baseStr:\n        result.append(find(c))\n\n    return \"\".join(result)\n\n\ns1 = \"parker\"\ns2 = \"morris\"\nbaseStr = \"parser\"\nprint(smallestEquivalentString(s1, s2, baseStr))  # \"makkek\"\n</code></pre>"},{"location":"graph_theory/union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, hash table, string, depth first search, breadth first search, union find</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"grind75/","title":"Grind 75","text":""},{"location":"grind75/array/","title":"Array","text":""},{"location":"grind75/array/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table</li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) <pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"grind75/array/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"grind75/array/#169-majority-element","title":"169. Majority Element","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, divide and conquer, sorting, counting</li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"grind75/array/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, sorting</li> <li>Return True if the array contains any duplicates, otherwise return False.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"grind75/array/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array</li> </ul> <pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"grind75/array/#15-3sum","title":"15. 3Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# |-----------|---------|---------|\n# | Approach  |   Time  |  Space  |\n# |-----------|---------|---------|\n# | LR Pointer|  O(n^2) |   O(1)  |\n# |-----------|---------|---------|\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))  # [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"grind75/array/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# 2. Prefix - Optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |    Prefix   |    O(n)     |    O(n)      |\n# |Prefix - Opt |    O(n)     |    O(1)      |\n# |-------------|-------------|--------------|\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"grind75/array/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"grind75/array/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, sorting</li> <li>Merge all overlapping intervals.</li> </ul> <pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"grind75/array/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortColors(nums: List[int]) -&gt; None:\n    \"\"\"Sorts an array of 0, 1, and 2 in-place.\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    current = 0\n\n    while current &lt;= right:\n        if nums[current] == 0:\n            nums[left], nums[current] = nums[current], nums[left]\n            left += 1\n            current += 1\n        elif nums[current] == 2:\n            nums[right], nums[current] = nums[current], nums[right]\n            right -= 1\n        else:\n            current += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nsortColors(nums)\nprint(nums)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"grind75/array/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, greedy</li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"grind75/binary/","title":"Binary","text":""},{"location":"grind75/binary/#67-add-binary","title":"67. Add Binary","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, string, bit manipulation, simulation</li> </ul>"},{"location":"grind75/binary_search/","title":"Binary Search","text":""},{"location":"grind75/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, binary search</li> <li>Implement binary search algorithm.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &gt; target:\n            right = mid - 1\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            return mid\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"grind75/binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: binary search, interactive</li> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> <pre><code># Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"grind75/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> </ul>"},{"location":"grind75/binary_search/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, binary search, design</li> </ul>"},{"location":"grind75/binary_search/#1235-maximum-profit-in-job-scheduling","title":"1235. Maximum Profit in Job Scheduling","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, dynamic programming, sorting</li> </ul>"},{"location":"grind75/binary_search_tree/","title":"Binary Search Tree","text":""},{"location":"grind75/binary_search_tree/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"grind75/binary_search_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"grind75/binary_search_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"grind75/binary_tree/","title":"Binary Tree","text":""},{"location":"grind75/binary_tree/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"grind75/binary_tree/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"grind75/binary_tree/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# Tree DFS\ndef diameterOfBinaryTree(root: Optional[TreeNode]) -&gt; int:\n    diameter = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left = dfs(node.left)\n        right = dfs(node.right)\n\n        nonlocal diameter\n        diameter = max(diameter, left + right)\n\n        return 1 + max(left, right)\n\n    dfs(root)\n    return diameter\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n)    | O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nprint(diameterOfBinaryTree(root))  # 3\n</code></pre>"},{"location":"grind75/binary_tree/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return depth\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    return 1 + max(maxDepthRecursive(root.left), maxDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthRecursive(root))  # 4\n</code></pre>"},{"location":"grind75/binary_tree/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"grind75/binary_tree/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre>"},{"location":"grind75/binary_tree/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, breadth first search, binary tree <pre><code>    ____1       &lt;---\n   /     \\\n  2__     2     &lt;--- Look at the rightmost node at each level\n /   \\     \\\n3     4     3   &lt;---\n     /\n    5           &lt;---\n</code></pre></li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n\n        for i in range(n):\n            cur = q.popleft()\n\n            # rightmost element\n            if i == n - 1:\n                res.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"grind75/binary_tree/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, tree, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"grind75/binary_tree/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: string, tree, depth first search, breadth first search, design, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"grind75/dynamic_programming/","title":"Dynamic Programming","text":""},{"location":"grind75/dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, dynamic programming, memoization</li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 <pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"grind75/dynamic_programming/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"grind75/dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, breadth first search</li> </ul> <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"grind75/dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\nfrom template import knapsack01\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nnums = [1, 5, 11, 5]\nprint(canPartitionTemplate(nums))  # True\nprint(canPartition(nums))  # True\n</code></pre>"},{"location":"grind75/dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, dynamic programming, combinatorics</li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"grind75/graph/","title":"Graph","text":""},{"location":"grind75/graph/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, depth first search, breadth first search, matrix</li> <li>Replace all the pixels of the same color starting from the given pixel.</li> <li>In other words, find the connected component of the starting pixel and change the color of all the pixels in that component.</li> <li>Edge cases: If the starting pixel is already the target color, return the image as it is.</li> <li>Flood Fill is essentially a graph traversal algorithm (like BFS or DFS) applied to matrices (2D grids).     It checks adjacent cells (up, down, left, right) of a starting point to determine whether they belong to the same region.     Typically, it involves modifying or marking the cells that belong to the same connected component.</li> </ul> 1 1 1 1 1 0 1 0 1 1 1 1 1 2 0 1 0 1 1 2 1 2 2 0 1 0 1 2 2 2 2 2 0 2 0 1 <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef floodFillDFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if org == color:\n        return image\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or image[r][c] != org:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# BFS\ndef floodFillBFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if org == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        r, c = q.popleft()\n        image[r][c] = color\n\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and image[nr][nc] == org:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre>"},{"location":"grind75/graph/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre>"},{"location":"grind75/graph/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, depth first search, breadth first search, graph</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre>"},{"location":"grind75/graph/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"grind75/graph/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"grind75/graph/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, breadth first search, matrix</li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    # 1. Init\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    # 2. Make a queue of rotten oranges and count fresh oranges\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    # 3. BFS\n    while q and fresh &gt; 0:\n        size = len(q)\n\n        for _ in range(size):\n            r, c = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if nr &lt; 0 or nc &lt; 0 or nr &gt;= m or nc &gt;= n or grid[nr][nc] != 1:\n                    continue\n                grid[nr][nc] = 2\n                q.append([nr, nc])\n                fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"grind75/graph/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"grind75/graph/#79-word-search","title":"79. Word Search","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, backtracking, depth first search, matrix</li> </ul> <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"grind75/graph/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> </ul>"},{"location":"grind75/graph/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, breadth first search</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # Edge case\n    if endWord not in wordList:\n        return 0\n\n    # Init\n    graph = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    # BFS\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\n# |------------|---------|---------|\n# |  Approach  |  Time   |  Space  |\n# |------------|---------|---------|\n# |    BFS     | O(n*m^2)| O(n*m)  |\n# |------------|---------|---------|\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"grind75/hash_table/","title":"Hash Table","text":""},{"location":"grind75/hash_table/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, string, counting</li> <li>Return <code>True</code> if the ransom note can be constructed from the magazines, otherwise, return <code>False</code>.</li> </ul> <pre><code>graph LR\n    A[\"Magazine: abcdef\"] --&gt; C(True)\n    B[\"Ransom Note: abc\"] --&gt; C</code></pre> <pre><code>from collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"grind75/heap/","title":"Heap","text":""},{"location":"grind75/heap/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, math, divide and conquer, geometry, sorting, heap priority queue, quickselect</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"grind75/heap/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, greedy, sorting, heap priority queue, counting</li> </ul> <pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"grind75/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: two pointers, design, sorting, heap priority queue, data stream</li> </ul> <pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"grind75/heap/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: linked list, divide and conquer, heap priority queue, merge sort</li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> <pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"grind75/linked_list/","title":"Linked List","text":""},{"location":"grind75/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: linked list, recursion</li> <li>Merge the two lists into one sorted list.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre>"},{"location":"grind75/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, linked list, two pointers</li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]</code></pre> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"grind75/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: linked list, recursion</li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[3]\nC --&gt; D[4]\nD --&gt; E[5]</code></pre> <pre><code>graph RL\nE[5] --&gt; D[4]\nD --&gt; C[3]\nC --&gt; B[2]\nB --&gt; A[1]</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"grind75/linked_list/#876-middle-of-the-linked-list","title":"876. Middle of the Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: linked list, two pointers</li> </ul>"},{"location":"grind75/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list, design, doubly linked list</li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. Approach Time Complexity Space Complexity LRU O(1) O(n) <pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre>"},{"location":"grind75/matrix/","title":"Matrix","text":""},{"location":"grind75/matrix/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, matrix, simulation</li> <li>Return all elements of the matrix in spiral order.</li> </ul> <pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"grind75/recursion/","title":"Recursion","text":""},{"location":"grind75/recursion/#46-permutations","title":"46. Permutations","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"grind75/recursion/#78-subsets","title":"78. Subsets","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking, bit manipulation</li> </ul> <pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"grind75/recursion/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letterMap = [\n        \"\",  # 0\n        \"\",  # 1\n        \"abc\",  # 2\n        \"def\",  # 3\n        \"ghi\",  # 4\n        \"jkl\",  # 5\n        \"mno\",  # 6\n        \"pqrs\",  # 7\n        \"tuv\",  # 8\n        \"wxyz\",  # 9\n    ]\n    res = []\n\n    def backtracking(index, s):\n        if index == len(digits):\n            res.append(s)\n            return None\n\n        digit = int(digits[index])\n        letters = letterMap[digit]\n\n        for i in range(len(letters)):\n            backtracking(index + 1, s + letters[i])\n\n    if len(digits) == 0:\n        return res\n\n    backtracking(0, \"\")\n\n    return res\n\n\nprint(letterCombinations(\"23\"))\n# ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n</code></pre>"},{"location":"grind75/stack/","title":"Stack","text":""},{"location":"grind75/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, stack</li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" <pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"grind75/stack/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: stack, design, queue</li> <li>Implement the following operations of a queue using stacks.<ul> <li><code>push(x)</code> - Push element x to the back of queue.</li> <li><code>pop()</code> - Removes the element from in front of queue.</li> <li><code>peek()</code> - Get the front element.</li> <li><code>empty()</code> - Return whether the queue is empty.</li> </ul> </li> </ul> <pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"grind75/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, math, stack</li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> <pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"grind75/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: stack, design</li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> <pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"grind75/stack/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, two pointers, dynamic programming, stack, monotonic stack</li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) <pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"grind75/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: math, string, stack, recursion</li> </ul> <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"grind75/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, stack, monotonic stack</li> </ul> <pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"grind75/string/","title":"String","text":""},{"location":"grind75/string/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string</li> </ul> <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"grind75/string/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, string, sorting</li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> <pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"grind75/string/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, string, greedy</li> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> <pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"grind75/string/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(len(s)):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"grind75/string/#8-string-to-integer-atoi","title":"8. String to Integer (atoi)","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string</li> </ul>"},{"location":"grind75/string/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string, dynamic programming</li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> <pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"grind75/string/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"grind75/string/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"grind75/trie/","title":"Trie","text":""},{"location":"grind75/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, design, trie</li> </ul>"},{"location":"grind75/trie/#trie_1","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"grind75/trie/#139-word-break","title":"139. Word Break","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, dynamic programming, trie, memoization</li> </ul> <pre><code>from typing import List\n\n\n# DP - Knapsack Unbounded\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"leetpattern/","title":"LeetPattern","text":""},{"location":"leetpattern/array/","title":"Array","text":""},{"location":"leetpattern/array/#414-third-maximum-number","title":"414. Third Maximum Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, sorting</li> <li>Return the third maximum number in an array. If the third maximum does not exist, return the maximum number.</li> </ul> <pre><code>from typing import List\n\n\n# Sort\ndef thirdMaxSort(nums: List[int]) -&gt; int:\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n\n    return nums[2] if len(nums) &gt;= 3 else nums[0]\n\n\n# Compare\ndef thirdMaxCompare(nums: List[int]) -&gt; int:\n    first, second, third = float(\"-inf\"), float(\"-inf\"), float(\"-inf\")\n\n    for num in nums:\n        if num &gt; first:\n            first, second, third = num, first, second\n        elif first &gt; num &gt; second:\n            second, third = num, second\n        elif second &gt; num &gt; third:\n            third = num\n\n    return third if third != float(\"-inf\") else first\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Sort     |    O(NlogN)     |     O(N)     |\n# |  Compare    |       O(N)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(thirdMaxSort([3, 2, 1]))  # 1\nprint(thirdMaxCompare([3, 2, 1]))  # 1\n</code></pre>"},{"location":"leetpattern/array/#169-majority-element","title":"169. Majority Element","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, divide and conquer, sorting, counting</li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"leetpattern/array/#2022-convert-1d-array-into-2d-array","title":"2022. Convert 1D Array Into 2D Array","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, matrix, simulation</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef construct2DArray(original: List[int], m: int, n: int) -&gt; List[List[int]]:\n    if len(original) != m * n:\n        return []\n    array = []\n\n    for i in range(m):\n        row = original[n * i : n * (i + 1)]\n        array.append(row)\n\n    return array\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Brute     |  O(m)  |  O(1)   |\n# |------------|--------|---------|\n\n\noriginal = [1, 2, 3, 4]\nm = 2\nn = 2\n\nprint(construct2DArray(original, m, n))  # [[1, 2], [3, 4]]\n</code></pre>"},{"location":"leetpattern/array/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, matrix, simulation</li> <li>Return all elements of the matrix in spiral order.</li> </ul> <pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"leetpattern/array/#59-spiral-matrix-ii","title":"59. Spiral Matrix II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, matrix, simulation</li> <li>Return a square matrix filled with elements from 1 to n^2 in spiral order.</li> </ul> <pre><code>from pprint import pprint\nfrom typing import List\n\n\n# Array\ndef generateMatrix(n: int) -&gt; List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n\n    for layer in range((n + 1) // 2):\n        for i in range(layer, n - layer):\n            matrix[layer][i] = num\n            num += 1\n        for j in range(layer + 1, n - layer):\n            matrix[j][n - 1 - layer] = num\n            num += 1\n        for i in range(n - 2 - layer, layer - 1, -1):\n            matrix[n - 1 - layer][i] = num\n            num += 1\n        for j in range(n - 2 - layer, layer, -1):\n            matrix[j][layer] = num\n            num += 1\n\n    return matrix\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Layer     |      O(N^2)     |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\npprint(generateMatrix(5))\n# [[ 1,  2,  3,  4, 5],\n#  [16, 17, 18, 19, 6],\n#  [15, 24, 25, 20, 7],\n#  [14, 23, 22, 21, 8],\n#  [13, 12, 11, 10, 9]]\n</code></pre>"},{"location":"leetpattern/backtracking/","title":"Backtracking","text":""},{"location":"leetpattern/backtracking/#77-combinations","title":"77. Combinations","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: backtracking</li> </ul> <pre><code>import itertools\nfrom typing import List\n\n\n# Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(1, [])\n\n    return res\n\n\n# itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre>"},{"location":"leetpattern/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letterMap = [\n        \"\",  # 0\n        \"\",  # 1\n        \"abc\",  # 2\n        \"def\",  # 3\n        \"ghi\",  # 4\n        \"jkl\",  # 5\n        \"mno\",  # 6\n        \"pqrs\",  # 7\n        \"tuv\",  # 8\n        \"wxyz\",  # 9\n    ]\n    res = []\n\n    def backtracking(index, s):\n        if index == len(digits):\n            res.append(s)\n            return None\n\n        digit = int(digits[index])\n        letters = letterMap[digit]\n\n        for i in range(len(letters)):\n            backtracking(index + 1, s + letters[i])\n\n    if len(digits) == 0:\n        return res\n\n    backtracking(0, \"\")\n\n    return res\n\n\nprint(letterCombinations(\"23\"))\n# ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n</code></pre>"},{"location":"leetpattern/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"leetpattern/backtracking/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"leetpattern/backtracking/#216-combination-sum-iii","title":"216. Combination Sum III","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combinationSum3(k: int, n: int) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(start):\n        if len(path) == k and sum(path) == n:\n            result.append(path[:])\n            return\n\n        for i in range(start, 10):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(1)\n\n    return result\n\n\n# 2. Itertools\ndef combinationSum3Itertools(k: int, n: int) -&gt; List[List[int]]:\n    combinations = itertools.combinations(range(1, 10), k)\n    result = []\n\n    for i in combinations:\n        if sum(i) == n:\n            result.append(i)\n\n    return result\n\n\nprint(combinationSum3(3, 7))  # [[1, 2, 4]]\nprint(combinationSum3Itertools(3, 7))  # [(1, 2, 4)]\n</code></pre>"},{"location":"leetpattern/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef partition(s: str) -&gt; List[List[str]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if startIndex == len(s):\n            result.append(path[:])\n            return None\n\n        for i in range(startIndex, len(s)):\n            if is_palindrome(s, startIndex, i):\n                path.append(s[startIndex : i + 1])\n                backtracking(i + 1)\n                path.pop()\n\n    def is_palindrome(s: str, start, end) -&gt; bool:\n        while start &lt; end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n\n        return True\n\n    backtracking(0)\n\n    return result\n\n\nprint(partition(\"aab\"))  # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"leetpattern/backtracking/#93-restore-ip-addresses","title":"93. Restore IP Addresses","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef restoreIpAddresses(s: str) -&gt; List[str]:\n    result = []\n\n    def backtracking(start_index, point_num, current, result):\n        # stop condition\n        if point_num == 3:\n            if is_valid(s, start_index, len(s) - 1):\n                current += s[start_index:]\n                result.append(current)\n            return\n\n        for i in range(start_index, len(s)):\n            if is_valid(s, start_index, i):\n                sub = s[start_index : i + 1]\n                backtracking(i + 1, point_num + 1, current + sub + \".\", result)\n            else:\n                break\n\n    def is_valid(s, start, end):\n        if start &gt; end:\n            return False\n\n        if s[start] == \"0\" and start != end:\n            return False\n\n        num = 0\n        for i in range(start, end + 1):\n            if not s[i].isdigit():\n                return False\n            num = num * 10 + int(s[i])\n            if num &gt; 255:\n                return False\n        return True\n\n    backtracking(0, 0, \"\", result)\n\n    return result\n\n\nprint(restoreIpAddresses(\"25525511135\"))\n# ['255.255.11.135', '255.255.111.35']\n</code></pre>"},{"location":"leetpattern/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking, bit manipulation</li> </ul> <pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"leetpattern/backtracking/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking, bit manipulation</li> </ul> <pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"leetpattern/backtracking/#491-non-decreasing-subsequences","title":"491. Non-decreasing Subsequences","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, backtracking, bit manipulation</li> </ul> <pre><code>from typing import List\n\n\ndef findSubsequences(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if len(path) &gt; 1:\n            result.append(path[:])\n\n        used = set()\n        for i in range(startIndex, len(nums)):\n\n            if (path and nums[i] &lt; path[-1]) or nums[i] in used:\n                continue\n\n            used.add(nums[i])\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(0)\n\n    return result\n\n\nprint(findSubsequences([4, 6, 7, 7]))\n# [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]\n</code></pre>"},{"location":"leetpattern/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"leetpattern/backtracking/#47-permutations-ii","title":"47. Permutations II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking, sorting</li> </ul> <pre><code>from typing import List\n\n\ndef permuteUnique(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permuteUnique([1, 1, 2]))\n# [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n</code></pre>"},{"location":"leetpattern/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, backtracking</li> <li>Hard</li> <li>N-Queens</li> <li>N \u7687\u540e</li> </ul> <pre><code>from typing import List\n\n\n# Backtracking - Board\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    result = []\n    chessboard = [\".\" * n for _ in range(n)]\n\n    def backtracking(row):\n        if row == n:\n            result.append(chessboard[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, chessboard):\n                chessboard[row] = (\n                    chessboard[row][:col] + \"Q\" + chessboard[row][col + 1 :]\n                )\n                backtracking(row + 1)\n                chessboard[row] = (\n                    chessboard[row][:col] + \".\" + chessboard[row][col + 1 :]\n                )\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    backtracking(0)\n\n    return [[\"\".join(row) for row in solution] for solution in result]\n\n\nprint(solveNQueens(4))\n# [['.Q..', '...Q', 'Q...', '..Q.'],\n#  ['..Q.', 'Q...', '...Q', '.Q..']]\n</code></pre>"},{"location":"leetpattern/backtracking/#37-sudoku-solver","title":"37. Sudoku Solver","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, hash table, backtracking, matrix</li> <li>Sudoku Solver</li> <li>\u89e3\u6570\u72ec</li> <li>Hard</li> </ul> <pre><code>from pprint import pprint\nfrom typing import List\n\n\n# Backtracking - Board\ndef solveSudoku(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n\n    def backtracking(board: List[List[str]]) -&gt; bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] != \".\":\n                    continue\n                for k in range(1, 10):\n                    if is_valid(i, j, k, board):\n                        board[i][j] = str(k)\n                        if backtracking(board):\n                            return True\n                        board[i][j] = \".\"\n                return False\n        return True\n\n    def is_valid(row: int, col: int, val: int, board: List[List[str]]) -&gt; bool:\n        for i in range(9):\n            if board[row][i] == str(val):\n                return False\n        for j in range(9):\n            if board[j][col] == str(val):\n                return False\n        start_row = (row // 3) * 3\n        start_col = (col // 3) * 3\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == str(val):\n                    return False\n        return True\n\n    backtracking(board)\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\n\nsolveSudoku(board)\npprint(board)\n# [['5', '3', '4', '6', '7', '8', '9', '1', '2'],\n#  ['6', '7', '2', '1', '9', '5', '3', '4', '8'],\n#  ['1', '9', '8', '3', '4', '2', '5', '6', '7'],\n#  ['8', '5', '9', '7', '6', '1', '4', '2', '3'],\n#  ['4', '2', '6', '8', '5', '3', '7', '9', '1'],\n#  ['7', '1', '3', '9', '2', '4', '8', '5', '6'],\n#  ['9', '6', '1', '5', '3', '7', '2', '8', '4'],\n#  ['2', '8', '7', '4', '1', '9', '6', '3', '5'],\n#  ['3', '4', '5', '2', '8', '6', '1', '7', '9']]\n</code></pre>"},{"location":"leetpattern/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, backtracking, depth first search, matrix</li> </ul> <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"leetpattern/backtracking/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, backtracking, trie, matrix</li> </ul> <pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"leetpattern/binary_search/","title":"Binary Search","text":""},{"location":"leetpattern/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, binary search</li> <li>Implement binary search algorithm.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &gt; target:\n            right = mid - 1\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            return mid\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"leetpattern/binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, binary search</li> <li>Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &gt; target:\n            right = mid - 1\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre>"},{"location":"leetpattern/binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: binary search, interactive</li> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> <pre><code># Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"leetpattern/binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> <li>Find the starting and ending position of a given target value in a sorted array.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef searchRange(nums: List[int], target: int) -&gt; List[int]:\n\n    def insertPosition(nums, target):\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    left = insertPosition(nums, target)\n    right = insertPosition(nums, target + 1) - 1\n\n    if left == len(nums) or nums[left] != target:\n        return [-1, -1]\n\n    return [left, right]\n\n\nnums = [5, 7, 7, 8, 8, 10]\ntarget = 8\nprint(searchRange(nums, target))  # [3, 4]\n</code></pre>"},{"location":"leetpattern/binary_search/#367-valid-perfect-square","title":"367. Valid Perfect Square","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, binary search</li> <li>Determine if a positive integer is a perfect square without using any built-in library function.</li> </ul> <pre><code># Binary Search\ndef isPerfectSquare(num: int) -&gt; bool:\n    if num &lt; 2:\n        return True\n\n    left, right = 0, num // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if mid * mid == num:\n            return True\n        elif mid * mid &lt; num:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nnum = 16\nprint(isPerfectSquare(num))  # True\n</code></pre>"},{"location":"leetpattern/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"leetpattern/binary_search/#1011-capacity-to-ship-packages-within-d-days","title":"1011. Capacity To Ship Packages Within D Days","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> <li>A conveyor belt has packages that must be shipped from one port to another within <code>D</code> days. The <code>i-th</code> package has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt. The ship will be loaded with packages up to its capacity. The ship will not be loaded beyond its capacity. Return the least weight capacity of the ship.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef shipWithinDays(weights: List[int], days: int) -&gt; int:\n\n    def canShip(weights, D, capacity):\n        days = 1\n        current_weight = 0\n\n        for weight in weights:\n            if current_weight + weight &gt; capacity:\n                days += 1\n                current_weight = 0\n            current_weight += weight\n\n        return days &lt;= D\n\n    left, right = max(weights), sum(weights)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canShip(weights, days, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\nweights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndays = 5\nprint(shipWithinDays(weights, days))  # 15\n</code></pre>"},{"location":"leetpattern/binary_search/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, sorting, heap priority queue, matrix</li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> <pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"leetpattern/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"leetpattern/bit_manipulation/#2595-number-of-even-and-odd-bits","title":"2595. Number of Even and Odd Bits","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: bit manipulation</li> <li>Topic: Bit Manipulation</li> <li>Difficulty: Easy</li> </ul> <p>You are given a positive integer n. Let even denote the number of even indices in the binary representation of n with value 1. Let odd denote the number of odd indices in the binary representation of n with value 1. Note that bits are indexed from right to left in the binary representation of a number. Return the array [even, odd].</p>"},{"location":"leetpattern/boyer_moore/","title":"Boyer Moore","text":""},{"location":"leetpattern/boyer_moore/#169-majority-element","title":"169. Majority Element","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, divide and conquer, sorting, counting</li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"leetpattern/boyer_moore/#229-majority-element-ii","title":"229. Majority Element II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, sorting, counting</li> </ul> <pre><code>from collections import Counter\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHash(nums: List[int]) -&gt; List[int]:\n    counts = Counter(nums)\n    target = len(nums) // 3\n    res = []\n\n    for num in nums:\n        if counts[num] &gt; target and num not in res:\n            res.append(num)\n\n    return res\n\n\n# Boyer-Moore\ndef majorityElementMoore(nums: List[int]) -&gt; List[int]:\n    if not nums:\n        return []\n\n    cdt1, cnt1 = None, 0\n    cdt2, cnt2 = None, 0\n\n    for num in nums:\n        if num == cdt1:\n            cnt1 += 1\n        elif num == cdt2:\n            cnt2 += 1\n        elif cnt1 == 0:\n            cdt1, cnt1 = num, 1\n        elif cnt2 == 0:\n            cdt2, cnt2 = num, 1\n        else:\n            cnt1 -= 1\n            cnt2 -= 1\n\n    return [n for n in (cdt1, cdt2) if nums.count(n) &gt; len(nums) // 3]\n\n\nnums = [3, 2, 3]\nprint(majorityElementHash(nums))  # [3]\nprint(majorityElementMoore(nums))  # [3]\n</code></pre>"},{"location":"leetpattern/boyer_moore/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, binary search, bit manipulation</li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> </ul> <pre><code>from typing import List\n\n\n# Fast Slow Pointer\ndef findDuplicate(nums: List[int]) -&gt; int:\n\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\n# | Algorithm          | TC   | SC   |\n# |--------------------|------|------|\n# | Fast Slow Pointer  | O(n) | O(1) |\n# |--------------------|------|------|\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"leetpattern/boyer_moore/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, binary search</li> </ul>"},{"location":"leetpattern/boyer_moore/#1157-online-majority-element-in-subarray","title":"1157. Online Majority Element In Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, design, binary indexed tree, segment tree</li> </ul>"},{"location":"leetpattern/boyer_moore/#495-teemo-attacking","title":"495. Teemo Attacking","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, simulation</li> </ul>"},{"location":"leetpattern/bst/","title":"BST","text":""},{"location":"leetpattern/bst/#700-search-in-a-binary-search-tree","title":"700. Search in a Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, binary search tree, binary tree</li> </ul>"},{"location":"leetpattern/bst/#binary-search-tree","title":"Binary Search Tree","text":"<ol> <li>Binary Tree</li> <li>Left subtree of a node contains only nodes with keys less than the node's key</li> <li>Right subtree of a node contains only nodes with keys greater than the node's key</li> <li>The left and right subtree each must also be a binary search tree</li> <li>There must be no duplicate nodes</li> <li>Inorder traversal of a BST gives a sorted list of keys</li> </ol> <pre><code>graph TD\n4((4)) --- 2((2))\n4 --- 7((7))\n2 --- 1((1))\n2 --- 3((3))</code></pre> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef searchBSTRecursive(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if root.val &gt; val:\n        return searchBSTRecursive(root.left, val)\n\n    elif root.val &lt; val:\n        return searchBSTRecursive(root.right, val)\n\n    else:\n        return root\n\n\n# 2. Iterative\ndef searchBSTIterative(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    while root:\n        if root.val &gt; val:\n            root = root.left\n        elif root.val &lt; val:\n            root = root.right\n        else:\n            return root\n    return None\n\n\nroot = [4, 2, 7, 1, 3]\nval = 2\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     7\n#  / \\\n# 1   3\nprint(searchBSTRecursive(root, val))\n#   2\n#  / \\\n# 1   3\nprint(searchBSTIterative(root, val))\n#   2\n#  / \\\n# 1   3\n</code></pre>"},{"location":"leetpattern/bst/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"leetpattern/bst/#530-minimum-absolute-difference-in-bst","title":"530. Minimum Absolute Difference in BST","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n\n    inorder = []\n    result = float(\"inf\")\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        result = min(result, abs(inorder[i] - inorder[i - 1]))\n\n    return result\n\n\nroot = [4, 2, 6, 1, 3]\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\nprint(getMinimumDifference(root))  # 1\n</code></pre>"},{"location":"leetpattern/bst/#501-find-mode-in-binary-search-tree","title":"501. Find Mode in Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findMode(root: Optional[TreeNode]) -&gt; List[int]:\n    hashmap = dict()\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        if node.val not in hashmap:\n            hashmap[node.val] = 1\n        else:\n            hashmap[node.val] += 1\n        dfs(node.right)\n\n    dfs(root)\n    max_counts = max(hashmap.values())\n    result = []\n\n    for key, value in hashmap.items():\n        if value == max_counts:\n            result.append(key)\n\n    return result\n\n\nroot = [1, None, 2, None, None, 2]\nroot = build(root)\nprint(root)\n# 1__\n#    \\\n#     2\n#    /\n#   2\nprint(findMode(root))  # [2]\n</code></pre>"},{"location":"leetpattern/bst/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"leetpattern/bst/#701-insert-into-a-binary-search-tree","title":"701. Insert into a Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef insertIntoBST(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return TreeNode(val)\n\n    if root.val &gt; val:\n        root.left = insertIntoBST(root.left, val)\n    if root.val &lt; val:\n        root.right = insertIntoBST(root.right, val)\n\n    return root\n\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\n\ninsertIntoBST(root, 5)\n#     __4\n#    /   \\\n#   2     6\n#  / \\   /\n# 1   3 5\n</code></pre>"},{"location":"leetpattern/bst/#450-delete-node-in-a-bst","title":"450. Delete Node in a BST","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef deleteNode(root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return root\n\n    if root.val == key:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            cur = root.right\n            while cur.left is not None:\n                cur = cur.left\n            cur.left = root.left\n            return root.right\n\n    if root.val &gt; key:\n        root.left = deleteNode(root.left, key)\n    if root.val &lt; key:\n        root.right = deleteNode(root.right, key)\n\n    return root\n\n\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.right = TreeNode(7)\n#     __5\n#    /   \\\n#   3     6\n#  / \\     \\\n# 2   4     7\n\ndeleteNode(root, 3)\n#     __5\n#    /   \\\n#   4     6\n#  /       \\\n# 2         7\n</code></pre>"},{"location":"leetpattern/bst/#669-trim-a-binary-search-tree","title":"669. Trim a Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef trimBST(\n    root: Optional[TreeNode], low: int, high: int\n) -&gt; Optional[TreeNode]:\n    if root is None:\n        return None\n\n    if root.val &lt; low:\n        return trimBST(root.right, low, high)\n    if root.val &gt; high:\n        return trimBST(root.left, low, high)\n\n    root.left = trimBST(root.left, low, high)\n    root.right = trimBST(root.right, low, high)\n\n    return root\n\n\nroot = TreeNode(3)\nroot.left = TreeNode(0)\nroot.right = TreeNode(4)\nroot.left.right = TreeNode(2)\nroot.left.right.left = TreeNode(1)\n#     __3\n#    /   \\\n#   0     4\n#    \\\n#     2\n#    /\n#   1\n\ntrimBST(root, 1, 3)\n#     __3\n#    /\n#   2\n#  /\n# 1\n</code></pre>"},{"location":"leetpattern/bst/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, divide and conquer, tree, binary search tree, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"leetpattern/bst/#109-convert-sorted-list-to-binary-search-tree","title":"109. Convert Sorted List to Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, divide and conquer, tree, binary search tree, binary tree </li> </ul> <pre><code>from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedListToBST(head: Optional[ListNode]) -&gt; Optional[TreeNode]:\n    if not head:\n        return None\n\n    def find_mid(head: ListNode) -&gt; ListNode:\n        prev = None\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if prev:\n            prev.next = None\n\n        return slow\n\n    mid = find_mid(head)\n\n    node = TreeNode(mid.val)\n\n    if head == mid:\n        return node\n\n    node.left = sortedListToBST(head)\n    node.right = sortedListToBST(mid.next)\n\n    return node\n\n\nhead = ListNode(-10)\nhead.next = ListNode(-3)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(5)\nhead.next.next.next.next = ListNode(9)\n\nroot = sortedListToBST(head)\nassert root.val == 0\nassert root.left.val == -3\nassert root.left.left.val == -10\nassert root.right.val == 9\nassert root.right.left.val == 5\nprint(\"All passed\")\n\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"leetpattern/bst/#538-convert-bst-to-greater-tree","title":"538. Convert BST to Greater Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree </li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef convertBST(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    prev = 0\n\n    def dfs(node):\n        if not node:\n            return None\n        nonlocal prev\n\n        dfs(node.right)\n\n        node.val += prev\n        prev = node.val\n\n        dfs(node.left)\n\n    dfs(root)\n\n    return root\n\n\nroot = [4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8]\nroot = build(root)\nprint(root)\n#     ____4__\n#    /       \\\n#   1         6\n#  / \\       / \\\n# 0   2     5   7\n#      \\         \\\n#       3         8\ngreater_tree = convertBST(root)\nprint(greater_tree)\n#      _______30___\n#     /            \\\n#   _36            _21\n#  /   \\          /   \\\n# 36    35       26    15\n#         \\              \\\n#          33             8\n</code></pre>"},{"location":"leetpattern/bst/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"leetpattern/bst/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: stack, tree, design, binary search tree, binary tree, iterator</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre>"},{"location":"leetpattern/bst/#1586-binary-search-tree-iterator-ii","title":"1586. Binary Search Tree Iterator II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: stack, tree, design, binary search tree, binary tree, iterator</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# BST\nclass BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.nodes = self._inorder(root)\n        self.index = -1\n        self.size = len(self.nodes)\n\n    def _inorder(self, node):\n        if not node:\n            return []\n        return (\n            self._inorder(node.left) + [node.val] + self._inorder(node.right)\n        )\n\n    def hasNext(self) -&gt; bool:\n        return self.index &lt; self.size - 1\n\n    def next(self) -&gt; int:\n        self.index += 1\n        return self.nodes[min(self.index, self.size - 1)]\n\n    def hasPrev(self) -&gt; bool:\n        return self.index &gt; 0\n\n    def prev(self) -&gt; int:\n        self.index -= 1\n        return self.nodes[max(self.index, 0)]\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\nprint(obj.prev())  # 3\nprint(obj.prev())  # None\n</code></pre>"},{"location":"leetpattern/design/","title":"Design","text":""},{"location":"leetpattern/design/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list, design, doubly linked list</li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. Approach Time Complexity Space Complexity LRU O(1) O(n) <pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre>"},{"location":"leetpattern/design/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list, design, heap priority queue</li> <li>Similar question: 23. Merge K Sorted Lists (Hard)</li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"leetpattern/design/#588-design-in-memory-file-system","title":"588. Design In-Memory File System","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, design, trie, sorting</li> </ul> <pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre>"},{"location":"leetpattern/design/#460-lfu-cache","title":"460. LFU Cache","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, linked list, design, doubly linked list</li> </ul> <pre><code>from collections import defaultdict\n\n\nclass Node:\n    def __init__(self, key: int, value: int):\n        self.key = key\n        self.value = value\n        self.freq = 1\n\n\nclass DoubleLinkedList:\n    def __init__(self):\n        self.head = Node(0, 0)  # dummy head\n        self.tail = Node(0, 0)  # dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def insert(self, node: Node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n\n    def remove(self, node: Node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def pop(self) -&gt; Node:\n        if self.head.next == self.tail:\n            return None\n        node = self.tail.prev\n        self.remove(node)\n        return node\n\n    def is_empty(self) -&gt; bool:\n        return self.head.next == self.tail\n\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_table = {}\n        self.freq_table = defaultdict(DoubleLinkedList)\n        self.size = 0\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.key_table:\n            return -1\n        node = self.key_table[key]\n        self._update(node)\n        return node.value\n\n    def put(self, key: int, value: int) -&gt; None:\n        if self.capacity == 0:\n            return\n        if key in self.key_table:\n            node = self.key_table[key]\n            node.value = value\n            self._update(node)\n        else:\n            if self.size == self.capacity:\n                list_to_remove = self.freq_table[self.min_freq]\n                node_to_remove = list_to_remove.pop()\n                del self.key_table[node_to_remove.key]\n                self.size -= 1\n            new_node = Node(key, value)\n            self.key_table[key] = new_node\n            self.freq_table[1].insert(new_node)\n            self.min_freq = 1\n            self.size += 1\n\n    def _update(self, node: Node):\n        freq = node.freq\n        self.freq_table[freq].remove(node)\n        if self.freq_table[freq].is_empty() and freq == self.min_freq:\n            self.min_freq += 1\n        node.freq += 1\n        self.freq_table[node.freq].insert(node)\n\n\nobj = LFUCache(2)\nobj.put(1, 1)\nobj.put(2, 2)\nprint(obj.get(1))  # 1\nobj.put(3, 3)\nprint(obj.get(2))  # -1\n</code></pre>"},{"location":"leetpattern/design/#1166-design-file-system","title":"1166. Design File System","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, design, trie</li> </ul> <pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self, name):\n        self.name = name\n        self.children = defaultdict(TrieNode)\n        self.value = -1\n\n\n# Trie\nclass FileSystem:\n    def __init__(self):\n        self.root = TrieNode(\"\")\n\n    def createPath(self, path: str, value: int) -&gt; bool:\n        paths = path.split(\"/\")[1:]\n        cur = self.root\n\n        for idx, path in enumerate(paths):\n            if path not in cur.children:\n                if idx == len(paths) - 1:\n                    cur.children[path] = TrieNode(path)\n                else:\n                    return False\n            cur = cur.children[path]\n\n        if cur.value != -1:\n            return False\n        cur.value = value\n        return True\n\n    def get(self, path: str) -&gt; int:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n\n        for path in paths:\n            if path not in cur.children:\n                return -1\n            cur = cur.children[path]\n\n        return cur.value\n\n\n# Your FileSystem object will be instantiated and called as such:\npath = \"/a\"\nvalue = 1\nobj = FileSystem()\nprint(obj.createPath(path, value))  # False\nprint(obj.get(path))  # 1\n</code></pre>"},{"location":"leetpattern/design/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, math, design, randomized</li> </ul> <pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.dict = {}\n        self.list = []\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.dict:\n            return False\n        self.dict[val] = len(self.list)\n        self.list.append(val)\n\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.dict:\n            return False\n        last_element = self.list[-1]\n        idx = self.dict[val]\n        self.list[idx] = last_element\n        self.dict[last_element] = idx\n        self.list.pop()\n        del self.dict[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.list)\n\n\nobj = RandomizedSet()\nprint(obj.insert(1))  # True\nprint(obj.remove(2))  # False\nprint(obj.insert(2))  # True\nprint(obj.getRandom())  # 1 or 2\nprint(obj.remove(1))  # True\n</code></pre>"},{"location":"leetpattern/design/#362-design-hit-counter","title":"362. Design Hit Counter","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, design, queue, data stream</li> </ul> <pre><code>from collections import deque\n\n\nclass HitCounter:\n\n    def __init__(self):\n        self.hits = deque()\n\n    def hit(self, timestamp: int) -&gt; None:\n        self.hits.append(timestamp)\n\n    def getHits(self, timestamp: int) -&gt; int:\n        # Remove hits that are older than 5 minutes (300 seconds)\n        while self.hits and self.hits[0] &lt;= timestamp - 300:\n            self.hits.popleft()\n        return len(self.hits)\n\n\nobj = HitCounter()\nobj.hit(1)\nobj.hit(2)\nobj.hit(3)\nprint(obj.getHits(4))  # 3\nobj.hit(300)\nprint(obj.getHits(300))  # 4\nprint(obj.getHits(301))  # 3\n</code></pre>"},{"location":"leetpattern/design/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: string, tree, depth first search, breadth first search, design, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"leetpattern/design/#622-design-circular-queue","title":"622. Design Circular Queue","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, linked list, design, queue</li> </ul> <pre><code># Design\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -&gt; bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.queue[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.size == 0\n\n    def isFull(self) -&gt; bool:\n        return self.size == self.capacity\n\n\nobj = MyCircularQueue(3)\nprint(obj.enQueue(1))  # True\nprint(obj.enQueue(2))  # True\nprint(obj.enQueue(3))  # True\nprint(obj.enQueue(4))  # False\nprint(obj.Rear())  # 3\nprint(obj.isFull())  # True\nprint(obj.deQueue())  # True\n</code></pre>"},{"location":"leetpattern/design/#353-design-snake-game","title":"353. Design Snake Game","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, design, queue, simulation</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\nclass SnakeGame:\n\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = deque(food)\n        self.snake = deque([(0, 0)])  # Snake starts at the top-left corner\n        self.snake_body = set([(0, 0)])  # To quickly check for collisions\n        self.score = 0\n        self.dirs = {\"U\": (-1, 0), \"L\": (0, -1), \"R\": (0, 1), \"D\": (1, 0)}\n\n    def move(self, direction: str) -&gt; int:\n        head = self.snake[0]\n        dx, dy = self.dirs[direction]\n        new_head = (head[0] + dx, head[1] + dy)\n\n        # Check if the new head is out of bounds\n        if not (\n            0 &lt;= new_head[0] &lt; self.height and 0 &lt;= new_head[1] &lt; self.width\n        ):\n            return -1\n\n        # Check if the new head collides with the snake body (excluding the tail)\n        if new_head in self.snake_body and new_head != self.snake[-1]:\n            return -1\n\n        # Check if the new head is on a food cell\n        if self.food and self.food[0] == list(new_head):\n            self.food.popleft()\n            self.score += 1\n        else:\n            tail = self.snake.pop()\n            self.snake_body.remove(tail)\n\n        # Add the new head to the snake\n        self.snake.appendleft(new_head)\n        self.snake_body.add(new_head)\n\n        return self.score\n\n\nsnake = SnakeGame(3, 2, [[1, 2], [0, 1]])\nprint(snake.move(\"R\"))  # 0\nprint(snake.move(\"D\"))  # 0\nprint(snake.move(\"R\"))  # 1\nprint(snake.move(\"U\"))  # 1\nprint(snake.move(\"L\"))  # 2\nprint(snake.move(\"U\"))  # -1\n</code></pre>"},{"location":"leetpattern/design/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, design, sorting</li> </ul> <pre><code>class Leaderboard:\n\n    def __init__(self):\n        self.scores = {}\n\n    def addScore(self, playerId: int, score: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] += score\n        else:\n            self.scores[playerId] = score\n\n    def top(self, K: int) -&gt; int:\n        topK = sorted(self.scores.values(), reverse=True)[:K]\n        return sum(topK)\n\n    def reset(self, playerId: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] = 0\n\n\nboard = Leaderboard()\nboard.addScore(1, 73)\nboard.addScore(2, 56)\nboard.addScore(3, 39)\nboard.addScore(4, 51)\nprint(board.top(1))  # 73\nboard.reset(1)\nboard.reset(2)\nprint(board.top(2))  # 90\n</code></pre>"},{"location":"leetpattern/difference_array/","title":"Difference Array","text":""},{"location":"leetpattern/difference_array/#1094-car-pooling","title":"1094. Car Pooling","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, sorting, heap priority queue, simulation, prefix sum</li> <li>Return <code>False</code> if the total number of passengers at any point is greater than <code>capacity</code>. Otherwise, return <code>True</code>.</li> </ul> <pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Difference Array\ndef carPooling1(trips: List[List[int]], capacity: int) -&gt; bool:\n    max_location = 0\n    for trip in trips:\n        max_location = max(max_location, trip[2])\n\n    diff = [0] * (max_location + 1)\n    n = len(diff)\n\n    for num, start, end in trips:\n        diff[start] += num\n        if end &lt; n:\n            diff[end] -= num\n\n    cur = 0\n    for i in range(n):\n        cur += diff[i]\n        if cur &gt; capacity:\n            return False\n\n    return True\n\n\n# Difference Array\ndef carPooling2(trips: List[List[int]], capacity: int) -&gt; bool:\n    diff = [0] * 1001\n\n    for num, start, end in trips:\n        diff[start] += num\n        diff[end] -= num\n\n    return all(s &lt;= capacity for s in accumulate(diff))\n\n\ntrips = [[2, 1, 5], [3, 3, 7]]\ncapacity = 4\nprint(carPooling1(trips, capacity))  # False\nprint(carPooling2(trips, capacity))  # False\n</code></pre>"},{"location":"leetpattern/difference_array/#370-range-addition","title":"370. Range Addition","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, prefix sum</li> <li>Return the final array after applying all the Adition operations.</li> </ul> <pre><code>from typing import List\n\n\n# Difference Array\ndef getModifiedArray(length: int, updates: List[List[int]]) -&gt; List[int]:\n    result = [0 for _ in range(length)]\n\n    for start, end, inc in updates:\n        result[start] += inc\n\n        if end + 1 &lt; length:\n            result[end + 1] -= inc\n\n    for i in range(1, length):\n        result[i] += result[i - 1]\n\n    return result\n\n\nlength = 5\nupdates = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]\nprint(getModifiedArray(length, updates))  # [-2, 0, 3, 5, 3]\n</code></pre>"},{"location":"leetpattern/difference_array/#1109-corporate-flight-bookings","title":"1109. Corporate Flight Bookings","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, prefix sum</li> <li>Return the number of seats booked on each flight.</li> </ul> <pre><code>from typing import List\n\n\n# Difference Array\ndef corpFlightBookings(bookings: List[List[int]], n: int) -&gt; List[int]:\n    \"\"\"Return the number of seats booked for each flight.\"\"\"\n    res = [0 for _ in range(n)]\n\n    for i, j, k in bookings:\n        res[i - 1] += k\n        if j &lt; n:\n            res[j] -= k\n\n    for i in range(1, n):\n        res[i] += res[i - 1]\n\n    return res\n\n\nbookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]\nn = 5\nprint(corpFlightBookings(bookings, n))  # [10, 55, 45, 25, 25]\n</code></pre>"},{"location":"leetpattern/difference_array/#2848-points-that-intersect-with-cars","title":"2848. Points That Intersect With Cars","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, prefix sum</li> <li>Return the number of points that intersect with cars.</li> </ul> <pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Differnce Array\ndef numberOfPoints(nums: List[List[int]]) -&gt; int:\n    max_end = max(end for _, end in nums)\n\n    diff = [0] * (max_end + 2)\n\n    for start, end in nums:\n        diff[start] += 1\n        diff[end + 1] -= 1\n\n    return sum(s &gt; 0 for s in accumulate(diff))\n\n\nnums = [[3, 6], [1, 5], [4, 7]]\nprint(numberOfPoints(nums))  # 7\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/","title":"DP 01 Knapsack","text":""},{"location":"leetpattern/dp_01_knapsack/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\nfrom template import knapsack01\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nnums = [1, 5, 11, 5]\nprint(canPartitionTemplate(nums))  # True\nprint(canPartition(nums))  # True\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/#474-ones-and-zeroes","title":"474. Ones and Zeroes","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\ndef findMaxForm(strs: List[str], m: int, n: int) -&gt; int:\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        zerosNum = s.count(\"0\")\n        onesNum = len(s) - zerosNum\n\n        for i in range(m, zerosNum - 1, -1):\n            for j in range(n, onesNum - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zerosNum][j - onesNum] + 1)\n\n    return dp[m][n]\n\n\nstrs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"]\nm = 5\nn = 3\nprint(findMaxForm(strs, m, n))  # 4\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/#494-target-sum","title":"494. Target Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, heap priority queue</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/#1049-last-stone-weight-ii","title":"1049. Last Stone Weight II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\ndef lastStoneWeightII(stones: List[int]) -&gt; int:\n    target = sum(stones) // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(stones)):\n        for j in range(target, stones[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])\n\n    result = (sum(stones) - dp[target]) - dp[target]\n\n    return result\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightII(stones))  # 1\n</code></pre>"},{"location":"leetpattern/dp_2d/","title":"DP 2D","text":""},{"location":"leetpattern/dp_2d/#118-pascals-triangle","title":"118. Pascal's Triangle","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li>Generate the first <code>numRows</code> of Pascal's triangle.</li> </ul> <pre><code>                 numRows    index\n     1              1         0\n    1 1             2         1\n   1 2 1            3         2\n  1 3 3 1           4         3\n 1 4 6 4 1          5         4\n</code></pre> <pre><code>from typing import List\n\n\ndef generate(numRows: int) -&gt; List[List[int]]:\n    dp = [[1] * i for i in range(1, numRows + 1)]\n\n    if numRows &lt;= 2:\n        return dp\n\n    for i in range(2, numRows):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp\n\n\nprint(generate(numRows=5))\n#     [[1],\n#    [1, 1],\n#   [1, 2, 1],\n#  [1, 3, 3, 1],\n# [1, 4, 6, 4, 1]]\n</code></pre>"},{"location":"leetpattern/dp_2d/#119-pascals-triangle-ii","title":"119. Pascal's Triangle II","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li>Return the <code>rowIndex</code>th row of Pascal's triangle.</li> </ul> <pre><code>from typing import List\n\n\ndef getRow(rowIndex: int) -&gt; List[int]:\n    dp = [[1] * (i + 1) for i in range(rowIndex + 1)]\n\n    if rowIndex &lt;= 1:\n        return dp[rowIndex]\n\n    for i in range(2, rowIndex + 1):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp[-1]\n\n\nprint(getRow(rowIndex=3))  # [1, 3, 3, 1]\n</code></pre>"},{"location":"leetpattern/dp_2d/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, dynamic programming, combinatorics</li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"leetpattern/dp_2d/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, matrix</li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid with obstacles.</li> </ul> <pre><code>from typing import List\n\n\n# DP - 2D\ndef uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -&gt; int:\n    if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n        return 0\n\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        if obstacleGrid[i][0] == 0:\n            dp[i][0] = 1\n        else:\n            break\n\n    for j in range(n):\n        if obstacleGrid[0][j] == 0:\n            dp[0][j] = 1\n        else:\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if obstacleGrid[i][j] == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nobstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nprint(uniquePathsWithObstacles(obstacleGrid))  # 2\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 2]]\n</code></pre>"},{"location":"leetpattern/dp_basic/","title":"DP Basic","text":""},{"location":"leetpattern/dp_basic/#509-fibonacci-number","title":"509. Fibonacci Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, dynamic programming, recursion, memoization</li> <li>Return the <code>n-th</code> Fibonacci number.</li> <li><code>dp[n]</code> stores the <code>n-th</code> Fibonacci number.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code> and <code>dp[1] = 1</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - 0 1 2 0 1 1 3 1 1 2 4 1 2 3 5 2 3 5 6 3 5 8 7 5 8 13 8 8 13 21 9 13 21 34 10 21 34 55 <pre><code># DP\ndef fibDP(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# Recursive\ndef fibRecursive(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    return fibRecursive(n - 1) + fibRecursive(n - 2)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |  Recursive  |     O(2^n)      |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nn = 10\nprint(fibDP(n))  # 55\nprint(fibRecursive(n))  # 55\n</code></pre>"},{"location":"leetpattern/dp_basic/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, dynamic programming, memoization</li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 <pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"leetpattern/dp_basic/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li> <p>Return the minimum cost to reach the top of the stairs.</p> </li> <li> <p><code>dp[n]</code> stores the minimum cost to reach the <code>n-th</code> stair.</p> </li> <li>Formula: <code>dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])</code>.</li> <li>Initialize <code>dp[0] = cost[0]</code> and <code>dp[1] = cost[1]</code>.</li> <li> <p>Return <code>min(dp[-1], dp[-2])</code>.</p> </li> <li> <p>Example: <code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code></p> </li> </ul> n <code>cost[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 1 - - 1 1 100 - 1 100 2 1 1 100 2 3 1 100 2 3 4 1 2 3 3 5 100 3 3 103 6 1 3 103 4 7 1 103 4 5 8 100 4 5 104 9 1 5 104 6 <pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"leetpattern/dp_basic/#198-house-robber","title":"198. House Robber","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 <pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 12\n</code></pre>"},{"location":"leetpattern/dp_basic/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 <pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre>"},{"location":"leetpattern/dp_basic/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return the length of the longest wiggle subsequence.</li> <li><code>up[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a rising wiggle.</li> <li><code>down[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a falling wiggle.</li> <li>Initialize <code>up[0] = 1</code> and <code>down[0] = 1</code>.</li> <li>Example: <code>nums = [1, 7, 4, 9, 2, 5]</code></li> </ul> <code>nums[n]</code> <code>nums[n-1]</code> <code>up[n-1]</code> <code>down[n-1]</code> <code>up[n]</code> <code>down[n]</code> 1 - - - 1 1 7 1 1 1 2 1 4 7 2 1 2 3 9 4 2 3 4 3 2 9 4 3 4 5 5 2 4 5 6 5 <pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"leetpattern/dp_basic/#343-integer-break","title":"343. Integer Break","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, dynamic programming</li> <li>Return the maximum product of the integer after breaking it into at least two positive integers.</li> <li><code>dp[i]</code> stores the maximum product of the integer <code>i</code>.</li> <li>Formula: <code>dp[i] = max(dp[i - j] * j, (i - j) * j)</code></li> </ul> dp 3 4 5 6 7 8 2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 dp[2]=1 1*1=2 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 3 3*1=3 3*2=6 3*3=9 3*4=12 3*5=15 dp[3]=2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 4 4*1=4 4*2=8 4*3=12 4*4=16 dp[4]=4 4*1=4 4*2=8 4*3=12 4*4=16 5 5*1=5 5*2=10 5*3=15 dp[5]=6 6*1=6 6*2=12 6*3=18 6 6*1=6 6*2=12 dp[6]=9 9*1=9 9*2=18 7 7*1=7 dp[7]=12 12*1=12 <code>dp[n]</code> 2 4 6 9 12 18 <pre><code>def integerBreak(n: int) -&gt; int:\n    dp = [0 for _ in range(n + 1)]\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        for j in range(2, i):\n            dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n^2)     |     O(n)     |\n# |-------------|-----------------|--------------|\n\nn = 8\nprint(integerBreak(n))  # 18\n</code></pre>"},{"location":"leetpattern/dp_basic/#1025-divisor-game","title":"1025. Divisor Game","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, dynamic programming, brainteaser, game theory</li> <li>Return <code>True</code> if Alice wins the game, assuming both players play optimally.</li> <li><code>dp[n]</code> stores the result of the game when the number is <code>n</code>.</li> <li>Initialize <code>dp[1] = False</code>.</li> </ul> <pre><code># DP\ndef divisorGameDP(n: int) -&gt; bool:\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\n# Math\ndef divisorGameDPMath(n: int) -&gt; bool:\n    return n % 2 == 0\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  DP         |      O(n^2)     |    O(n)      |\n# |  Math       |      O(1)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\nn = 2\nprint(divisorGameDP(n))  # True\nprint(divisorGameDPMath(n))  # True\n</code></pre>"},{"location":"leetpattern/dp_interval/","title":"DP Interval","text":""},{"location":"leetpattern/dp_interval/#516-longest-palindromic-subsequence","title":"516. Longest Palindromic Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> <li>Return the length of the longest palindromic subsequence in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp b b b a b b 1 2 3 3 4 b 0 1 2 2 3 <code>dp[i][j]</code> b 0 0 1 1 <code>dp[i+1][j-1]</code> 2 a 0 0 0 1 1 b 0 0 0 0 1 <pre><code>def longestPalindromeSubseq(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    return dp[0][-1]\n\n\nprint(longestPalindromeSubseq(\"bbbab\"))  # 4\n</code></pre>"},{"location":"leetpattern/dp_interval/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string, dynamic programming</li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 <pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"leetpattern/dp_interval/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string, dynamic programming</li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> <pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"leetpattern/dp_kadane/","title":"DP Kadane","text":""},{"location":"leetpattern/dp_kadane/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"leetpattern/dp_kadane/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, dynamic programming, queue, monotonic queue</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"leetpattern/dp_kadane/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"leetpattern/dp_kadane/#978-longest-turbulent-subarray","title":"978. Longest Turbulent Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, sliding window</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxTurbulenceSize(arr: List[int]) -&gt; int:\n    n = len(arr)\n    up = [1 for _ in range(n)]\n    down = [1 for _ in range(n)]\n    maxLen = 1\n\n    for i in range(1, n):\n        if arr[i - 1] &lt; arr[i]:\n            up[i] = down[i - 1] + 1\n            down[i] = 1\n        elif arr[i - 1] &gt; arr[i]:\n            down[i] = up[i - 1] + 1\n            up[i] = 1\n        else:\n            up[i] = 1\n            down[i] = 1\n\n        maxLen = max(maxLen, up[i], down[i])\n\n    return maxLen\n\n\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxTurbulenceSize(arr))  # 5\n</code></pre>"},{"location":"leetpattern/dp_kadane/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maximumSum(arr: List[int]) -&gt; int:\n    dp0 = arr[0]\n    dp1 = 0\n    maxSum = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        maxSum = max(maxSum, dp0, dp1)  # update result\n\n    return maxSum\n\n\narr = [1, -2, 0, 3]\nprint(maximumSum(arr))  # 4\n</code></pre>"},{"location":"leetpattern/dp_lcs/","title":"DP LCS","text":""},{"location":"leetpattern/dp_lcs/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n            if res &lt; dp[i][j]:\n                res = dp[i][j]\n\n    return res\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code>def minDistance(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nword1 = \"horse\"\nword2 = \"ros\"\nprint(minDistance(word1, word2))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#392-is-subsequence","title":"392. Is Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string, dynamic programming</li> </ul> <pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre>"},{"location":"leetpattern/dp_lcs/#583-delete-operation-for-two-strings","title":"583. Delete Operation for Two Strings","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code># DP - LCS\ndef minDistance1(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no need to delete\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,  # delete word1[i]\n                    dp[i][j - 1] + 1,  # delete word2[j]\n                    dp[i - 1][j - 1] + 2,  # delete both\n                )\n    return dp[-1][-1]\n\n\n# DP - LCS\ndef minDistance2(word1: str, word2: str) -&gt; int:\n    def LCS(word1: str, word2: str) -&gt; int:\n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        lcs = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n                if lcs &lt; dp[i][j]:\n                    lcs = dp[i][j]\n        return lcs\n\n    lcs = LCS(word1, word2)\n    return len(word1) + len(word2) - 2 * lcs\n\n\nword1 = \"sea\"\nword2 = \"eat\"\nprint(minDistance1(word1, word2))  # 2\nprint(minDistance2(word1, word2))  # 2\n</code></pre>"},{"location":"leetpattern/dp_lcs/#674-longest-continuous-increasing-subsequence","title":"674. Longest Continuous Increasing Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array</li> </ul> <pre><code>from typing import List\n\n\ndef findLengthOfLCIS(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if nums[i] &gt; nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\n\nprint(findLengthOfLCIS([1, 3, 5, 4, 7]))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, dynamic programming, sliding window, rolling hash, hash function</li> </ul> <pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#1035-uncrossed-lines","title":"1035. Uncrossed Lines","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\ndef maxUncrossedLines(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    num = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            if num &lt; dp[i][j]:\n                num = dp[i][j]\n\n    return num\n\n\nprint(maxUncrossedLines([1, 4, 2], [1, 2, 4]))  # 2\n</code></pre>"},{"location":"leetpattern/dp_lis/","title":"DP LIS","text":""},{"location":"leetpattern/dp_lis/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - LIS\ndef lengthOfLIS(nums: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(n)\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # 4\n</code></pre>"},{"location":"leetpattern/dp_lis/#673-number-of-longest-increasing-subsequence","title":"673. Number of Longest Increasing Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, binary indexed tree, segment tree</li> </ul> <pre><code>from typing import List\n\n\n# DP - LIS\ndef findNumberOfLIS(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1 for _ in range(n)]\n    counts = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                if dp[j] + 1 &gt; dp[i]:\n                    dp[i] = dp[j] + 1\n                    counts[i] = counts[j]\n                elif dp[j] + 1 == dp[i]:\n                    counts[i] += counts[j]\n\n    longest = max(dp)\n    return sum(c for i, c in enumerate(counts) if dp[i] == longest)\n\n\nnums = [1, 3, 5, 4, 7]\nprint(findNumberOfLIS(nums))  # 2\n</code></pre>"},{"location":"leetpattern/dp_lis/#354-russian-doll-envelopes","title":"354. Russian Doll Envelopes","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, dynamic programming, sorting</li> </ul> <pre><code>from typing import List\n\n\n# DP - LIS\ndef maxEnvelopes(envelopes: List[List[int]]) -&gt; int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n\n    for w, h in envelopes:\n        left, right = 0, len(dp)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if dp[mid][1] &lt; h:\n                left = mid + 1\n            else:\n                right = mid\n        if right == len(dp):\n            dp.append((w, h))\n        else:\n            dp[right] = (w, h)\n\n    return len(dp)\n\n\nenvelopes = [[5, 4], [6, 4], [6, 7], [2, 3]]\nprint(maxEnvelopes(envelopes))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lis/#960-delete-columns-to-make-sorted-iii","title":"960. Delete Columns to Make Sorted III","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - LIS\ndef minDeletionSize(strs: List[str]) -&gt; int:\n    if not strs:\n        return 0\n\n    n = len(strs[0])\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if all(row[j] &lt;= row[i] for row in strs):\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n</code></pre>"},{"location":"leetpattern/dp_lis/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, dynamic programming, greedy</li> </ul> <pre><code>from typing import List\n\n\n# DP - LIS\ndef minimumMountainRemovals(nums: List[int]) -&gt; int:\n    n = len(nums)\n    lis = [1 for _ in range(n)]\n    lds = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if nums[i] &gt; nums[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    maxLen = 0\n    for i in range(1, n - 1):\n        if lis[i] &gt; 1 and lds[i] &gt; 1:\n            maxLen = max(maxLen, lis[i] + lds[i] - 1)\n\n    return n - maxLen\n\n\nnums = [2, 1, 1, 5, 6, 2, 3, 1]\nprint(minimumMountainRemovals(nums))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lis/#941-valid-mountain-array","title":"941. Valid Mountain Array","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array</li> </ul> <pre><code>from typing import List\n\n\n# Array\ndef validMountainArray(arr: List[int]) -&gt; bool:\n    n = len(arr)\n    i = 0\n\n    while i &lt; n - 1 and arr[i] &lt; arr[i + 1]:\n        i += 1\n\n    if i == 0 or i == n - 1:\n        return False\n\n    while i &lt; n - 1 and arr[i] &gt; arr[i + 1]:\n        i += 1\n\n    return i == n - 1\n\n\n# Left Right Pointers\ndef validMountainArrayLP(arr: List[int]) -&gt; bool:\n    n = len(arr)\n\n    if n &lt; 3:\n        return False\n\n    left, right = 0, n - 1\n\n    while left &lt; n - 1 and arr[left] &lt; arr[left + 1]:\n        left += 1\n\n    while right &gt; 0 and arr[right] &lt; arr[right - 1]:\n        right -= 1\n\n    return 0 &lt; left == right &lt; n - 1\n\n\narr = [0, 3, 2, 1]\nprint(validMountainArray(arr))  # True\nprint(validMountainArrayLP(arr))  # True\n</code></pre>"},{"location":"leetpattern/dp_lis/#845-longest-mountain-in-array","title":"845. Longest Mountain in Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, dynamic programming, enumeration</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef longestMountain(arr: List[int]) -&gt; int:\n    n = len(arr)\n    res = 0\n    left = 0\n\n    while left &lt; n:\n        right = left\n\n        if right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n            while right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n                right += 1\n\n            if right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                while right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n\n        left = max(right, left + 1)\n\n    return res\n\n\narr = [2, 1, 4, 7, 3, 2, 5]\nprint(longestMountain(arr))  # 5\n</code></pre>"},{"location":"leetpattern/dp_stock/","title":"DP Stock","text":""},{"location":"leetpattern/dp_stock/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"leetpattern/dp_stock/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return the maximum profit you can achieve.</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"leetpattern/dp_stock/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre>"},{"location":"leetpattern/dp_stock/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre>"},{"location":"leetpattern/dp_stock/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"leetpattern/dp_stock/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return the maximum profit you can achieve with the given transaction fee.</li> </ul> <pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/","title":"DP Unbounded Knapsack","text":""},{"location":"leetpattern/dp_unbounded_knapsack/#139-word-break","title":"139. Word Break","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, dynamic programming, trie, memoization</li> </ul> <pre><code>from typing import List\n\n\n# DP - Knapsack Unbounded\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, dynamic programming, breadth first search</li> </ul> <pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/#322-coin-change","title":"322. Coin Change","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, breadth first search</li> </ul> <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/#377-combination-sum-iv","title":"377. Combination Sum IV","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\ndef combinationSum4(nums: List[int], target: int) -&gt; int:\n    dp = [0 for _ in range(target + 1)]\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i - nums[j] &gt;= 0:\n                dp[i] += dp[i - nums[j]]\n\n        return dp[target]\n\n\nnums = [1, 2, 3]\ntarget = 4\nprint(combinationSum4(nums, target))  # 7\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/","title":"Fast Slow Pointers","text":""},{"location":"leetpattern/fast_slow_pointers/#27-remove-element","title":"27. Remove Element","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, two pointers</li> <li>Remove all instances of a given value in-place.</li> </ul> <pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, two pointers</li> <li>Remove duplicates in-place.</li> </ul> <pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers</li> <li>Allow at most two duplicates.</li> <li>fast pointer: explore the array</li> <li>slow pointer: point to the position to be replaced</li> </ul> <pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, two pointers</li> <li>Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.</li> </ul> <pre><code>from typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#1089-duplicate-zeros","title":"1089. Duplicate Zeros","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, two pointers</li> <li>Duplicate each occurrence of zero, shifting the remaining elements to the right.</li> </ul> <pre><code>from typing import List\n\n\ndef duplicateZeros(arr: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    fast, slow = 0, 0\n\n    # First pass: find the position\n    # where the last element would be in the expanded array\n    while fast &lt; n:\n        if arr[slow] == 0:\n            fast += 1\n        slow += 1\n        fast += 1\n\n    slow -= 1\n    fast -= 1\n\n    # Second pass: move elements backwards\n    while slow &gt;= 0:\n        if fast &lt; n:\n            arr[fast] = arr[slow]\n\n        if arr[slow] == 0:\n            fast -= 1\n            if fast &lt; n:\n                arr[fast] = 0\n\n        slow -= 1\n        fast -= 1\n\n\narr = [1, 0, 2, 3, 0, 4, 5, 0]\nduplicateZeros(arr)\nprint(arr)  # [1, 0, 0, 2, 3, 0, 0, 4]\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, binary search, bit manipulation</li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> </ul> <pre><code>from typing import List\n\n\n# Fast Slow Pointer\ndef findDuplicate(nums: List[int]) -&gt; int:\n\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\n# | Algorithm          | TC   | SC   |\n# |--------------------|------|------|\n# | Fast Slow Pointer  | O(n) | O(1) |\n# |--------------------|------|------|\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"leetpattern/graph_bellman_ford/","title":"Graph Bellman Ford","text":""},{"location":"leetpattern/graph_bellman_ford/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"leetpattern/graph_bellman_ford/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"leetpattern/graph_bfs/","title":"Graph BFS","text":""},{"location":"leetpattern/graph_bfs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, breadth first search, matrix</li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    # 1. Init\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    # 2. Make a queue of rotten oranges and count fresh oranges\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    # 3. BFS\n    while q and fresh &gt; 0:\n        size = len(q)\n\n        for _ in range(size):\n            r, c = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if nr &lt; 0 or nc &lt; 0 or nr &gt;= m or nc &gt;= n or grid[nr][nc] != 1:\n                    continue\n                grid[nr][nc] = 2\n                q.append([nr, nc])\n                fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"leetpattern/graph_bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, breadth first search</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # Edge case\n    if endWord not in wordList:\n        return 0\n\n    # Init\n    graph = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    # BFS\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\n# |------------|---------|---------|\n# |  Approach  |  Time   |  Space  |\n# |------------|---------|---------|\n# |    BFS     | O(n*m^2)| O(n*m)  |\n# |------------|---------|---------|\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"leetpattern/graph_bfs/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph</li> <li></li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"leetpattern/graph_bfs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, breadth first search, matrix </li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            r in range(m)\n            and c in range(n)\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nrooms = [\n    [2147483647, -1, 0, 2147483647],\n    [2147483647, 2147483647, 2147483647, -1],\n    [2147483647, -1, 2147483647, -1],\n    [0, -1, 2147483647, 2147483647],\n]\nwallsAndGates(rooms)\nprint(rooms)\n# [[3, -1, 0,  1],\n#  [2,  2, 1, -1],\n#  [1, -1, 2, -1],\n#  [0, -1, 3,  4]]\n</code></pre>"},{"location":"leetpattern/graph_bfs/#815-bus-routes","title":"815. Bus Routes","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, hash table, breadth first search</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef numBusesToDestination(\n    routes: List[List[int]], source: int, target: int\n) -&gt; int:\n    if source == target:\n        return 0\n\n    graph = defaultdict(set)  # {stop: buses}\n    for buses, route in enumerate(routes):\n        for stop in route:\n            graph[stop].add(buses)\n\n    q = deque([(source, 0)])  # (stop, bus)\n    visited_stops = set([source])\n    visited_buses = set()\n\n    while q:\n        stop, bus = q.popleft()\n\n        if stop == target:\n            return bus\n\n        for buses in graph[stop]:\n            if buses not in visited_buses:\n                visited_buses.add(buses)\n                for next_stop in routes[buses]:\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        q.append((next_stop, bus + 1))\n\n    return -1\n\n\nroutes = [[1, 2, 7], [3, 6, 7]]\nsource = 1\ntarget = 6\nprint(numBusesToDestination(routes, source, target))  # 2\n</code></pre>"},{"location":"leetpattern/graph_coloring/","title":"Graph Coloring","text":""},{"location":"leetpattern/graph_coloring/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> <li>Determine if a graph is bipartite.</li> </ul> <p>How to group</p> Uncolored Color 1 Color 2 Operation Method 1 -1 0 1 <code>1 - color</code> Method 2 0 1 -1 <code>-color</code> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"leetpattern/graph_coloring/#886-possible-bipartition","title":"886. Possible Bipartition","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> <li>Determine if a graph can be divided into two groups such that no two nodes of the same group are connected.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef possibleBipartitionBFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n\n    # Undirected graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def bfs(person):\n        q = deque([person])\n        group[person] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if group[neighbor] == -1:\n                    group[neighbor] = 1 - group[cur]\n                    q.append(neighbor)\n                elif group[neighbor] == group[cur]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not bfs(i):\n                return False\n    return True\n\n\n# DFS\ndef possibleBipartitionDFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def dfs(person, g):\n        group[person] = g\n\n        for neighbor in graph[person]:\n            if group[neighbor] == -1:\n                if not dfs(neighbor, 1 - g):\n                    return False\n            elif group[neighbor] == g:\n                return False\n\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V+E) |\n# |    DFS     | O(V+E) |  O(V+E) |\n# |------------|--------|---------|\n\n\nn = 4\ndislikes = [[1, 2], [1, 3], [2, 4]]\nprint(possibleBipartitionBFS(n, dislikes))  # True\nprint(possibleBipartitionDFS(n, dislikes))  # True\n</code></pre>"},{"location":"leetpattern/graph_coloring/#924-minimize-malware-spread","title":"924. Minimize Malware Spread","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, hash table, depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from typing import List\n\n\n# Coloring\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -&gt; int:\n    n = len(graph)\n    initial = set(initial)\n\n    def dfs(x):\n        visited.add(x)\n        mark[x] = 1\n        if x in initial:\n            v.append(x)\n        for nxt in range(n):\n            if graph[x][nxt] and nxt != x and not mark[nxt]:\n                dfs(nxt)\n\n    ans = min(initial)\n    mx = 0\n    mark = [0] * n\n    for i in range(n):\n        if not mark[i]:\n            visited = set()\n            v = []\n            dfs(i)\n            if len(v) == 1 and (\n                len(visited) &gt; mx or len(visited) == mx and v[0] &lt; ans\n            ):\n                ans, mx = v[0], len(visited)\n    return ans\n\n\ngraph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\ninitial = [0, 1]\nprint(minMalwareSpread(graph, initial))  # 0\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/","title":"Graph Flood Fill","text":""},{"location":"leetpattern/graph_flood_fill/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, depth first search, breadth first search, matrix</li> <li>Replace all the pixels of the same color starting from the given pixel.</li> <li>In other words, find the connected component of the starting pixel and change the color of all the pixels in that component.</li> <li>Edge cases: If the starting pixel is already the target color, return the image as it is.</li> <li>Flood Fill is essentially a graph traversal algorithm (like BFS or DFS) applied to matrices (2D grids).     It checks adjacent cells (up, down, left, right) of a starting point to determine whether they belong to the same region.     Typically, it involves modifying or marking the cells that belong to the same connected component.</li> </ul> 1 1 1 1 1 0 1 0 1 1 1 1 1 2 0 1 0 1 1 2 1 2 2 0 1 0 1 2 2 2 2 2 0 2 0 1 <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef floodFillDFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if org == color:\n        return image\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or image[r][c] != org:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# BFS\ndef floodFillBFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if org == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        r, c = q.popleft()\n        image[r][c] = color\n\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and image[nr][nc] == org:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return 0\n\n        grid[r][c] = 2\n\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    area = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#463-island-perimeter","title":"463. Island Perimeter","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, depth first search, breadth first search, matrix</li> </ul> <pre><code>from typing import List\n\n\n# DFS\ndef islandPerimeterDFS(grid: List[List[int]]) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n\n    visited = set()\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if (r, c) in visited or grid[r][c] == 0:\n            return 0\n        visited.add((r, c))\n        perimeter = 0\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr not in range(m) or nc not in range(n) or grid[nr][nc] == 0:\n                perimeter += 1\n            else:\n                perimeter += dfs(nr, nc)\n\n        return perimeter\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                return dfs(r, c)\n    return 0\n\n\ndef islandPerimeter(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    perimeter = 0\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                perimeter += 4\n\n                if r &gt; 0 and grid[r - 1][c] == 1:\n                    perimeter -= 2\n\n                if c &gt; 0 and grid[r][c - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\n\ngrid = [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]\nprint(islandPerimeterDFS(grid))  # 16\nprint(islandPerimeter(grid))  # 16\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> </ul> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom typing import List\n\n\n# 1. DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r not in range(m) or c not in range(n) or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# 2. BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and board[nr][nc] == \"O\":\n                    q.append((nr, nc))\n                    board[nr][nc] = \"T\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nboard = [\n    [\"X\", \"X\", \"X\", \"X\"],\n    [\"X\", \"O\", \"O\", \"X\"],\n    [\"X\", \"X\", \"O\", \"X\"],\n    [\"X\", \"O\", \"X\", \"X\"],\n]\nboard1 = deepcopy(board)\nsolveDFS(board1)\npprint(board1)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n\nboard2 = deepcopy(board)\nsolveBFS(board2)\npprint(board2)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#827-making-a-large-island","title":"827. Making A Large Island","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Flood Fill\ndef largestIsland(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    areas = defaultdict(int)  # {index: area}\n    index = 2\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(r, c, index):\n        area = 1\n        grid[r][c] = index\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                area += dfs(nr, nc, index)\n        return area\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 1:\n                areas[index] = dfs(r, c, index)\n                index += 1\n\n    if not areas:\n        return 1\n\n    res = max(areas.values())\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 0:\n                connected = set()\n                area = 1\n                for dr, dc in dirs:\n                    nr, nc = r + dr, c + dc\n                    if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] &gt; 1:\n                        connected.add(grid[nr][nc])\n\n                for island in connected:\n                    area += areas[island]\n                res = max(res, area)\n\n    return res\n\n\ngrid = [[1, 0], [0, 1]]\nprint(largestIsland(grid))  # 3\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/","title":"Graph Minimum Spanning Tree","text":""},{"location":"leetpattern/graph_minimum_spanning_tree/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, union find, graph, minimum spanning tree</li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm<ul> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Kruskal's Algorithm</p> <ul> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Demonstration</p> </li> </ul> <p>Example graph</p> <p></p> <p>MST</p> <p></p> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: union find, graph, heap priority queue, minimum spanning tree</li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: union find, graph, heap priority queue, minimum spanning tree </li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: union find, graph, sorting, minimum spanning tree, strongly connected component</li> </ul> <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: union find, graph</li> <li>Return the maximum number of edges you can remove so that the graph remains fully traversable.</li> </ul> <pre><code>from typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/","title":"Graph Shortest Path","text":""},{"location":"leetpattern/graph_shortest_path/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</li> <li>Return the minimum time when you can reach the target.</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, graph, heap priority queue, shortest path</li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#882-reachable-nodes-in-subdivided-graph","title":"882. Reachable Nodes In Subdivided Graph","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: graph, heap priority queue, shortest path</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -&gt; int:\n    graph = {i: {} for i in range(n)}\n    for u, v, cnt in edges:\n        graph[u][v] = cnt\n        graph[v][u] = cnt\n\n    heap = [(-maxMoves, 0)]\n    seen = {}\n\n    while heap:\n        moves, node = heapq.heappop(heap)\n        if node in seen:\n            continue\n        seen[node] = -moves\n        for nxt, cnt in graph[node].items():\n            movesLeft = -moves - cnt - 1\n            if nxt not in seen and movesLeft &gt;= 0:\n                heapq.heappush(heap, (-movesLeft, nxt))\n\n    res = len(seen)\n    for u, v, cnt in edges:\n        res += min(seen.get(u, 0) + seen.get(v, 0), cnt)\n\n    return res\n\n\nedges = [[0, 1, 10], [0, 2, 1], [1, 2, 2]]\nmaxMoves = 6\nn = 3\nprint(reachableNodes(None, edges, maxMoves, n))  # 13\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, breadth first search</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: union find, graph, heap priority queue, minimum spanning tree </li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: dynamic programming, graph, topological sort, shortest path</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef countPaths(n: int, roads: List[List[int]]) -&gt; int:\n    mod = 10**9 + 7\n    graph = [[] for _ in range(n)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float(\"inf\") for _ in range(n)]\n    dist[0] = 0\n    count = [0 for _ in range(n)]\n    count[0] = 1\n\n    heap = [(0, 0)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                count[v] = count[u]\n                heapq.heappush(heap, (dist[v], v))\n            elif dist[u] + w == dist[v]:\n                count[v] += count[u]\n                count[v] %= mod\n\n    return count[-1]\n\n\nn = 7\nroads = [\n    [0, 6, 7],\n    [0, 1, 2],\n    [1, 2, 3],\n    [1, 3, 3],\n    [6, 3, 3],\n    [3, 5, 1],\n    [6, 5, 1],\n    [2, 5, 1],\n    [0, 4, 5],\n    [4, 6, 2],\n]\nprint(countPaths(n, roads))  # 4\n</code></pre>"},{"location":"leetpattern/graph_tarjan/","title":"Graph Tarjan","text":""},{"location":"leetpattern/graph_tarjan/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: depth first search, graph, biconnected component</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/","title":"Graph Topological Sort","text":""},{"location":"leetpattern/graph_topological_sort/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: graph</li> <li>Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.</li> <li>\u2705 Return the vertices with indegree 0.</li> </ul> <ul> <li><code>edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]</code></li> <li>Initialization</li> </ul> <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 0 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 1 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 2 0 1 1 <pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for a, b in edges:\n        indegree[b] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(findSmallestSetOfVertices(n, edges))  # [0, 3]\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, depth first search, breadth first search, graph, topological sort</li> <li>Return the correct order of characters in the alien language.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return any permutation of the items that satisfies the requirements.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, dynamic programming, graph, topological sort, memoization, counting</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#1136-parallel-courses","title":"1136. Parallel Courses","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: graph, topological sort</li> <li>Return the minimum number of semesters needed to take all courses.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/","title":"Graph Union Find","text":""},{"location":"leetpattern/graph_union_find/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> <li>Return the number of provinces.</li> </ul>"},{"location":"leetpattern/graph_union_find/#union-find","title":"Union Find","text":"<ul> <li>Find by Path Compression</li> <li>Union by Rank</li> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(n)</li> </ul> template/union_find.py<pre><code>class UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return None\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n    def connected(self, n1, n2):\n        return self.find(n1) == self.find(n2)\n</code></pre> <pre><code>from typing import List\n\nfrom template import UnionFind\n\n\n# Union Find\ndef findCircleNumUF(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                uf.union(i, j)\n\n    res = len(set(uf.find(i) for i in range(n)))\n\n    return res\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    connected_components = len(set(find(i) for i in range(n)))\n\n    return connected_components\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNum(isConnected))  # 2\nprint(findCircleNumUF(isConnected))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"leetpattern/graph_union_find/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"leetpattern/graph_union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, union find, graph</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"leetpattern/graph_union_find/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, hash table, math, union find, number theory</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef largestComponentSize(nums: List[int]) -&gt; int:\n    par = {i: i for i in nums}\n    rank = {i: 0 for i in nums}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    def prime_factors(n):\n        \"\"\"Return the prime factors of n.\"\"\"\n        i = 2\n        factors = set()\n        while i * i &lt;= n:\n            while (n % i) == 0:\n                factors.add(i)\n                n //= i\n            i += 1\n        if n &gt; 1:\n            factors.add(n)\n        return factors\n\n    factor_map = defaultdict(list)  # factor -&gt; [nums]\n    for num in nums:\n        factors = prime_factors(num)\n        for factor in factors:\n            factor_map[factor].append(num)\n\n    for factor, group in factor_map.items():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n\n    sizes = defaultdict(int)  # component root -&gt; size\n    for num in nums:\n        root = find(num)\n        sizes[root] += 1\n\n    return max(sizes.values())\n\n\nnums = [20, 50, 9, 63]\nprint(largestComponentSize(nums))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, hash table, string, depth first search, breadth first search, union find</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/#305-number-of-islands-ii","title":"305. Number of Islands II","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, hash table, union find</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre>"},{"location":"leetpattern/graph_union_find/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre>"},{"location":"leetpattern/graph_union_find/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre>"},{"location":"leetpattern/graph_union_find/#399-evaluate-division","title":"399. Evaluate Division","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, depth first search, breadth first search, union find, graph, shortest path</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre>"},{"location":"leetpattern/graph_union_find/#1101-the-earliest-moment-when-everyone-become-friends","title":"1101. The Earliest Moment When Everyone Become Friends","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, union find, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Union Find\ndef earliestAcq(logs: List[List[int]], n: int) -&gt; int:\n    logs.sort()\n    par = {i: i for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    for time, a, b in logs:\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            par[pa] = pb\n            n -= 1\n        if n == 1:\n            return time\n    return -1\n\n\nlogs = [[0, 2, 0], [1, 0, 1], [3, 0, 3], [4, 1, 2], [7, 3, 1]]\nn = 4\nprint(earliestAcq(logs, n))  # 3\n</code></pre>"},{"location":"leetpattern/greedy/","title":"Greedy","text":""},{"location":"leetpattern/greedy/#455-assign-cookies","title":"455. Assign Cookies","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, two pointers, greedy, sorting</li> <li>Return the maximum number of your content children that can be satisfied.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef findContentChildren(g: List[int], s: List[int]) -&gt; int:\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n\n    while i &lt; len(g) and j &lt; len(s):\n        if g[i] &lt;= s[j]:\n            i += 1\n        j += 1\n\n    return i\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Greedy    | O(N * logN) |    O(1)      |\n# |-------------|-------------|--------------|\n\n\ng = [1, 2, 3]\ns = [1, 1]\nprint(findContentChildren(g, s))  # 1\n</code></pre>"},{"location":"leetpattern/greedy/#1005-maximize-sum-of-array-after-k-negations","title":"1005. Maximize Sum Of Array After K Negations","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, greedy, sorting</li> <li>Return the maximum sum of the array after changing at most <code>k</code> elements.</li> </ul> <pre><code>from heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Greedy\ndef largestSumAfterKNegationsGreedy(nums: List[int], k: int) -&gt; int:\n    nums.sort(key=abs, reverse=True)\n\n    for i in range(len(nums)):\n        if nums[i] &lt; 0 and k &gt; 0:\n            nums[i] *= -1\n            k -= 1\n\n    if k % 2:\n        nums[-1] *= -1\n\n    return sum(nums)\n\n\n# Heap\ndef largestSumAfterKNegationsHeap(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n\n    while k and nums[0] &lt; 0:\n        heapreplace(nums, -nums[0])\n        k -= 1\n\n    if k % 2:\n        heapreplace(nums, -nums[0])\n\n    return sum(nums)\n\n\nprint(largestSumAfterKNegationsGreedy([4, 2, 3], 1))  # 5\nprint(largestSumAfterKNegationsHeap([4, 2, 3], 1))\n</code></pre>"},{"location":"leetpattern/greedy/#860-lemonade-change","title":"860. Lemonade Change","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, greedy</li> <li>Return <code>True</code> if and only if you can provide every customer with correct change.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef lemonadeChange(bills: List[int]) -&gt; bool:\n    hashmap = {5: 0, 10: 0, 20: 0}\n\n    for i in bills:\n        if i == 5:\n            hashmap[5] += 1\n\n        if i == 10:\n            if hashmap[5] &lt; 1:\n                return False\n\n            hashmap[5] -= 1\n            hashmap[10] += 1\n\n        if i == 20:\n            if hashmap[5] &gt;= 1 and hashmap[10] &gt;= 1:\n                hashmap[5] -= 1\n                hashmap[10] -= 1\n                hashmap[20] += 1\n\n            elif hashmap[5] &gt;= 3:\n                hashmap[5] -= 3\n                hashmap[20] += 1\n\n            else:\n                return False\n\n    return True\n\n\nprint(lemonadeChange([5, 5, 5, 10, 20]))  # True\n</code></pre>"},{"location":"leetpattern/greedy/#2037-minimum-number-of-moves-to-seat-everyone","title":"2037. Minimum Number of Moves to Seat Everyone","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, greedy, sorting, counting sort</li> <li>Return the minimum number of moves needed to seat everyone.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef minMovesToSeat(seats: List[int], students: List[int]) -&gt; int:\n    seats.sort()\n    students.sort()\n    moves = 0\n\n    for i, j in zip(seats, students):\n        moves += abs(i - j)\n\n    return moves\n\n\nprint(minMovesToSeat([3, 1, 5], [2, 7, 4]))  # 4\n</code></pre>"},{"location":"leetpattern/greedy/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return the length of the longest wiggle subsequence.</li> <li><code>up[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a rising wiggle.</li> <li><code>down[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a falling wiggle.</li> <li>Initialize <code>up[0] = 1</code> and <code>down[0] = 1</code>.</li> <li>Example: <code>nums = [1, 7, 4, 9, 2, 5]</code></li> </ul> <code>nums[n]</code> <code>nums[n-1]</code> <code>up[n-1]</code> <code>down[n-1]</code> <code>up[n]</code> <code>down[n]</code> 1 - - - 1 1 7 1 1 1 2 1 4 7 2 1 2 3 9 4 2 3 4 3 2 9 4 3 4 5 5 2 4 5 6 5 <pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"leetpattern/greedy/#738-monotone-increasing-digits","title":"738. Monotone Increasing Digits","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, greedy</li> <li>Return the largest number that is less than or equal to <code>n</code> with monotone increasing digits.</li> </ul> <pre><code># Greedy\ndef monotoneIncreasingDigits(n: int) -&gt; int:\n    strNum = list(str(n))\n\n    for i in range(len(strNum) - 2, -1, -1):\n        if int(strNum[i]) &gt; int(strNum[i + 1]):\n            strNum[i] = str(int(strNum[i]) - 1)\n            strNum[i + 1 :] = [\"9\"] * (len(strNum) - (i + 1))\n\n    return int(\"\".join(strNum))\n\n\nn = 332\nprint(monotoneIncreasingDigits(n))  # 299\n</code></pre>"},{"location":"leetpattern/greedy/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return the maximum profit you can achieve.</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"leetpattern/greedy/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return the maximum profit you can achieve with the given transaction fee.</li> </ul> <pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"leetpattern/greedy/#135-candy","title":"135. Candy","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, greedy</li> <li>Return the minimum number of candies you must give.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"leetpattern/greedy/#406-queue-reconstruction-by-height","title":"406. Queue Reconstruction by Height","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary indexed tree, segment tree, sorting</li> <li>Reconstruct the queue.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef reconstructQueue(people: List[List[int]]) -&gt; List[List[int]]:\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for i in people:\n        queue.insert(i[1], i)\n\n    return queue\n\n\npeople = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nprint(reconstructQueue(people))\n# [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n</code></pre>"},{"location":"leetpattern/greedy/#3075-maximize-happiness-of-selected-children","title":"3075. Maximize Happiness of Selected Children","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, greedy, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef maximumHappinessSum(happiness: List[int], k: int) -&gt; int:\n    selected = 0\n    happinessScore = 0\n    happiness.sort(reverse=True)\n\n    for score in happiness:\n        if selected == k:\n            return happinessScore\n        happinessScore += max(0, score - selected)\n        selected += 1\n\n    return happinessScore\n\n\nhappiness = [1, 2, 3]\nk = 2\nprint(maximumHappinessSum(happiness, k))  # 4\n</code></pre>"},{"location":"leetpattern/greedy/#945-minimum-increment-to-make-array-unique","title":"945. Minimum Increment to Make Array Unique","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, greedy, sorting, counting</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef minIncrementForUnique(nums: List[int]) -&gt; int:\n    nums.sort()\n    moves = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] &lt;= nums[i - 1]:\n            moves += nums[i - 1] + 1 - nums[i]\n            nums[i] = nums[i - 1] + 1\n\n    return moves\n\n\nnums = [1, 2, 2]\nprint(minIncrementForUnique(nums))  # 1\n</code></pre>"},{"location":"leetpattern/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"leetpattern/greedy/#134-gas-station","title":"134. Gas Station","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, greedy</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre>"},{"location":"leetpattern/greedy/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: dynamic programming, tree, depth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef minCameraCover(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, hasParent):\n        if not node:\n            return -1\n\n        nonlocal res\n        left, right = dfs(node.left, True), dfs(node.right, True)\n\n        if left == -1 and right == -1:\n            if hasParent:\n                return 0\n            res += 1\n            return 2\n        if left == 0 or right == 0:\n            res += 1\n            return 2\n        if left == 2 or right == 2:\n            return 1\n        if hasParent:\n            return 0\n        res += 1\n        return 2\n\n    dfs(root, False)\n\n    return res\n\n\nroot = build([0, 0, None, 0, 0])\nprint(root)\nprint(minCameraCover(root))  # 1\n</code></pre>"},{"location":"leetpattern/greedy/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, greedy, sorting, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre>"},{"location":"leetpattern/hash_counting/","title":"Hash Counting","text":""},{"location":"leetpattern/hash_counting/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, string, sorting</li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> <pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"leetpattern/hash_counting/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"leetpattern/hash_counting/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, sorting</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"leetpattern/hash_counting/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"leetpattern/hash_map/","title":"Hash Map","text":""},{"location":"leetpattern/hash_map/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, string, counting</li> <li>Return <code>True</code> if the ransom note can be constructed from the magazines, otherwise, return <code>False</code>.</li> </ul> <pre><code>graph LR\n    A[\"Magazine: abcdef\"] --&gt; C(True)\n    B[\"Ransom Note: abc\"] --&gt; C</code></pre> <pre><code>from collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"leetpattern/hash_map/#350-intersection-of-two-arrays-ii","title":"350. Intersection of Two Arrays II","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, two pointers, binary search, sorting</li> <li>Return the intersection of two arrays.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hashmap\ndef intersect(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    hashmap = defaultdict(int)  # {num: count}\n    result = []\n\n    for i in nums1:\n        hashmap[i] += 1\n\n    for i in nums2:\n        if hashmap[i] &gt; 0:\n            result.append(i)\n            hashmap[i] -= 1\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Hashmap   |   O(n + m)  | O(min(n, m)) |\n# |-------------|-------------|--------------|\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersect(nums1, nums2))  # [2, 2]\n</code></pre>"},{"location":"leetpattern/hash_map/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table</li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) <pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"leetpattern/hash_map/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, string, greedy</li> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> <pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"leetpattern/hash_map/#1365-how-many-numbers-are-smaller-than-the-current-number","title":"1365. How Many Numbers Are Smaller Than the Current Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, sorting, counting</li> <li>For each number in the array, return how many numbers are smaller than it.</li> </ul> <pre><code>from typing import List\n\n\ndef smallerNumbersThanCurrent(nums: List[int]) -&gt; List[int]:\n    sortedNums = sorted(nums)\n\n    hashmap = dict()\n\n    for i, num in enumerate(sortedNums):\n        if num not in hashmap:\n            hashmap[num] = i\n\n    result = []\n    for i in range(len(sortedNums)):\n        result.append(hashmap[nums[i]])\n\n    return result\n\n\nnums = [8, 1, 2, 2, 3]\nprint(smallerNumbersThanCurrent(nums))  # [4, 0, 1, 1, 3]\n</code></pre>"},{"location":"leetpattern/hash_map/#202-happy-number","title":"202. Happy Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, math, two pointers</li> <li>Return <code>True</code> if the number is a happy number, otherwise, return <code>False</code>.</li> <li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> </ul> <pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"leetpattern/hash_map/#454-4sum-ii","title":"454. 4Sum II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table</li> <li>Return the number of tuples <code>(i, j, k, l)</code> such that <code>A[i] + B[j] + C[k] + D[l] == 0</code>.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef fourSumCount(\n    nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n) -&gt; int:\n\n    sumAB = defaultdict(int)\n    result = 0\n\n    for i in nums1:\n        for j in nums2:\n            sumAB[i + j] += 1\n\n    for i in nums3:\n        for j in nums4:\n            if -(i + j) in sumAB:\n                result += sumAB[-(i + j)]\n\n    return result\n\n\nnums1 = [1, 2]\nnums2 = [-2, -1]\nnums3 = [-1, 2]\nnums4 = [0, 2]\nprint(fourSumCount(nums1, nums2, nums3, nums4))  # 2\n</code></pre>"},{"location":"leetpattern/hash_set/","title":"Hash Set","text":""},{"location":"leetpattern/hash_set/#349-intersection-of-two-arrays","title":"349. Intersection of Two Arrays","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, two pointers, binary search, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Set\ndef intersectionSet(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return list(set1 &amp; set2)\n\n\n# Hash\ndef intersectionHash(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    result = set()\n\n    for num in nums2:\n        if num in set1:\n            result.add(num)\n\n    return list(result)\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     Set    | O(n+m) |  O(n+m) |\n# |    Hash    | O(n+m) |   O(n)  |\n# |------------|--------|---------|\n\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersectionSet(nums1, nums2))  # [2]\nprint(intersectionHash(nums1, nums2))  # [2]\n</code></pre>"},{"location":"leetpattern/heap/","title":"Heap","text":""},{"location":"leetpattern/heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, heap priority queue</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"leetpattern/heap_merge_k_sorted/","title":"Heap Merge K Sorted","text":""},{"location":"leetpattern/heap_merge_k_sorted/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: linked list, divide and conquer, heap priority queue, merge sort</li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> <pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"leetpattern/heap_merge_k_sorted/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, heap priority queue</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(\n    nums1: List[int], nums2: List[int], k: int\n) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    result = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return result\n\n\nnums1 = [1, 2, 4, 5, 6]\nnums2 = [3, 5, 7, 9]\nk = 3\nprint(kSmallestPairs(nums1, nums2, k))\n# [[1, 3], [2, 3], [1, 5]]\n</code></pre>"},{"location":"leetpattern/heap_merge_k_sorted/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, sorting, heap priority queue, matrix</li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> <pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"leetpattern/heap_top_k/","title":"Heap Top K","text":""},{"location":"leetpattern/heap_top_k/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, sorting, heap priority queue, quickselect</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    heap = nums[:k]\n    heapq.heapify(heap)  # min heap\n\n    for num in nums[k:]:\n        if num &gt; heap[0]:\n            heapq.heappop(heap)  # pop the smallest element\n            heapq.heappush(heap, num)  # push the new element\n\n    return heap[0]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\nnums = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(findKthLargest(nums, k))  # 5\n</code></pre>"},{"location":"leetpattern/heap_top_k/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, math, divide and conquer, geometry, sorting, heap priority queue, quickselect</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"leetpattern/heap_top_k/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect</li> </ul> <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"leetpattern/heap_top_k/#692-top-k-frequent-words","title":"692. Top K Frequent Words","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, trie, sorting, heap priority queue, bucket sort, counting</li> </ul> <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\nclass WordFrequency:\n    def __init__(self, word, freq):\n        self.word = word\n        self.freq = freq\n\n    def __lt__(self, other):\n        # If the frequency is different\n        if self.freq != other.freq:\n            # The word with the lower frequency comes first\n            return self.freq &lt; other.freq\n        else:\n            # The word with the lower alphabetical order comes first\n            return self.word &gt; other.word\n\n\ndef topKFrequent(words: List[str], k: int) -&gt; List[str]:\n    heap = []\n\n    for word, freq in Counter(words).items():\n        heapq.heappush(heap, WordFrequency(word, freq))\n\n        if len(heap) &gt; k:\n            heapq.heappop(heap)\n\n    heap.sort(reverse=True)\n    return [x.word for x in heap]\n\n\nwords = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"]\nk = 2\nprint(topKFrequent(words, k))  # [\"i\", \"love\"]\n</code></pre>"},{"location":"leetpattern/heap_top_k/#264-ugly-number-ii","title":"264. Ugly Number II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, math, dynamic programming, heap priority queue</li> </ul> <pre><code>import heapq\n\n\ndef nthUglyNumber(n: int) -&gt; int:\n    heap = [1]\n    seen = set(heap)\n\n    factors = [2, 3, 5]\n    current = 1\n\n    # Pop the smallest ugly number n times\n    for _ in range(n):\n        current = heapq.heappop(heap)  # Pop the smallest ugly number\n\n        for factor in factors:\n            new = current * factor\n            if new not in seen:\n                seen.add(new)\n                heapq.heappush(heap, new)\n\n    return current\n\n\nprint(nthUglyNumber(10))  # 12\n</code></pre>"},{"location":"leetpattern/heap_top_k/#451-sort-characters-by-frequency","title":"451. Sort Characters By Frequency","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sorting, heap priority queue, bucket sort, counting</li> </ul> <pre><code>import heapq\nfrom collections import Counter\n\n\ndef frequencySort(s: str) -&gt; str:\n    result = \"\"\n\n    # Max Heap\n    heap = [(-freq, val) for val, freq in Counter(s).items()]\n    heapq.heapify(heap)\n\n    while heap:\n        freq, val = heapq.heappop(heap)\n        result += val * -freq\n\n    return result\n\n\nprint(frequencySort(\"tree\"))  # eert\n</code></pre>"},{"location":"leetpattern/heap_top_k/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, design, binary search tree, heap priority queue, binary tree, data stream</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"leetpattern/heap_top_k/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, greedy, sorting, heap priority queue, counting</li> </ul> <pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if (\n            prev_count &lt; 0\n        ):  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = (\n            count + 1\n        )  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre>"},{"location":"leetpattern/heap_top_k/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, binary search, sorting, heap priority queue</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre>"},{"location":"leetpattern/heap_two_heaps/","title":"Heap Two Heaps","text":""},{"location":"leetpattern/heap_two_heaps/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: two pointers, design, sorting, heap priority queue, data stream</li> </ul> <pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"leetpattern/heap_two_heaps/#480-sliding-window-median","title":"480. Sliding Window Median","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, hash table, sliding window, heap priority queue</li> </ul> <pre><code>import heapq\nfrom typing import List\n\nfrom sortedcontainers import SortedList\n\n\n# Heap - Two Heaps\ndef medianSlidingWindow1(nums: List[int], k: int) -&gt; List[float]:\n    min_heap, max_heap = [], []\n\n    for i in range(k):\n        heapq.heappush(min_heap, (nums[i], i))\n    for i in range(k // 2):\n        n, idx = heapq.heappop(min_heap)\n        heapq.heappush(max_heap, (-n, idx))\n\n    res = [\n        (\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n    ]\n\n    for i in range(k, len(nums)):\n        if nums[i] &lt; min_heap[0][0]:\n            heapq.heappush(max_heap, (-nums[i], i))\n\n            if nums[i - k] &gt;= min_heap[0][0]:\n                n, idx = heapq.heappop(max_heap)\n                heapq.heappush(min_heap, (-n, idx))\n        else:\n            heapq.heappush(min_heap, (nums[i], i))\n\n            if nums[i - k] &lt;= min_heap[0][0]:\n                n, idx = heapq.heappop(min_heap)\n                heapq.heappush(max_heap, (-n, idx))\n\n        while min_heap and min_heap[0][1] &lt;= i - k:\n            heapq.heappop(min_heap)\n        while max_heap and max_heap[0][1] &lt;= i - k:\n            heapq.heappop(max_heap)\n\n        res.append(\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n\n    return res\n\n\n# Sorted List\ndef medianSlidingWindow2(nums: List[int], k: int) -&gt; List[float]:\n    window = SortedList()\n    res = []\n\n    for i in range(len(nums)):\n        window.add(nums[i])\n\n        if len(window) == k:\n            if k % 2 == 1:\n                res.append(window[k // 2])\n            else:\n                res.append((window[k // 2 - 1] + window[k // 2]) / 2.0)\n\n            window.remove(nums[i - k + 1])\n\n    return res\n\n\nnums = [1, 2, 3, 4, 2, 3, 1, 4, 2]\nk = 3\nprint(medianSlidingWindow1(nums, k))\nprint(medianSlidingWindow2(nums, k))\n</code></pre>"},{"location":"leetpattern/heap_two_heaps/#502-ipo","title":"502. IPO","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, greedy, sorting, heap priority queue</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(\n    k: int, w: int, profits: List[int], capital: List[int]\n) -&gt; int:\n    if not profits or not capital:\n        return w\n\n    minHeap = []\n    maxHeap = []\n\n    for i in range(len(profits)):\n        heapq.heappush(minHeap, (capital[i], profits[i]))\n\n    for _ in range(k):\n        while minHeap and minHeap[0][0] &lt;= w:\n            capital, profit = heapq.heappop(minHeap)\n            heapq.heappush(maxHeap, -profit)\n\n        if not maxHeap:\n            break\n\n        w += -heapq.heappop(maxHeap)\n\n    return w\n\n\nk = 2\nw = 0\nprofits = [1, 2, 3]\ncapital = [0, 1, 1]\nprint(findMaximizedCapital(k, w, profits, capital))  # 4\n</code></pre>"},{"location":"leetpattern/intervals/","title":"Intervals","text":""},{"location":"leetpattern/intervals/#55-jump-game","title":"55. Jump Game","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True <pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    maxReach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= maxReach:\n        maxReach = max(maxReach, i + nums[i])\n        if maxReach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"leetpattern/intervals/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if len(nums) == 1:\n        return 0\n\n    maxReach = 0\n    step = 0\n    left, right = 0, 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            maxReach = max(maxReach, i + nums[i])\n        left = right + 1\n        right = maxReach\n        step += 1\n\n    return step\n\n\nprint(jump([2, 3, 1, 1, 4, 2, 1]))  # 3\n</code></pre>"},{"location":"leetpattern/intervals/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, greedy, sorting</li> <li>Return the minimum number of arrows.</li> </ul> <ul> <li>Differece between two versions<ol> <li>Start from 1: if there is no overlap, we add one more arrow.</li> <li>Start from the number of balloons: if there is overlap, we need to reduce one arrow.</li> </ol> </li> </ul> <pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 1:\n        return n\n\n    res = 1\n    points.sort(key=lambda x: x[0])\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            res += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n    return res\n\n\n# Greedy - Interval (Neetcode's version)\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    res = len(points)\n    if res == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            res -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return res\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy3(points: List[List[int]]) -&gt; int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n\n    res = 1\n    cur_end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] &gt; cur_end:\n            res += 1\n            cur_end = points[i][1]\n\n    return res\n\n\n# Utility\ndef plot(points, i=None):\n    plt.figure(figsize=(8, 4))\n    for idx in range(len(points)):\n        color = \"b\" if idx == i else \"k\"\n        plt.plot(\n            [points[idx][0], points[idx][1]],\n            [idx + 1, idx + 1],\n            f\"{color}o-\",\n            label=f\"Line {idx + 1}\",\n        )\n\n    plt.title(\"Find Min Arrow Shots\")\n    plt.xlabel(\"X-axis\")\n    plt.xlim(0, 17)\n    plt.grid(True)\n    plt.savefig(f\"find_min_arrow_shots_{i}.png\")\n    plt.show()\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"leetpattern/intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy, sorting</li> </ul> <pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"leetpattern/intervals/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, two pointers, string, greedy</li> </ul> <pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    # Time complexity: O(nlogn)\n    # Space complexity: O(n)\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    result = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            result.append(intervals[i][0])\n\n    result.append(intervals[-1][1] + 1)\n\n    if len(result) == 1:\n        return result\n    else:\n        for i in range(len(result) - 1, 0, -1):\n            result[i] -= result[i - 1]\n        return result\n\n\n# 2. Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    last = {c: i for i, c in enumerate(s)}\n\n    start, end = 0, 0\n    result = []\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if i == end:\n            result.append(end - start + 1)\n            start = i + 1\n\n    return result\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"leetpattern/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, sorting</li> <li>Merge all overlapping intervals.</li> </ul> <pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"leetpattern/kmp/","title":"KMP","text":""},{"location":"leetpattern/kmp/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string, string matching</li> </ul> <pre><code>from template import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre>"},{"location":"leetpattern/kmp/#459-repeated-substring-pattern","title":"459. Repeated Substring Pattern","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, string matching</li> </ul> <pre><code>from template import LPS\n\n\n# KMP\ndef repeatedSubstringPattern(s: str) -&gt; bool:\n    lps = LPS(s)\n    length = len(s)\n\n    if lps[-1] != 0 and length % (length - lps[-1]) == 0:\n        return True\n\n    return False\n\n\ns = \"abab\"\nprint(repeatedSubstringPattern(s))  # True\n</code></pre>"},{"location":"leetpattern/kmp/#686-repeated-string-match","title":"686. Repeated String Match","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, string matching</li> </ul> <pre><code>import math\n\nfrom template import LPS\n\n\n# KMP\ndef repeatedStringMatch(a: str, b: str) -&gt; int:\n    min_repeat = math.ceil(len(b) / len(a))\n\n    def kmp(text, pattern):\n        n, m = len(text), len(pattern)\n        lps = LPS(pattern)\n        j = 0\n\n        for i in range(n):\n            while j &gt; 0 and text[i] != pattern[j]:\n                j = lps[j - 1]\n            if text[i] == pattern[j]:\n                j += 1\n            if j == m:\n                return i - j + 1\n        return -1\n\n    for i in range(min_repeat, min_repeat + 2):\n        if kmp(a * i, b) != -1:\n            return i\n    return -1\n\n\nprint(repeatedStringMatch(\"abcd\", \"cdabcdab\"))  # 3\n</code></pre>"},{"location":"leetpattern/kmp/#1392-longest-happy-prefix","title":"1392. Longest Happy Prefix","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: string, rolling hash, string matching, hash function</li> </ul> <pre><code>from template import LPS\n\n\n# KMP\ndef longestPrefix(s: str) -&gt; str:\n    if len(s) &lt;= 1:\n        return \"\"\n\n    lps = LPS(s)\n\n    return s[: lps[-1]]\n\n\nprint(longestPrefix(\"ababab\"))  # abab\n</code></pre>"},{"location":"leetpattern/kmp/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: string, rolling hash, string matching, hash function</li> </ul> <pre><code>from template import LPS\n\n\n# KMP\ndef shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre>"},{"location":"leetpattern/left_right_pointers/","title":"Left Right Pointers","text":""},{"location":"leetpattern/left_right_pointers/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math</li> <li>Return true if the given number is a palindrome. Otherwise, return false.</li> </ul> <pre><code># Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# |-----------|---------|---------|\n# | Approach  |   Time  |  Space  |\n# |-----------|---------|---------|\n# | LR Pointer|  O(n^2) |   O(1)  |\n# |-----------|---------|---------|\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))  # [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#18-4sum","title":"18. 4Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    \"\"\"Returns all unique quadruplets that sum up to the target.\"\"\"\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n# [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#69-sqrtx","title":"69. Sqrt(x)","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, binary search</li> </ul> <pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    \"\"\"Merges two sorted arrays in-place.\"\"\"\n    p1, p2, t = m - 1, n - 1, m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n\n        t -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#977-squares-of-a-sorted-array","title":"977. Squares of a Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    \"\"\"Returns the squares of the sorted array.\"\"\"\n    n = len(nums)\n    result = [0 for _ in range(n)]\n\n    left, right, tail = 0, n - 1, n - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[tail] = nums[left] ** 2\n            left += 1\n        else:\n            result[tail] = nums[right] ** 2\n            right -= 1\n        tail -= 1\n\n    return result\n\n\n# |---------------------|------|-------|\n# | Approach            | Time | Space |\n# |---------------------|------|-------|\n# | Left Right Pointers | O(n) | O(n)  |\n# |---------------------|------|-------|\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#881-boats-to-save-people","title":"881. Boats to Save People","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, greedy, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef numRescueBoats(people: List[int], limit: int) -&gt; int:\n    \"\"\"Returns the minimum number of boats to rescue people.\"\"\"\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n\n    while left &lt;= right:\n        if people[left] + people[right] &lt;= limit:\n            left += 1\n        right -= 1\n        boats += 1\n\n    return boats\n\n\npeople = [3, 2, 2, 1]\nlimit = 3\nprint(numRescueBoats(people, limit))  # 3\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortColors(nums: List[int]) -&gt; None:\n    \"\"\"Sorts an array of 0, 1, and 2 in-place.\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    current = 0\n\n    while current &lt;= right:\n        if nums[current] == 0:\n            nums[left], nums[current] = nums[current], nums[left]\n            left += 1\n            current += 1\n        elif nums[current] == 2:\n            nums[right], nums[current] = nums[current], nums[right]\n            right -= 1\n        else:\n            current += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nsortColors(nums)\nprint(nums)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string</li> </ul> <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II -   Input Array Is Sorted","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, binary search</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, greedy</li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"leetpattern/linked_list/","title":"Linked List","text":""},{"location":"leetpattern/linked_list/#203-remove-linked-list-elements","title":"203. Remove Linked List Elements","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: linked list, recursion</li> <li> <p>Remove all elements from a linked list of integers that have value <code>val</code>.</p> </li> <li> <p>Before</p> </li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((6))\nC --&gt; D((3))\nD --&gt; E((4))\nE --&gt; F((5))\nF --&gt; G((6))\nG --&gt; H((None))</code></pre> <ul> <li>After</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB -.-&gt; C((6))\nC -.-&gt; D((3))\nD --&gt; E((4))\nE --&gt; F((5))\nF -.-&gt; G((6))\nB --&gt; D((3))\nF --&gt; I((None))</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef removeElements(head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = dummy\n\n    while cur.next:\n        if cur.next.val == val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Iterative  |      O(N)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\n\nnums = [1, 2, 6, 3, 4, 5, 6]\nval = 6\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nprint(removeElements(head, val))\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"leetpattern/linked_list/#707-design-linked-list","title":"707. Design Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, design</li> <li>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</li> </ul> <pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.dummy = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -&gt; int:\n        if index &lt; 0 or index &gt;= self.size:\n            return -1\n\n        current = self.dummy.next\n        for _ in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -&gt; None:\n        self.dummy.next = ListNode(val, self.dummy.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -&gt; None:\n        current = self.dummy\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n        if index &lt; 0 or index &gt; self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n        if index &lt; 0 or index &gt;= self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1\n\n\nll = MyLinkedList()\nll.addAtHead(1)\nll.addAtTail(3)\nll.addAtIndex(1, 2)  # 1 -&gt; 2 -&gt; 3\nprint(ll.get(1))  # 2\n</code></pre>"},{"location":"leetpattern/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: linked list, recursion</li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[3]\nC --&gt; D[4]\nD --&gt; E[5]</code></pre> <pre><code>graph RL\nE[5] --&gt; D[4]\nD --&gt; C[3]\nC --&gt; B[2]\nB --&gt; A[1]</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"leetpattern/linked_list/#237-delete-node-in-a-linked-list","title":"237. Delete Node in a Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list</li> <li>Delete a node in a singly linked list. You are given only the node to be deleted.</li> </ul> <pre><code>from template import ListNode\n\n\ndef deleteNode(node: ListNode) -&gt; None:\n    node.val = node.next.val\n    node.next = node.next.next\n\n\nhead = ListNode.create([4, 5, 1, 9])\nnode = head.next\ndeleteNode(node)\nprint(head)  # 4 -&gt; 1 -&gt; 9\n</code></pre>"},{"location":"leetpattern/linked_list/#2487-remove-nodes-from-linked-list","title":"2487. Remove Nodes From Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, stack, recursion, monotonic stack</li> <li>Remove all nodes from a linked list that have a value greater than <code>maxValue</code>.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Recursive\ndef removeNodesRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    head.next = removeNodesRecursive(head.next)\n\n    if head.next and head.val &lt; head.next.val:\n        return head.next\n\n    return head\n\n\n# Iterative\ndef removeNodesIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    stack = []\n    cur = head\n\n    while cur:\n        # pop all nodes in stack that are smaller than cur\n        while stack and cur.val &gt; stack[-1].val:\n            stack.pop()\n\n        stack.append(cur)\n        cur = cur.next\n\n    # link all nodes in stack\n    dummy = ListNode()\n    cur = dummy\n\n    for node in stack:\n        cur.next = node\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = [5, 2, 13, 3, 8]\nhead1 = ListNode.create(head)\nprint(head1)  # 5 -&gt; 2 -&gt; 13 -&gt; 3 -&gt; 8\nprint(removeNodesRecursive(head1))  # 13 -&gt; 8\nhead2 = ListNode.create(head)\nprint(removeNodesIterative(head2))  # 13 -&gt; 8\n</code></pre>"},{"location":"leetpattern/linked_list/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, recursion</li> <li>Given a linked list, swap every two adjacent nodes and return its head.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef swapPairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    cur = dummy\n\n    while cur.next and cur.next.next:\n        temp = cur.next\n        temp1 = cur.next.next.next\n\n        cur.next = cur.next.next\n        cur.next.next = temp\n        temp.next = temp1\n        cur = cur.next.next\n\n    return dummy.next\n\n\nnums = [1, 2, 3, 4, 5]\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(swapPairs(head))\n# 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"leetpattern/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, two pointers</li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"leetpattern/linked_list/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, linked list, two pointers</li> <li>Find the node at which the intersection of two singly linked lists begins.</li> </ul> <pre><code>graph LR\na1((a1)) --&gt; a2((a2))\na2 --&gt; c1((c1))\nb1((b1)) --&gt; b2((b2))\nb2 --&gt; b3((b3))\nb3 --&gt; c1\nc1 --&gt; c2((c2))\nc2 --&gt; c3((c3))</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Hash Set\ndef getIntersectionNodeHash(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    \"\"\"Return the intersection node of two linked lists.\"\"\"\n    if not headA or not headB:\n        return None\n\n    visited = set()\n    cur = headA\n    while cur:\n        visited.add(cur)\n        cur = cur.next\n\n    cur = headB\n    while cur:\n        if cur in visited:\n            return cur\n        cur = cur.next\n\n    return None\n\n\n# Two Pointers\ndef getIntersectionNodeTP(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    \"\"\"Return the intersection node of two linked lists.\"\"\"\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Hash Set  | O(n+m) |  O(n)   |\n# |Two Pointers| O(n+m) |  O(1)   |\n# |------------|--------|---------|\n\n\nlistA = [4, 1, 8, 4, 5]\nlistB = [5, 6, 1, 8, 4, 5]\nheadA = ListNode.create(listA)\nprint(headA)\n# 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\nheadB = ListNode.create(listB)\nprint(headB)\n# 5 -&gt; 6 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\n\nheadA.intersect(headB, 8)\n\nprint(getIntersectionNodeHash(headA, headB))\n# 8 -&gt; 4 -&gt; 5\nprint(getIntersectionNodeTP(headA, headB))\n# 8 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"leetpattern/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, linked list, two pointers</li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]</code></pre> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"leetpattern/linked_list/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list, two pointers</li> <li>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>None</code>.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\nhead1 = ListNode.create([3, 2, 0, -4], 1)\nprint(detectCycle(head1).val)  # 2\nhead2 = ListNode.create([3, 2, 0, -4])\nprint(detectCycle(head2))  # None\n</code></pre>"},{"location":"leetpattern/linked_list/#2816-double-a-number-represented-as-a-linked-list","title":"2816. Double a Number Represented as a Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, math, stack</li> <li>Given a number represented as a linked list, double it and return the resulting linked list.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef doubleIt(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n    def twice(node):\n        if not node:\n            return 0\n        doubled_value = node.val * 2 + twice(node.next)\n        node.val = doubled_value % 10\n        return doubled_value // 10\n\n    carry = twice(head)\n\n    if carry:\n        head = ListNode(val=carry, next=head)\n\n    return head\n\n\nhead = ListNode.create([1, 2, 3, 4])\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(doubleIt(head))\n# 2 -&gt; 4 -&gt; 6 -&gt; 8\n</code></pre>"},{"location":"leetpattern/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, math, recursion</li> <li>Represent the sum of two numbers as a linked list.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre>"},{"location":"leetpattern/math/","title":"Math","text":""},{"location":"leetpattern/math/#1945-sum-of-digits-of-string-after-convert","title":"1945. Sum of Digits of String After Convert","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, simulation</li> </ul> <pre><code># Math\ndef getLucky(s: str, k: int) -&gt; int:\n    def getSum(n: int) -&gt; int:\n        total = 0\n        while n != 0:\n            n, m = divmod(n, 10)\n            total += m\n        return total\n\n    result = \"\"\n    for i in s:\n        result += str(ord(i) - ord(\"a\") + 1)\n    result = int(result)\n\n    for _ in range(k):\n        result = getSum(result)\n\n    return result\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"iiii\"\nk = 1\n\nprint(getLucky(s, k))  # 36\n</code></pre>"},{"location":"leetpattern/math/#1894-find-the-student-that-will-replace-the-chalk","title":"1894. Find the Student that Will Replace the Chalk","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, simulation, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# Math\ndef chalkReplacer(chalk: List[int], k: int) -&gt; int:\n    total = sum(chalk)\n\n    k %= total\n\n    for i, c in enumerate(chalk):\n        k -= c\n\n        if k &lt; 0:\n            return i\n\n    return -1\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nchalk = [5, 1, 5]\nk = 22\n\nprint(chalkReplacer(chalk, k))  # 0\n</code></pre>"},{"location":"leetpattern/math/#7-reverse-integer","title":"7. Reverse Integer","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math</li> </ul> <pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre>"},{"location":"leetpattern/prefix_sum/","title":"Prefix Sum","text":""},{"location":"leetpattern/prefix_sum/#2574-left-and-right-sum-differences","title":"2574. Left and Right Sum Differences","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# Prefix Sum\ndef leftRightDifferenceSum(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    left = [0 for _ in range(n)]\n    right = [0 for _ in range(n)]\n\n    for i in range(1, n):\n        left[i] = left[i - 1] + nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right[i] = right[i + 1] + nums[i + 1]\n\n    return [abs(left[i] - right[i]) for i in range(n)]\n\n\n# Left Right Pointers\ndef leftRightDifferencePointer(nums: List[int]) -&gt; List[int]:\n    left, right = 0, sum(nums)\n    result = []\n\n    for num in nums:\n        right -= num\n        result.append(abs(left - right))\n        left += num\n\n    return result\n\n\nnums = [10, 4, 8, 3]\nprint(leftRightDifferenceSum(nums))  # [15, 1, 11, 22]\nprint(leftRightDifferencePointer(nums))  # [15, 1, 11, 22]\n</code></pre>"},{"location":"leetpattern/prefix_sum/#1732-find-the-highest-altitude","title":"1732. Find the Highest Altitude","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, prefix sum</li> </ul> <pre><code>from typing import List\n\n\ndef largestAltitude(gain: List[int]) -&gt; int:\n    result, altitude = 0, 0\n\n    for i in gain:\n        altitude += i\n        result = max(result, altitude)\n\n    return result\n\n\ngain = [-5, 1, 5, 0, -7]\nprint(largestAltitude(gain))  # 1\n</code></pre>"},{"location":"leetpattern/prefix_sum/#303-range-sum-query-immutable","title":"303. Range Sum Query -   Immutable","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, design, prefix sum</li> </ul> <pre><code>from typing import List\n\n\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.prefix_sum = [0 for _ in range(len(nums) + 1)]\n\n        for i in range(1, len(nums) + 1):\n            self.prefix_sum[i] = self.prefix_sum[i - 1] + nums[i - 1]\n\n    def sumRange(self, left: int, right: int) -&gt; int:\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\n\n\nnums = [-2, 0, 3, -5, 2, -1]\nobj = NumArray(nums)\nassert obj.sumRange(0, 2) == 1\nassert obj.sumRange(2, 5) == -1\nassert obj.sumRange(0, 5) == -3\nprint(\"PASSED\")\n</code></pre>"},{"location":"leetpattern/prefix_sum/#304-range-sum-query-2d-immutable","title":"304. Range Sum Query 2D -   Immutable","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, design, matrix, prefix sum</li> </ul> <pre><code>from typing import List\n\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return None\n\n        self.sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sum[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sum[i - 1][j]\n                    + self.sum[i][j - 1]\n                    - self.sum[i - 1][j - 1]  # to avoid double counting\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return (\n            self.sum[row2 + 1][col2 + 1]\n            - self.sum[row1][col2 + 1]\n            - self.sum[row2 + 1][col1]\n            + self.sum[row1][col1]\n        )\n\n\nmatrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5],\n]\nobj = NumMatrix(matrix)\nassert obj.sumRegion(2, 1, 4, 3) == 8\nassert obj.sumRegion(1, 1, 2, 2) == 11\nassert obj.sumRegion(1, 2, 2, 4) == 12\nprint(\"PASSED\")\n</code></pre>"},{"location":"leetpattern/prefix_sum/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"leetpattern/prefix_sum/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# 2. Prefix - Optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |    Prefix   |    O(n)     |    O(n)      |\n# |Prefix - Opt |    O(n)     |    O(1)      |\n# |-------------|-------------|--------------|\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"leetpattern/prefix_sum/#974-subarray-sums-divisible-by-k","title":"974. Subarray Sums Divisible by K","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, prefix sum</li> </ul> <pre><code>from typing import List\n\n\ndef subarraysDivByK_1(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n\n        if mod &lt; 0:\n            mod += k\n\n        if mod in mods:\n            result += mods[mod]\n\n        if mod in mods:\n            mods[mod] += 1\n        else:\n            mods[mod] = 1\n\n    return result\n\n\ndef subarraysDivByK_2(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n        result += mods.get(mod, 0)\n        mods[mod] = mods.get(mod, 0) + 1\n\n    return result\n\n\nnums = [4, 5, 0, -2, -3, 1]\nk = 5\nprint(subarraysDivByK_1(nums, k))  # 7\nprint(subarraysDivByK_2(nums, k))  # 7\n</code></pre>"},{"location":"leetpattern/prefix_sum/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, sliding window, prefix sum</li> </ul> <pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding window - Fixed\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    left, right = 0, 0\n    curSum = 0\n    minLen = float(\"inf\")\n\n    while right &lt; len(nums):\n        curSum += nums[right]\n\n        while curSum &gt;= target:\n            minLen = min(minLen, right - left + 1)\n            curSum -= nums[left]\n            left += 1\n\n        right += 1\n\n    return minLen if minLen != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"leetpattern/prefix_sum/#523-continuous-subarray-sum","title":"523. Continuous Subarray Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, math, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# Prefix Sum\ndef checkSubarraySum(nums: List[int], k: int) -&gt; bool:\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i - 1] == 0 and nums[i] == 0:\n                return True\n\n    prefix_sum = 0\n    mod_dict = {0: -1}\n\n    for i, num in enumerate(nums):\n        prefix_sum += num\n        mod = prefix_sum % k\n\n        if mod in mod_dict:\n            if i - mod_dict[mod] &gt; 1:\n                return True\n        else:\n            mod_dict[mod] = i\n\n    return False\n\n\nnums = [23, 2, 4, 6, 7]\nk = 6\nprint(checkSubarraySum(nums, k))  # True\n</code></pre>"},{"location":"leetpattern/prefix_sum/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, math, sliding window, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# Prefix Sum\ndef numberOfSubarrays(nums: List[int], k: int) -&gt; int:\n    count = 0\n    odd_counts = {0: 1}  # odd_count -&gt; count\n    odd_count = 0\n\n    for num in nums:\n        if num % 2 == 1:\n            odd_count += 1\n        if odd_count - k in odd_counts:\n            count += odd_counts[odd_count - k]\n        if odd_count in odd_counts:\n            odd_counts[odd_count] += 1\n        else:\n            odd_counts[odd_count] = 1\n\n    return count\n\n\nnums = [1, 1, 2, 1, 1]\nk = 3\nprint(numberOfSubarrays(nums, k))  # 2\n</code></pre>"},{"location":"leetpattern/prefix_sum/#325-maximum-size-subarray-sum-equals-k","title":"325. Maximum Size Subarray Sum Equals k","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# Prefix Sum\ndef maxSubArrayLen(nums: List[int], k: int) -&gt; int:\n    res = 0\n    prefix = 0\n    sumMap = {0: -1}  # sum -&gt; index\n\n    for i, num in enumerate(nums):\n        prefix += num\n        if prefix - k in sumMap:\n            res = max(res, i - sumMap[prefix - k])\n        if prefix not in sumMap:\n            sumMap[prefix] = i\n\n    return res\n\n\nnums = [1, -1, 5, -2, 3]\nk = 3\nprint(maxSubArrayLen(nums, k))  # 4\n</code></pre>"},{"location":"leetpattern/prefix_sum/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre>"},{"location":"leetpattern/prefix_sum/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Prefix Sum\ndef removeZeroSumSublists(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = head\n    prefix_sum = 0\n    seen = {0: dummy}\n\n    while cur:\n        prefix_sum += cur.val\n        if prefix_sum in seen:\n            node = seen[prefix_sum].next\n            temp_sum = prefix_sum\n            while node != cur:\n                temp_sum += node.val\n                del seen[temp_sum]\n                node = node.next\n            seen[prefix_sum].next = cur.next\n        else:\n            seen[prefix_sum] = cur\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 2, -3, 3, 1])\nprint(removeZeroSumSublists(head))  # 3 -&gt; 1\n</code></pre>"},{"location":"leetpattern/queue/","title":"Queue","text":""},{"location":"leetpattern/queue/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: stack, design, queue</li> <li>Implement the following operations of a queue using stacks.<ul> <li><code>push(x)</code> - Push element x to the back of queue.</li> <li><code>pop()</code> - Removes the element from in front of queue.</li> <li><code>peek()</code> - Get the front element.</li> <li><code>empty()</code> - Return whether the queue is empty.</li> </ul> </li> </ul> <pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"leetpattern/queue/#225-implement-stack-using-queues","title":"225. Implement Stack using Queues","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: stack, design, queue</li> </ul> <pre><code>from collections import deque\n\n\n# Queue\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()  # main queue\n        self.q2 = deque()  # auxiliary queue\n\n    def push(self, x: int) -&gt; None:\n        self.q1.append(x)\n\n    def pop(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1[0]\n        self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -&gt; bool:\n        return not self.q1\n\n\nobj = MyStack()\nobj.push(1)\nobj.push(2)\nobj.push(3)\nobj.push(4)\nprint(obj.pop())  # 4\nprint(obj.top())  # 3\nprint(obj.empty())  # False\nprint(obj.pop())  # 3\n</code></pre>"},{"location":"leetpattern/queue_monotonic/","title":"Queue Monotonic","text":""},{"location":"leetpattern/queue_monotonic/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, dynamic programming, queue, monotonic queue</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"leetpattern/queue_monotonic/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre>"},{"location":"leetpattern/queue_monotonic/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, queue, sliding window, heap priority queue, monotonic queue</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"leetpattern/queue_monotonic/#2398-maximum-number-of-robots-within-budget","title":"2398. Maximum Number of Robots Within Budget","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maximumRobots(\n    chargeTimes: List[int], runningCosts: List[int], budget: int\n) -&gt; int:\n    ans = sum_cost = left = 0\n    q = deque()\n\n    for right, (time, cost) in enumerate(zip(chargeTimes, runningCosts)):\n        # 1. Add\n        while q and time &gt;= chargeTimes[q[-1]]:\n            q.pop()\n        q.append(right)\n        sum_cost += cost\n\n        # 2. Remove\n        while q and chargeTimes[q[0]] + (right - left + 1) * sum_cost &gt; budget:\n            if q[0] == left:\n                q.popleft()\n            sum_cost -= runningCosts[left]\n            left += 1\n\n        # 3. Update\n        ans = max(ans, right - left + 1)\n    return ans\n\n\nchargeTimes = [3, 6, 1, 3, 4]\nrunningCosts = [2, 1, 3, 4, 5]\nbudget = 25\nprint(maximumRobots(chargeTimes, runningCosts, budget))  # 3\n</code></pre>"},{"location":"leetpattern/simulation/","title":"Simulation","text":""},{"location":"leetpattern/simulation/#874-walking-robot-simulation","title":"874. Walking Robot Simulation","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, simulation</li> </ul> <pre><code>from typing import List\n\n\n# Simulation\ndef robotSim(commands: List[int], obstacles: List[List[int]]) -&gt; int:\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    obstacles_set = set(map(tuple, obstacles))\n\n    x, y, d = 0, 0, 0\n    res = 0\n\n    for command in commands:\n        if command == -2:  # Turn left\n            d = (d - 1) % 4\n        elif command == -1:  # Turn right\n            d = (d + 1) % 4\n        else:\n            dx, dy = dirs[d]\n            for _ in range(command):\n                if (x + dx, y + dy) not in obstacles_set:\n                    x += dx\n                    y += dy\n                    res = max(res, x**2 + y**2)\n                else:\n                    break\n\n    return res\n\n\ncommands = [4, -1, 4, -2, 4]\nobstacles = [[2, 4]]\nprint(robotSim(commands, obstacles))  # 65\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/","title":"Sliding Window Fixed","text":""},{"location":"leetpattern/sliding_window_fixed/#643-maximum-average-subarray-i","title":"643. Maximum Average Subarray I","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, sliding window</li> </ul> <pre><code>from typing import List\n\n\n# Sliding Window - Fixed\ndef findMaxAverage(nums: List[int], k: int) -&gt; float:\n    cur = sum(nums[:k])\n    result = cur\n\n    for i in range(k, len(nums)):\n        cur += nums[i] - nums[i - k]\n        result = max(result, cur)\n\n    return result / k\n\n\nnums = [1, 12, -5, -6, 50, 3]\nk = 4\nprint(findMaxAverage(nums, k))  # 12.75\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, sliding window</li> </ul> <pre><code>from typing import List\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicate(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicate(nums, k))  # True\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#1456-maximum-number-of-vowels-in-a-substring-of-given-length","title":"1456. Maximum Number of Vowels in a Substring of Given Length","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, sliding window</li> </ul> <pre><code>from typing import List\n\n\n# Sliding Window - Fixed\ndef maxVowels(s: str, k: int) -&gt; int:\n    vowel = set(\"aeiou\")\n    count = 0\n\n    for i in range(k):\n        if s[i] in vowel:\n            count += 1\n\n    max_count = count\n\n    for i in range(k, len(s)):\n        if s[i] in vowel:\n            count += 1\n        if s[i - k] in vowel:\n            count -= 1\n\n        max_count = max(max_count, count)\n\n        if max_count == k:\n            break\n\n    return max_count\n\n\ns = \"abciiidef\"\nk = 3\nprint(maxVowels(s, k))  # 3\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, two pointers, string, sliding window</li> </ul> <pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#713-subarray-product-less-than-k","title":"713. Subarray Product Less Than K","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, sliding window, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# Sliding window - Fixed\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -&gt; int:\n    if k &lt;= 1:\n        return 0\n\n    left = 0\n    product = 1\n    count = 0\n\n    for right in range(len(nums)):\n        product *= nums[right]\n\n        while product &gt;= k:\n            product //= nums[left]\n            left += 1\n\n        count += right - left + 1\n\n    return count\n\n\nnums = [10, 5, 2, 6]\nk = 100\nprint(numSubarrayProductLessThanK(nums, k))  # 8\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#1151-minimum-swaps-to-group-all-1s-together","title":"1151. Minimum Swaps to Group All 1's Together","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, sliding window</li> </ul> <pre><code>from typing import List\n\n\ndef minSwaps(data: List[int]) -&gt; int:\n    n = len(data)\n    total = sum(data)\n\n    if total == 0 or total == 1 or total == n:\n        return 0\n\n    max_count = 0\n    cur = 0\n    left = 0\n\n    for right in range(n):\n        cur += data[right]\n\n        if right - left + 1 &gt; total:\n            cur -= data[left]\n            left += 1\n\n        max_count = max(max_count, cur)\n\n    return total - max_count\n\n\ndata = [1, 0, 1, 0, 1]\nprint(minSwaps(data))  # 1\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, sliding window, prefix sum</li> </ul> <pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding window - Fixed\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    left, right = 0, 0\n    curSum = 0\n    minLen = float(\"inf\")\n\n    while right &lt; len(nums):\n        curSum += nums[right]\n\n        while curSum &gt;= target:\n            minLen = min(minLen, right - left + 1)\n            curSum -= nums[left]\n            left += 1\n\n        right += 1\n\n    return minLen if minLen != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/","title":"Sliding Window Variable","text":""},{"location":"leetpattern/sliding_window_variable/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(len(s)):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#1208-get-equal-substrings-within-budget","title":"1208. Get Equal Substrings Within Budget","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, binary search, sliding window, prefix sum</li> </ul> <pre><code># Sliding Window - Variable\ndef equalSubstring(s: str, t: str, maxCost: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    currentCost = 0\n\n    for right in range(len(s)):\n        currentCost += abs(ord(s[right]) - ord(t[right]))\n\n        while currentCost &gt; maxCost:\n            currentCost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcd\"\nt = \"bcdf\"\nmaxCost = 3\nprint(equalSubstring(s, t, maxCost))  # 3\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#1004-max-consecutive-ones-iii","title":"1004. Max Consecutive Ones III","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, sliding window, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef longestOnes(nums: List[int], k: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count &gt; k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\nnums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]\nk = 2\nprint(longestOnes(nums, k))  # 6\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#992-subarrays-with-k-different-integers","title":"992. Subarrays with K Different Integers","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, hash table, sliding window, counting</li> </ul> <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef subarraysWithKDistinct(nums: List[int], k: int) -&gt; int:\n    def atMost(k: int) -&gt; int:\n        count = 0\n        left = 0\n        freq = {}\n\n        for right in range(len(nums)):\n            if nums[right] not in freq:\n                freq[nums[right]] = 0\n            freq[nums[right]] += 1\n\n            while len(freq) &gt; k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n\n            count += right - left + 1\n\n        return count\n\n    return atMost(k) - atMost(k - 1)\n\n\nnums = [1, 2, 1, 2, 3]\nk = 2\nprint(subarraysWithKDistinct(nums, k))  # 7\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#2024-maximize-the-confusion-of-an-exam","title":"2024. Maximize the Confusion of an Exam","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, binary search, sliding window, prefix sum</li> </ul> <pre><code># Sliding Window - Variable\ndef maxConsecutiveAnswers1(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left = 0\n        count = 0  # num of str != char\n\n        for right in range(len(s)):\n            if s[right] != char:\n                count += 1\n\n            while count &gt; k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# Sliding Window - Variable\ndef maxConsecutiveAnswers2(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left, right = 0, 0\n\n        while right &lt; len(s):\n            if s[right] != char:\n                k -= 1\n\n            while k &lt; 0:\n                if s[left] != char:\n                    k += 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n            right += 1\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# |-----------------|---------|------------|\n# |  Approach       |  Time   |  Space     |\n# |-----------------|---------|------------|\n# | Sliding Window  |  O(N)   |  O(1)      |\n# |-----------------|---------|------------|\n\n\nanswerKey = \"TTFF\"\nk = 2\nprint(maxConsecutiveAnswers1(answerKey, k))  # 4\nprint(maxConsecutiveAnswers2(answerKey, k))  # 4\n</code></pre>"},{"location":"leetpattern/stack/","title":"Stack","text":""},{"location":"leetpattern/stack/#2390-removing-stars-from-a-string","title":"2390. Removing Stars From a String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, stack, simulation</li> <li> <p>Remove all <code>*</code> characters and their adjacent characters from the string.</p> </li> <li> <p>Steps for the string <code>leet**cod*e</code>:</p> </li> </ul> char action stack l push \"l\" e push \"le\" e push \"lee\" t push \"leet\" * pop \"lee\" * pop \"le\" c push \"lec\" o push \"leco\" d push \"lecod\" * pop \"leco\" e push \"lecoe\" <pre><code># Stack\ndef removeStars(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char == \"*\":\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"leet**cod*e\"\nprint(removeStars(s))  # \"lecoe\"\n</code></pre>"},{"location":"leetpattern/stack/#1544-make-the-string-great","title":"1544. Make The String Great","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, stack</li> <li>Remove all adjacent characters that are the same and have different cases.</li> <li>Steps for the string <code>leEeetcode</code>:</li> </ul> char action stack l push \"l\" e push \"le\" E pop \"l\" e push \"le\" e push \"lee\" t push \"leet\" c push \"leetc\" o push \"leetco\" d push \"leetcod\" e push \"leetcode\" <pre><code># Stack\ndef makeGood(s: str) -&gt; str:\n    stack = []\n\n    for i in range(len(s)):\n        if stack and stack[-1] == s[i].swapcase():\n            stack.pop()\n        else:\n            stack.append(s[i])\n    return \"\".join(stack)\n\n\nprint(makeGood(\"leEeetcode\"))  # \"leetcode\"\n</code></pre>"},{"location":"leetpattern/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, stack</li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" <pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"leetpattern/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: stack, design</li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> <pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"leetpattern/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, math, stack</li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> <pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"leetpattern/stack/#394-decode-string","title":"394. Decode String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, stack, recursion</li> </ul> <pre><code># Stack\ndef decodeString(s: str) -&gt; str:\n    stack = []  # (str, int)\n    num = 0\n    res = \"\"\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == \"[\":\n            stack.append((res, num))\n            res, num = \"\", 0\n        elif c == \"]\":\n            top = stack.pop()\n            res = top[0] + res * top[1]\n        else:\n            res += c\n\n    return res\n\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # accaccacc\n</code></pre>"},{"location":"leetpattern/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming, backtracking</li> </ul> <pre><code>from typing import List\n\n\n# Stack\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"leetpattern/stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, stack, sorting, monotonic stack</li> </ul> <pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"leetpattern/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: math, string, stack, recursion</li> </ul> <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"leetpattern/stack/#227-basic-calculator-ii","title":"227. Basic Calculator II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, string, stack</li> </ul> <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    num = 0\n    sign = \"+\"\n\n    for index, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n\n        if char in \"+-*/\" or index == len(s) - 1:\n            if sign == \"+\":\n                stack.append(num)\n            elif sign == \"-\":\n                stack.append(-num)\n            elif sign == \"*\":\n                stack.append(stack.pop() * num)\n            elif sign == \"/\":\n                stack.append(int(stack.pop() / num))\n            sign = char\n            num = 0\n\n    return sum(stack)\n\n\ns = \"3+2*2\"\nprint(calculate(s))  # 7\n</code></pre>"},{"location":"leetpattern/stack/#772-basic-calculator-iii","title":"772. Basic Calculator III","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: math, string, stack, recursion</li> </ul> <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre>"},{"location":"leetpattern/stack/#770-basic-calculator-iv","title":"770. Basic Calculator IV","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, math, string, stack, recursion</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Stack\nclass Solution:\n    def __init__(self):\n        self.operators = set([\"+\", \"-\", \"*\"])\n\n    def basicCalculatorIV(\n        self, expression: str, evalvars: List[str], evalints: List[int]\n    ) -&gt; List[str]:\n        evalmap = dict(zip(evalvars, evalints))\n        tokens = self.parse_expression(expression)\n        result_terms = self.evaluate(tokens, evalmap)\n        return self.format_result(result_terms)\n\n    def parse_expression(self, expression):\n        tokens = []\n        i = 0\n        while i &lt; len(expression):\n            if expression[i].isalnum():  # Variable or digit\n                start = i\n                while i &lt; len(expression) and (\n                    expression[i].isalnum() or expression[i] == \"_\"\n                ):\n                    i += 1\n                tokens.append(expression[start:i])\n            elif expression[i] in self.operators or expression[i] in \"()\":\n                tokens.append(expression[i])\n                i += 1\n            elif expression[i] == \" \":\n                i += 1  # skip whitespace\n        return tokens\n\n    def evaluate(self, tokens, evalmap):\n        def apply_operator(op, b, a):\n            if op == \"+\":\n                return self.add_terms(a, b)\n            elif op == \"-\":\n                return self.add_terms(a, self.negate_terms(b))\n            elif op == \"*\":\n                return self.multiply_terms(a, b)\n\n        def process_token(token):\n            if token.isalnum():\n                if token in evalmap:\n                    stack.append({(): evalmap[token]})\n                elif token.isdigit():\n                    stack.append({(): int(token)})\n                else:\n                    stack.append({(token,): 1})\n            elif token == \"(\":\n                ops.append(token)\n            elif token == \")\":\n                while ops and ops[-1] != \"(\":\n                    operate()\n                ops.pop()\n            else:\n                while (\n                    ops\n                    and ops[-1] in precedence\n                    and precedence[ops[-1]] &gt;= precedence[token]\n                ):\n                    operate()\n                ops.append(token)\n\n        def operate():\n            if len(stack) &lt; 2 or not ops:\n                return\n            b = stack.pop()\n            a = stack.pop()\n            op = ops.pop()\n            stack.append(apply_operator(op, b, a))\n\n        stack = []\n        ops = []\n        precedence = {\"+\": 1, \"-\": 1, \"*\": 2}\n\n        for token in tokens:\n            process_token(token)\n\n        while ops:\n            operate()\n        return self.combine_terms(stack[-1])\n\n    def add_terms(self, a, b):\n        result = defaultdict(int, a)\n        for term, coef in b.items():\n            result[term] += coef\n        return dict(result)\n\n    def negate_terms(self, a):\n        return {term: -coef for term, coef in a.items()}\n\n    def multiply_terms(self, a, b):\n        result = defaultdict(int)\n        for term1, coef1 in a.items():\n            for term2, coef2 in b.items():\n                new_term = tuple(sorted(term1 + term2))\n                result[new_term] += coef1 * coef2\n        return dict(result)\n\n    def combine_terms(self, terms):\n        result = defaultdict(int)\n        for term, coef in terms.items():\n            if coef != 0:\n                result[term] = coef\n        return dict(result)\n\n    def format_result(self, result_terms):\n        result = []\n        for term in sorted(result_terms.keys(), key=lambda x: (-len(x), x)):\n            coef = result_terms[term]\n            if coef != 0:\n                term_str = \"*\".join(term)\n                if term_str:\n                    result.append(f\"{coef}*{term_str}\")\n                else:\n                    result.append(str(coef))\n        return result\n\n\ncalculator = Solution()\nexpression = \"e + 8 - a + 5\"\nevalvars = [\"e\"]\nevalints = [1]\nprint(calculator.basicCalculatorIV(expression, evalvars, evalints))\n# ['-1*a', '14']\n</code></pre>"},{"location":"leetpattern/stack_monotonic/","title":"Stack Monotonic","text":""},{"location":"leetpattern/stack_monotonic/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, stack, monotonic stack</li> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> Index Temp &gt; stack last stack result 0 73 False <code>[ [73, 0] ]</code> 1 - 0 = 1 1 74 True <code>[ [74, 1] ]</code> 2 - 1 = 1 2 75 True <code>[ [75, 2] ]</code> 6 - 2 = 4 3 71 False <code>[ [75, 2], [71, 3] ]</code> 5 - 3 = 2 4 69 False <code>[ [75, 2], [71, 3], [69, 4] ]</code> 5 - 4 = 1 5 72 True <code>[ [75, 2], [72, 5] ]</code> 6 - 5 = 1 6 76 True <code>[ [76, 6] ]</code> 0 7 73 False <code>[[76, 6], [73, 7]]</code> 0 <pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []\n\n    for idx, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, last_index = stack.pop()\n            res[last_index] = idx - last_index\n\n        stack.append([temp, idx])\n\n    return res\n\n\ndef utils_plot(idx: int, temps: List[int], stack: List[List[int]]) -&gt; None:\n    \"\"\"Plot the current state of the stack and the temperatures.\"\"\"\n    plt.figure(figsize=(8, 3))\n    plt.plot(\n        range(len(temps)),\n        temps,\n        marker=\"o\",\n        linestyle=\"-\",\n        color=\"b\",\n        label=\"Temperatures\",\n    )\n\n    # Highlight the current temperature in red\n    plt.scatter(idx, temps[idx], color=\"r\", s=100, label=\"Current\")\n\n    # Display the current state of the stack\n    for temp, stack_idx in stack:\n        plt.scatter(stack_idx, temp, color=\"g\", s=70)\n        plt.text(\n            stack_idx,\n            temp,\n            f\"({temp}, {stack_idx})\",\n            fontsize=10,\n            ha=\"center\",\n            va=\"bottom\",\n            color=\"red\",\n        )\n\n    plt.title(f\"Day {idx}\")\n    plt.xlabel(\"Days\")\n    plt.ylabel(\"Temperature\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#496-next-greater-element-i","title":"496. Next Greater Element I","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, stack, monotonic stack</li> </ul> <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElement(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    next_greater = {}\n    stack = []\n    result = []\n\n    for num in nums2:\n        while stack and num &gt; stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    for num in nums1:\n        result.append(next_greater.get(num, -1))\n\n    return result\n\n\nnums1 = [4, 1, 2]\nnums2 = [1, 3, 4, 2]\nprint(nextGreaterElement(nums1, nums2))  # [3, -1, -1]\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#503-next-greater-element-ii","title":"503. Next Greater Element II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, stack, monotonic stack</li> </ul> <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElements(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] &lt; nums[i % n]:\n            result[stack.pop()] = nums[i % n]\n        if i &lt; n:\n            stack.append(i)\n\n    return result\n\n\nnums = [1, 2, 1]\nprint(nextGreaterElements(nums))  # [2, -1, 2]\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, stack, monotonic stack</li> </ul> <pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#85-maximal-rectangle","title":"85. Maximal Rectangle","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, dynamic programming, stack, matrix, monotonic stack</li> <li>Return the area of the largest rectangle that can be formed within a rectangle of 1's.</li> </ul> <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef maximalRectangle(matrix: List[List[str]]) -&gt; int:\n    if not matrix or not matrix[0]:\n        return 0\n\n    n = len(matrix[0])\n    heights = [0] * (n + 1)\n    max_area = 0\n\n    for row in matrix:\n        for i in range(n):\n            if row[i] == \"1\":\n                heights[i] += 1\n            else:\n                heights[i] = 0\n\n        stack = [-1]\n        for i in range(n + 1):\n            while heights[i] &lt; heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n\n    return max_area\n\n\nmatrix = [\n    [\"1\", \"0\", \"1\", \"0\", \"0\"],\n    [\"1\", \"0\", \"1\", \"1\", \"1\"],\n    [\"1\", \"1\", \"1\", \"1\", \"1\"],\n    [\"1\", \"0\", \"0\", \"1\", \"0\"],\n]\nprint(maximalRectangle(matrix))  # 6\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, two pointers, dynamic programming, stack, monotonic stack</li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) <pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#901-online-stock-span","title":"901. Online Stock Span","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: stack, design, monotonic stack, data stream</li> <li>Design a class <code>StockSpanner</code> to return the number of consecutive days (including the current day) the price of the stock has been less than or equal to the current price.</li> </ul> <pre><code>from typing import List\n\n\n# Monotonic Stack\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = [(-1, float(\"inf\"))]\n        self.cur_day = -1\n\n    def next(self, price: int) -&gt; int:\n        while price &gt;= self.stack[-1][1]:\n            self.stack.pop()\n        self.cur_day += 1\n        self.stack.append((self.cur_day, price))\n        return self.cur_day - self.stack[-2][0]\n\n\nobj = StockSpanner()\nprices = [100, 80, 60, 70, 60, 75, 85]\nprint([obj.next(price) for price in prices])  # [1, 1, 1, 2, 1, 4, 6]\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#316-remove-duplicate-letters","title":"316. Remove Duplicate Letters","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, stack, greedy, monotonic stack</li> </ul> <pre><code># Monotonic Stack\ndef removeDuplicateLetters(s: str) -&gt; str:\n    stack = []\n    seen = set()\n    last = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n        if c not in seen:\n            while stack and c &lt; stack[-1] and i &lt; last[stack[-1]]:\n                seen.discard(stack.pop())\n            seen.add(c)\n            stack.append(c)\n\n    return \"\".join(stack)\n\n\ns = \"cbacdcbc\"\nprint(removeDuplicateLetters(s))  # acdb\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, stack, monotonic stack, ordered set</li> </ul> <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, stack, monotonic stack, prefix sum</li> </ul> <pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (\n            r - i + 1\n        ) * (prefix_sum[i + 1] - prefix_sum[l])\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre>"},{"location":"leetpattern/string/","title":"String","text":""},{"location":"leetpattern/string/#344-reverse-string","title":"344. Reverse String","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string</li> </ul> <pre><code>from typing import List\n\n\ndef reverseString(s: List[str]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n\n\ns = [\"h\", \"e\", \"l\", \"l\", \"o\"]\nreverseString(s)\nprint(s)  # ['o', 'l', 'l', 'e', 'h']\n</code></pre>"},{"location":"leetpattern/string/#541-reverse-string-ii","title":"541. Reverse String II","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string</li> </ul> <pre><code>def reverseStr(s: str, k: int) -&gt; str:\n    def reverse_substring(text):\n        left, right = 0, len(text) - 1\n        while left &lt; right:\n            text[left], text[right] = text[right], text[left]\n            left += 1\n            right -= 1\n        return text\n\n    result = list(s)\n\n    for i in range(0, len(s), 2 * k):\n        result[i : i + k] = reverse_substring(result[i : i + k])\n\n    return \"\".join(result)\n\n\ns = \"abcdefg\"\nk = 2\nprint(reverseStr(s, k))  # \"bacdfeg\"\n</code></pre>"},{"location":"leetpattern/string/#151-reverse-words-in-a-string","title":"151. Reverse Words in a String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string</li> </ul> <pre><code>def reverseWords(s: str) -&gt; str:\n    words = s.split()\n\n    left, right = 0, len(words) - 1\n\n    while left &lt; right:\n        words[left], words[right] = words[right], words[left]\n        left += 1\n        right -= 1\n\n    return \" \".join(words)\n\n\ns = \"the sky is blue\"\nprint(reverseWords(s))  # \"blue is sky the\"\n</code></pre>"},{"location":"leetpattern/string/#58-length-of-last-word","title":"58. Length of Last Word","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string</li> </ul> <pre><code>def lengthOfLastWord(s: str) -&gt; int:\n    n = 0\n\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] != \" \":\n            n += 1\n        if s[i] == \" \" and n &gt; 0:\n            return n\n\n    return n\n\n\nprint(lengthOfLastWord(\"Hello World\"))  # 5\n</code></pre>"},{"location":"leetpattern/string/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string, stack, simulation</li> </ul> <pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre>"},{"location":"leetpattern/string/#2185-counting-words-with-a-given-prefix","title":"2185. Counting Words With a Given Prefix","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, string, string matching</li> </ul> <pre><code>from typing import List\n\n\n# 1\ndef prefixCount1(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        if word.startswith(pref):\n            count += 1\n\n    return count\n\n\n# 2\ndef prefixCount2(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        n = len(pref)\n\n        if len(word) &lt; n:\n            continue\n\n        if word[:n] == pref:\n            count += 1\n\n    return count\n\n\nwords = [\"pay\", \"attention\", \"practice\", \"attend\"]\npref = \"at\"\nprint(prefixCount1(words, pref))  # 2\nprint(prefixCount2(words, pref))  # 2\n</code></pre>"},{"location":"leetpattern/string/#2000-reverse-prefix-of-word","title":"2000. Reverse Prefix of Word","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string, stack</li> </ul> <pre><code>def reversePrefix(word: str, ch: str) -&gt; str:\n    if ch not in word:\n        return word\n\n    wordList = list(word)\n    left, right = 0, 0\n\n    for i in range(len(wordList)):\n        if wordList[i] == ch:\n            right = i\n            break\n\n    while left &lt; right:\n        wordList[left], wordList[right] = wordList[right], wordList[left]\n        left += 1\n        right -= 1\n\n    return \"\".join(wordList)\n\n\nword = \"abcdefd\"\nch = \"d\"\nprint(reversePrefix(word, ch))  # \"dcbaefd\"\n</code></pre>"},{"location":"leetpattern/tree_bfs/","title":"Tree BFS","text":""},{"location":"leetpattern/tree_bfs/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, breadth first search, binary tree <pre><code>    ____1       &lt;---\n   /     \\\n  2__     2     &lt;--- Look at the rightmost node at each level\n /   \\     \\\n3     4     3   &lt;---\n     /\n    5           &lt;---\n</code></pre></li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n\n        for i in range(n):\n            cur = q.popleft()\n\n            # rightmost element\n            if i == n - 1:\n                res.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"leetpattern/tree_bfs/#111-minimum-depth-of-binary-tree","title":"111. Minimum Depth of Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n\n        for _ in range(len(q)):\n            node = q.popleft()\n\n            if not node.left and not node.right:\n                return res\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre>"},{"location":"leetpattern/tree_bfs/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return depth\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    return 1 + max(maxDepthRecursive(root.left), maxDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthRecursive(root))  # 4\n</code></pre>"},{"location":"leetpattern/tree_bfs/#637-average-of-levels-in-binary-tree","title":"637. Average of Levels in Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom statistics import mean\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n        result.append(mean(level))\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(averageOfLevels(root))  # [1, 2, 3.5, 5]\n</code></pre>"},{"location":"leetpattern/tree_bfs/#429-n-ary-tree-level-order-traversal","title":"429. N-ary Tree Level Order Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, breadth first search</li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\n\ndef levelOrder(root: Optional[Node]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            for child in node.children:\n                queue.append(child)\n\n        result.append(level)\n\n    return result\n\n\nroot = Node(\n    1,\n    [\n        Node(\n            3,\n            [\n                Node(5, []),\n                Node(6, []),\n            ],\n        ),\n        Node(2, []),\n        Node(4, []),\n    ],\n)\nprint(levelOrder(root))  # [[1], [3, 2, 4], [5, 6]]\n</code></pre>"},{"location":"leetpattern/tree_bfs/#515-find-largest-value-in-each-tree-row","title":"515. Find Largest Value in Each Tree Row","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef largestValues(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        levelMax = float(\"-inf\")\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            levelMax = max(levelMax, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(levelMax)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(largestValues(root))  # [1, 2, 4, 5]\n</code></pre>"},{"location":"leetpattern/tree_bfs/#116-populating-next-right-pointers-in-each-node","title":"116. Populating Next Right Pointers in Each Node","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, tree, depth first search, breadth first search, binary tree</li> <li>Perfect Binary Tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return root\n\n\n# Perfect binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n#     __1__\n#    /     \\\n#   2__     3\n#  /   \\   / \\\n# 4     5 6   7\n\n\n# Connect the nodes\nconnect(root)\n#      __1__ -&gt; None\n#     /     \\\n#   _2_ -&gt;  3 -&gt; None\n#  /   \\   / \\\n# 4 -&gt; 5-&gt;6-&gt; 7 -&gt; None\n\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.left\nassert root.right.left.next == root.right.right\nassert root.right.right.next is None\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"leetpattern/tree_bfs/#117-populating-next-right-pointers-in-each-node-ii","title":"117. Populating Next Right Pointers in Each Node II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Node\") -&gt; \"Node\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n    return root\n\n\n# Binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(7)\n#       1\n#      / \\\n#     2   3\n#    / \\   \\\n#   4   5   7\n\n# Connect the nodes\nconnect(root)\n#       1 -&gt; None\n#      / \\\n#     2 -&gt; 3 -&gt; None\n#    / \\    \\\n#   4 -&gt; 5 -&gt; 7 -&gt; None\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.right.next is None\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.right\nassert root.right.right.next is None\n\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"leetpattern/tree_bfs/#513-find-bottom-left-tree-value","title":"513. Find Bottom Left Tree Value","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findBottomLeftValue(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    result = 0\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\n\nprint(findBottomLeftValue(root))  # 5\n</code></pre>"},{"location":"leetpattern/tree_bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre>"},{"location":"leetpattern/tree_feature/","title":"Tree Feature","text":""},{"location":"leetpattern/tree_feature/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef isSymmetricRecursive(root: Optional[TreeNode]) -&gt; bool:\n    \"\"\"Determine if a tree is symmetric.\"\"\"\n    if not root:\n        return True\n\n    def compare(left, right):\n        if left is None and right is not None:\n            return False\n        elif left is not None and right is None:\n            return False\n        elif left is None and right is None:\n            return True\n        elif left.val != right.val:\n            return False\n\n        outside = compare(left.left, right.right)\n        inside = compare(left.right, right.left)\n\n        return outside and inside\n\n    return compare(root.left, root.right)\n\n\n# Iterative\ndef isSymmetricIterative(root: Optional[TreeNode]) -&gt; bool:\n    \"\"\"Determine if a tree is symmetric.\"\"\"\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        leftNode = q.popleft()\n        rightNode = q.popleft()\n\n        if not leftNode and not rightNode:\n            continue\n\n        if not leftNode or not rightNode or leftNode.val != rightNode.val:\n            return False\n\n        q.append(leftNode.left)\n        q.append(rightNode.right)\n        q.append(leftNode.right)\n        q.append(rightNode.left)\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |   O(n)  |\n# | Iterative  |  O(n)  |   O(n)  |\n# |------------|--------|---------|\n\n\nroot = [1, 2, 2, 3, 4, 4, 3]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       2\n#  / \\     / \\\n# 3   4   4   3\nprint(isSymmetricRecursive(root))  # True\nprint(isSymmetricIterative(root))  # True\n</code></pre>"},{"location":"leetpattern/tree_feature/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: binary search, bit manipulation, tree, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre>"},{"location":"leetpattern/tree_feature/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"leetpattern/tree_feature/#257-binary-tree-paths","title":"257. Binary Tree Paths","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, backtracking, tree, depth first search, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef binaryTreePaths(root: Optional[TreeNode]) -&gt; List[str]:\n    if not root:\n        return []\n\n    path = []\n    paths = []\n\n    def dfs(node, path):\n        if not node:\n            return None\n\n        path.append(str(node.val))\n\n        if not node.left and not node.right:\n            paths.append(\"-&gt;\".join(path))\n\n        dfs(node.left, path[:])\n        dfs(node.right, path[:])\n\n    dfs(root, path)\n\n    return paths\n\n\nroot = build([1, 2, 3, None, 5])\nprint(root)\n#   __1\n#  /   \\\n# 2     3\n#  \\\n#   5\nprint(binaryTreePaths(root))  # ['1-&gt;2-&gt;5', '1-&gt;3']\n</code></pre>"},{"location":"leetpattern/tree_feature/#404-sum-of-left-leaves","title":"404. Sum of Left Leaves","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef sumOfLeftLeaves(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    stack = [root]\n    sumLL = 0\n\n    while stack:\n        node = stack.pop()\n\n        if node.left and not node.left.left and not node.left.right:\n            sumLL += node.left.val\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return sumLL\n\n\n# Left Leave None:\n#   - node.left is not None\n#   - node.left.left is None\n#   - node.left.right is None\n\nroot = build([3, 9, 20, None, None, 15, 7])\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(sumOfLeftLeaves(root))  # 24\n</code></pre>"},{"location":"leetpattern/tree_feature/#112-path-sum","title":"112. Path Sum","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(\n        root.right, targetSum\n    )\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre>"},{"location":"leetpattern/tree_feature/#2331-evaluate-boolean-binary-tree","title":"2331. Evaluate Boolean Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef evaluateTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root.left and not root.right:\n        return root.val\n\n    left = evaluateTree(root.left)\n    right = evaluateTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    elif root.val == 3:\n        return left and right\n\n\nroot = build([2, 1, 3, None, None, 0, 1])\nprint(root)\n#   2__\n#  /   \\\n# 1     3\n#      / \\\n#     0   1\nboolTree = build([\"OR\", \"True\", \"AND\", None, None, \"False\", \"True\"])\nprint(boolTree)\n#    __OR_______\n#   /           \\\n# True        __AND_\n#            /      \\\n#         False     True\nprint(evaluateTree(root))  # 1\n</code></pre>"},{"location":"leetpattern/tree_feature/#100-same-tree","title":"100. Same Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"leetpattern/tree_feature/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"leetpattern/tree_feature/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre>"},{"location":"leetpattern/tree_modification/","title":"Tree Modification","text":""},{"location":"leetpattern/tree_modification/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"leetpattern/tree_modification/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, tree, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"leetpattern/tree_modification/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, tree, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"leetpattern/tree_modification/#654-maximum-binary-tree","title":"654. Maximum Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, stack, tree, monotonic stack, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef constructMaximumBinaryTree(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    maximum = max(nums)\n    rootIndex = nums.index(maximum)\n\n    root = TreeNode(maximum)\n\n    left_nums = nums[:rootIndex]\n    right_nums = nums[rootIndex + 1 :]\n\n    root.left = constructMaximumBinaryTree(left_nums)\n    root.right = constructMaximumBinaryTree(right_nums)\n\n    return root\n\n\nnums = [3, 2, 1, 6, 0, 5]\nroot = constructMaximumBinaryTree(nums)\n#     __6__\n#    /     \\\n#   3       5\n#    \\     /\n#     2   0\n#      \\\n#       1\n</code></pre>"},{"location":"leetpattern/tree_modification/#617-merge-two-binary-trees","title":"617. Merge Two Binary Trees","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef mergeTrees(\n    root1: Optional[TreeNode], root2: Optional[TreeNode]\n) -&gt; Optional[TreeNode]:\n\n    if not root1:\n        return root2\n    if not root2:\n        return root1\n\n    root = TreeNode()\n\n    root.val += root1.val + root2.val\n    root.left = mergeTrees(root1.left, root2.left)\n    root.right = mergeTrees(root1.right, root2.right)\n\n    return root\n\n\nroot1 = TreeNode(1)\nroot1.left = TreeNode(3)\nroot1.right = TreeNode(2)\nroot1.left.left = TreeNode(5)\n#     1\n#    / \\\n#   3   2\n#  /\n# 5\n\nroot2 = TreeNode(2)\nroot2.left = TreeNode(1)\nroot2.right = TreeNode(3)\nroot2.left.right = TreeNode(4)\nroot2.right.right = TreeNode(7)\n#     2\n#    / \\\n#   1   3\n#    \\   \\\n#     4   7\n\nroot = mergeTrees(root1, root2)\n#     3\n#    / \\\n#   4   5\n#  / \\   \\\n# 5   4   7\n</code></pre>"},{"location":"leetpattern/tree_traversal/","title":"Tree Traversal","text":""},{"location":"leetpattern/tree_traversal/#144-binary-tree-preorder-traversal","title":"144. Binary Tree Preorder Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: stack, tree, depth first search, binary tree </li> </ul>"},{"location":"leetpattern/tree_traversal/#example-1","title":"Example 1","text":"<pre><code>graph TD\nA(( ))\nB(( ))\nC(( ))\nD(( ))\nE(( ))\nF(( ))\nG(( ))\nA --- B\nA --- E\nB --- C\nB --- D\nE --- F\nE --- G</code></pre> <p>Pre-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 4\n1 --- 2\n1 --- 3\n4 --- 5\n4 --- 6</code></pre> <p>In-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n3 --- 1\n3 --- 5\n1 --- 0\n1 --- 2\n5 --- 4\n5 --- 6</code></pre> <p>Post-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n6 --- 2\n6 --- 5\n2 --- 0\n2 --- 1\n5 --- 3\n5 --- 4</code></pre> <p>Level Order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((1))\n3((2))\n4((2))\n5((2))\n6((2))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre>"},{"location":"leetpattern/tree_traversal/#example-2","title":"Example 2","text":"<pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre> Traversal Order Method Result Preorder Root, Left, Right DFS or Stack <code>[0, 1, 3, 4, 2, 5, 6]</code> Inorder Left, Root, Right DFS or Stack <code>[3, 1, 4, 0, 5, 2, 6]</code> Postorder Left, Right, Root DFS or Stack <code>[3, 4, 1, 5, 6, 2, 0]</code> Level Order Level by Level BFS with Queue <code>[[0], [1, 2], [3, 4, 5, 6]]</code> <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef preorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        res.append(node.val)  # &lt;--\n        dfs(node.left)\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef preorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = [root]\n    res = []\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(preorderTraversalRecursive(tree))  # [0, 1, 3, 4, 2, 5, 6]\nprint(preorderTraversalIterative(tree))  # [0, 1, 3, 4, 2, 5, 6]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#94-binary-tree-inorder-traversal","title":"94. Binary Tree Inorder Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: stack, tree, depth first search, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        res.append(node.val)  # &lt;--\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    res = []\n    cur = root\n\n    while cur or stack:\n        if cur:\n            stack.append(cur)\n            cur = cur.left\n        else:\n            cur = stack.pop()\n            res.append(cur.val)\n            cur = cur.right\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#145-binary-tree-postorder-traversal","title":"145. Binary Tree Postorder Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: stack, tree, depth first search, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef postorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        dfs(node.right)\n        res.append(node.val)  # &lt;--\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef postorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    res = []\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return res[::-1]\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(postorderTraversalRecursive(tree))  # [3, 4, 1, 5, 6, 2, 0]\nprint(postorderTraversalIterative(tree))  # [3, 4, 1, 5, 6, 2, 0]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#107-binary-tree-level-order-traversal-ii","title":"107. Binary Tree Level Order Traversal II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrderBottom(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    res = []\n    q = deque([root])\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res[::-1]\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrderBottom(tree))  # [[15, 7], [9, 20], [3]]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#103-binary-tree-zigzag-level-order-traversal","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level if len(res) % 2 == 0 else level[::-1])\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(zigzagLevelOrder(tree))  # [[3], [20, 9], [15, 7]]\n</code></pre>"},{"location":"leetpattern/trie/","title":"Trie","text":""},{"location":"leetpattern/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, design, trie</li> </ul>"},{"location":"leetpattern/trie/#trie_1","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"leetpattern/trie/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, depth first search, design, trie</li> </ul> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"leetpattern/trie/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, backtracking, trie, matrix</li> </ul> <pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"neetcode150/","title":"Neetcode 150","text":""},{"location":"neetcode150/1d_dynamic_programming/","title":"1D Dynamic Programming","text":""},{"location":"neetcode150/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, dynamic programming, memoization</li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 <pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li> <p>Return the minimum cost to reach the top of the stairs.</p> </li> <li> <p><code>dp[n]</code> stores the minimum cost to reach the <code>n-th</code> stair.</p> </li> <li>Formula: <code>dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])</code>.</li> <li>Initialize <code>dp[0] = cost[0]</code> and <code>dp[1] = cost[1]</code>.</li> <li> <p>Return <code>min(dp[-1], dp[-2])</code>.</p> </li> <li> <p>Example: <code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code></p> </li> </ul> n <code>cost[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 1 - - 1 1 100 - 1 100 2 1 1 100 2 3 1 100 2 3 4 1 2 3 3 5 100 3 3 103 6 1 3 103 4 7 1 103 4 5 8 100 4 5 104 9 1 5 104 6 <pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 <pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 12\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 <pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string, dynamic programming</li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> <pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string, dynamic programming</li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 <pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, breadth first search</li> </ul> <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, dynamic programming, trie, memoization</li> </ul> <pre><code>from typing import List\n\n\n# DP - Knapsack Unbounded\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - LIS\ndef lengthOfLIS(nums: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(n)\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # 4\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\nfrom template import knapsack01\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nnums = [1, 5, 11, 5]\nprint(canPartitionTemplate(nums))  # True\nprint(canPartition(nums))  # True\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/","title":"2D Dynamic_Programming","text":""},{"location":"neetcode150/2d_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, dynamic programming, combinatorics</li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n            if res &lt; dp[i][j]:\n                res = dp[i][j]\n\n    return res\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#494-target-sum","title":"494. Target Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#97-interleaving-string","title":"97. Interleaving String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code># DP - 2D\ndef isInterleaveDP(s1: str, s2: str, s3: str) -&gt; bool:\n    m, n, k = len(s1), len(s2), len(s3)\n\n    if m + n != k:\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (\n                dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n            )\n\n    return dp[m][n]\n\n\n# DFS\ndef isInterleaveDFS(s1: str, s2: str, s3: str) -&gt; bool:\n    memo = {}\n\n    def dfs(i, j, k):\n        if i == len(s1) and j == len(s2) and k == len(s3):\n            return True\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        res = False\n\n        if i &lt; len(s1) and k &lt; len(s3) and s1[i] == s3[k]:\n            res |= dfs(i + 1, j, k + 1)\n\n        if j &lt; len(s2) and k &lt; len(s3) and s2[j] == s3[k]:\n            res |= dfs(i, j + 1, k + 1)\n\n        memo[(i, j)] = res\n\n        return res\n\n    return dfs(0, 0, 0)\n\n\ns1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbbaccc\"\nprint(isInterleaveDP(s1, s2, s3))  # False\nprint(isInterleaveDFS(s1, s2, s3))  # False\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, dynamic programming, depth first search, breadth first search, graph, topological sort, memoization, matrix</li> </ul> <pre><code>from typing import List\n\n\n# DP - 2D\ndef longestIncreasingPath(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c):\n        if dp[r][c]:\n            return dp[r][c]\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                dp[r][c] = max(dp[r][c], dfs(nr, nc))\n        dp[r][c] += 1\n        return dp[r][c]\n\n    res = float(\"-inf\")\n    for i in range(m):\n        for j in range(n):\n            res = max(res, dfs(i, j))\n\n    return res\n\n\nmatrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\nprint(longestIncreasingPath(matrix))  # 4\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming</li> </ul> <pre><code>def minDistance(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nword1 = \"horse\"\nword2 = \"ros\"\nprint(minDistance(word1, word2))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#312-burst-balloons","title":"312. Burst Balloons","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, dynamic programming</li> </ul>"},{"location":"neetcode150/2d_dynamic_programming/#10-regular-expression-matching","title":"10. Regular Expression Matching","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: string, dynamic programming, recursion</li> </ul>"},{"location":"neetcode150/advanced_graphs/","title":"Advanced Graphs","text":""},{"location":"neetcode150/advanced_graphs/#332-reconstruct-itinerary","title":"332. Reconstruct Itinerary","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: depth first search, graph, eulerian circuit</li> <li>Return the itinerary in order that visits every airport exactly once.</li> <li>The starting airport is <code>JFK</code>.</li> <li>If there are multiple valid itineraries, return the lexicographically smallest one.</li> <li>Eulerian path: A path that visits every edge exactly once.</li> </ul> <pre><code>graph TD\nJFK((JFK))\nSFO((SFO))\nATL((ATL))\nJFK --&gt; SFO\nSFO --&gt; ATL\nATL --&gt; JFK\nJFK --&gt; ATL\nATL --&gt; SFO</code></pre> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hierholzer\ndef findItinerary1(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    for u, v in sorted(tickets, reverse=True):\n        graph[u].append(v)\n\n    route = []\n\n    def dfs(node):\n        while graph[node]:\n            dest = graph[node].pop()\n            dfs(dest)\n        route.append(node)\n\n    dfs(\"JFK\")\n\n    return route[::-1]\n\n\n# Backtracking\ndef findItinerary2(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    tickets.sort()\n    for u, v in tickets:\n        graph[u].append(v)\n\n    route = [\"JFK\"]\n\n    def backtraking(node):\n        if len(route) == len(tickets) + 1:\n            return True\n        if node not in graph:\n            return False\n\n        temp = list(graph[node])\n        for i, v in enumerate(temp):\n            graph[node].pop(i)\n            route.append(v)\n\n            if backtraking(v):\n                return True\n\n            graph[node].insert(i, v)\n            route.pop()\n\n        return False\n\n    backtraking(\"JFK\")\n\n    return route\n\n\ntickets = tickets = [\n    [\"JFK\", \"SFO\"],\n    [\"JFK\", \"ATL\"],\n    [\"SFO\", \"ATL\"],\n    [\"ATL\", \"JFK\"],\n    [\"ATL\", \"SFO\"],\n]\nprint(findItinerary1(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nprint(findItinerary2(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, union find, graph, minimum spanning tree</li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm<ul> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Kruskal's Algorithm</p> <ul> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Demonstration</p> </li> </ul> <p>Example graph</p> <p></p> <p>MST</p> <p></p> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</li> <li>Return the minimum time when you can reach the target.</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, depth first search, breadth first search, graph, topological sort</li> <li>Return the correct order of characters in the alien language.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"neetcode150/arrays_hashing/","title":"Arrays Hashing","text":""},{"location":"neetcode150/arrays_hashing/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, sorting</li> <li>Return True if the array contains any duplicates, otherwise return False.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, string, sorting</li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> <pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table</li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) <pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, sorting</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect</li> </ul> <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, design</li> </ul> <pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# 2. Prefix - Optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |    Prefix   |    O(n)     |    O(n)      |\n# |Prefix - Opt |    O(n)     |    O(1)      |\n# |-------------|-------------|--------------|\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, matrix</li> </ul> <pre><code>from typing import List\n\n\n# Set\ndef isValidSudoku(board: List[List[str]]) -&gt; bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == \".\":\n                continue\n\n            if board[i][j] in rows[i]:\n                return False\n            rows[i].add(board[i][j])\n\n            if board[i][j] in cols[j]:\n                return False\n            cols[j].add(board[i][j])\n\n            box_index = (i // 3) * 3 + j // 3\n            if board[i][j] in boxes[box_index]:\n                return False\n            boxes[box_index].add(board[i][j])\n\n    return True\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\nprint(isValidSudoku(board))  # True\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, union find</li> </ul> <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"neetcode150/backtracking/","title":"Backtracking","text":""},{"location":"neetcode150/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking, bit manipulation</li> </ul> <pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"neetcode150/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"neetcode150/backtracking/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"neetcode150/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"neetcode150/backtracking/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, backtracking, bit manipulation</li> </ul> <pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"neetcode150/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, backtracking, depth first search, matrix</li> </ul> <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"neetcode150/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef partition(s: str) -&gt; List[List[str]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if startIndex == len(s):\n            result.append(path[:])\n            return None\n\n        for i in range(startIndex, len(s)):\n            if is_palindrome(s, startIndex, i):\n                path.append(s[startIndex : i + 1])\n                backtracking(i + 1)\n                path.pop()\n\n    def is_palindrome(s: str, start, end) -&gt; bool:\n        while start &lt; end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n\n        return True\n\n    backtracking(0)\n\n    return result\n\n\nprint(partition(\"aab\"))  # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"neetcode150/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, backtracking</li> </ul> <pre><code>from typing import List\n\n\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letterMap = [\n        \"\",  # 0\n        \"\",  # 1\n        \"abc\",  # 2\n        \"def\",  # 3\n        \"ghi\",  # 4\n        \"jkl\",  # 5\n        \"mno\",  # 6\n        \"pqrs\",  # 7\n        \"tuv\",  # 8\n        \"wxyz\",  # 9\n    ]\n    res = []\n\n    def backtracking(index, s):\n        if index == len(digits):\n            res.append(s)\n            return None\n\n        digit = int(digits[index])\n        letters = letterMap[digit]\n\n        for i in range(len(letters)):\n            backtracking(index + 1, s + letters[i])\n\n    if len(digits) == 0:\n        return res\n\n    backtracking(0, \"\")\n\n    return res\n\n\nprint(letterCombinations(\"23\"))\n# ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n</code></pre>"},{"location":"neetcode150/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, backtracking</li> <li>Hard</li> <li>N-Queens</li> <li>N \u7687\u540e</li> </ul> <pre><code>from typing import List\n\n\n# Backtracking - Board\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    result = []\n    chessboard = [\".\" * n for _ in range(n)]\n\n    def backtracking(row):\n        if row == n:\n            result.append(chessboard[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, chessboard):\n                chessboard[row] = (\n                    chessboard[row][:col] + \"Q\" + chessboard[row][col + 1 :]\n                )\n                backtracking(row + 1)\n                chessboard[row] = (\n                    chessboard[row][:col] + \".\" + chessboard[row][col + 1 :]\n                )\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    backtracking(0)\n\n    return [[\"\".join(row) for row in solution] for solution in result]\n\n\nprint(solveNQueens(4))\n# [['.Q..', '...Q', 'Q...', '..Q.'],\n#  ['..Q.', 'Q...', '...Q', '.Q..']]\n</code></pre>"},{"location":"neetcode150/binary_search/","title":"Binary Search","text":""},{"location":"neetcode150/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, binary search</li> <li>Implement binary search algorithm.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &gt; target:\n            right = mid - 1\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            return mid\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"neetcode150/binary_search/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search, matrix</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        mid_value = matrix[mid // n][mid % n]\n\n        if mid_value == target:\n            return True\n        elif mid_value &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nmatrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\ntarget = 3\nprint(searchMatrix(matrix, target))  # True\n</code></pre>"},{"location":"neetcode150/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"neetcode150/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> </ul>"},{"location":"neetcode150/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> </ul>"},{"location":"neetcode150/binary_search/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, binary search, design</li> </ul>"},{"location":"neetcode150/binary_search/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, divide and conquer</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"neetcode150/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"neetcode150/bit_manipulation/#136-single-number","title":"136. Single Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, bit manipulation</li> </ul>"},{"location":"neetcode150/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: divide and conquer, bit manipulation</li> </ul> <pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: dynamic programming, bit manipulation</li> </ul> <pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: divide and conquer, bit manipulation</li> </ul> <pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#268-missing-number","title":"268. Missing Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, math, binary search, bit manipulation, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, bit manipulation</li> </ul> <pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#7-reverse-integer","title":"7. Reverse Integer","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math</li> </ul> <pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre>"},{"location":"neetcode150/graphs/","title":"Graphs","text":""},{"location":"neetcode150/graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"neetcode150/graphs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return 0\n\n        grid[r][c] = 2\n\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    area = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"neetcode150/graphs/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, depth first search, breadth first search, graph</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre>"},{"location":"neetcode150/graphs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, breadth first search, matrix </li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            r in range(m)\n            and c in range(n)\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nrooms = [\n    [2147483647, -1, 0, 2147483647],\n    [2147483647, 2147483647, 2147483647, -1],\n    [2147483647, -1, 2147483647, -1],\n    [0, -1, 2147483647, 2147483647],\n]\nwallsAndGates(rooms)\nprint(rooms)\n# [[3, -1, 0,  1],\n#  [2,  2, 1, -1],\n#  [1, -1, 2, -1],\n#  [0, -1, 3,  4]]\n</code></pre>"},{"location":"neetcode150/graphs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, breadth first search, matrix</li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    # 1. Init\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    # 2. Make a queue of rotten oranges and count fresh oranges\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    # 3. BFS\n    while q and fresh &gt; 0:\n        size = len(q)\n\n        for _ in range(size):\n            r, c = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if nr &lt; 0 or nc &lt; 0 or nr &gt;= m or nc &gt;= n or grid[nr][nc] != 1:\n                    continue\n                grid[nr][nc] = 2\n                q.append([nr, nc])\n                fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"neetcode150/graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, matrix</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"neetcode150/graphs/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> </ul> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom typing import List\n\n\n# 1. DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r not in range(m) or c not in range(n) or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# 2. BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and board[nr][nc] == \"O\":\n                    q.append((nr, nc))\n                    board[nr][nc] = \"T\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nboard = [\n    [\"X\", \"X\", \"X\", \"X\"],\n    [\"X\", \"O\", \"O\", \"X\"],\n    [\"X\", \"X\", \"O\", \"X\"],\n    [\"X\", \"O\", \"X\", \"X\"],\n]\nboard1 = deepcopy(board)\nsolveDFS(board1)\npprint(board1)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n\nboard2 = deepcopy(board)\nsolveBFS(board2)\npprint(board2)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n</code></pre>"},{"location":"neetcode150/graphs/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"neetcode150/graphs/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"neetcode150/graphs/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"neetcode150/graphs/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"neetcode150/graphs/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, union find, graph</li> </ul> <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"neetcode150/graphs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, breadth first search</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # Edge case\n    if endWord not in wordList:\n        return 0\n\n    # Init\n    graph = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    # BFS\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\n# |------------|---------|---------|\n# |  Approach  |  Time   |  Space  |\n# |------------|---------|---------|\n# |    BFS     | O(n*m^2)| O(n*m)  |\n# |------------|---------|---------|\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"neetcode150/greedy/","title":"Greedy","text":""},{"location":"neetcode150/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, dynamic programming</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"neetcode150/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True <pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    maxReach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= maxReach:\n        maxReach = max(maxReach, i + nums[i])\n        if maxReach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"neetcode150/greedy/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if len(nums) == 1:\n        return 0\n\n    maxReach = 0\n    step = 0\n    left, right = 0, 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            maxReach = max(maxReach, i + nums[i])\n        left = right + 1\n        right = maxReach\n        step += 1\n\n    return step\n\n\nprint(jump([2, 3, 1, 1, 4, 2, 1]))  # 3\n</code></pre>"},{"location":"neetcode150/greedy/#134-gas-station","title":"134. Gas Station","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, greedy</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre>"},{"location":"neetcode150/greedy/#846-hand-of-straights","title":"846. Hand of Straights","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, greedy, sorting</li> </ul> <pre><code>from collections import Counter\nfrom typing import List\n\n\n# Greedy\ndef isNStraightHand(hand: List[int], groupSize: int) -&gt; bool:\n    if len(hand) % groupSize != 0:\n        return False\n\n    count = Counter(hand)\n\n    while count:\n        minVal = min(count)\n        for i in range(minVal, minVal + groupSize):\n            if count[i] == 0:\n                return False\n            count[i] -= 1\n            if count[i] == 0:\n                del count[i]\n    return True\n\n\nhand = [1, 2, 3, 6, 2, 3, 4, 7, 8]\ngroupSize = 3\nprint(isNStraightHand(hand, groupSize))  # True\n</code></pre>"},{"location":"neetcode150/greedy/#1899-merge-triplets-to-form-target-triplet","title":"1899. Merge Triplets to Form Target Triplet","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, greedy</li> </ul> <pre><code>from typing import List\n\n\ndef mergeTriplets(triplets: List[List[int]], target: List[int]) -&gt; bool:\n    can_form = [False, False, False]\n\n    for triplet in triplets:\n        if all(triplet[i] &lt;= target[i] for i in range(3)):\n            for i in range(3):\n                if triplet[i] == target[i]:\n                    can_form[i] = True\n\n    return all(can_form)\n\n\ntriplets = [[2, 5, 3], [1, 8, 4], [1, 7, 5]]\ntarget = [2, 7, 5]\nprint(mergeTriplets(triplets, target))  # True\n</code></pre>"},{"location":"neetcode150/greedy/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, two pointers, string, greedy</li> </ul> <pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    # Time complexity: O(nlogn)\n    # Space complexity: O(n)\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    result = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            result.append(intervals[i][0])\n\n    result.append(intervals[-1][1] + 1)\n\n    if len(result) == 1:\n        return result\n    else:\n        for i in range(len(result) - 1, 0, -1):\n            result[i] -= result[i - 1]\n        return result\n\n\n# 2. Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    last = {c: i for i, c in enumerate(s)}\n\n    start, end = 0, 0\n    result = []\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if i == end:\n            result.append(end - start + 1)\n            start = i + 1\n\n    return result\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"neetcode150/greedy/#678-valid-parenthesis-string","title":"678. Valid Parenthesis String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming, stack, greedy</li> </ul> <pre><code># Greedy\ndef checkValidString(s: str) -&gt; bool:\n    min_open, max_open = 0, 0\n\n    for char in s:\n        if char == \"(\":\n            min_open += 1\n            max_open += 1\n        elif char == \")\":\n            min_open = max(min_open - 1, 0)\n            max_open -= 1\n        elif char == \"*\":\n            min_open = max(min_open - 1, 0)\n            max_open += 1\n\n        if max_open &lt; 0:\n            return False\n\n    return min_open == 0\n\n\ns = \"(*))\"\nprint(checkValidString(s))  # True\n</code></pre>"},{"location":"neetcode150/heap/","title":"Heap","text":""},{"location":"neetcode150/heap/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, design, binary search tree, heap priority queue, binary tree, data stream</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"neetcode150/heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, heap priority queue</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"neetcode150/heap/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, math, divide and conquer, geometry, sorting, heap priority queue, quickselect</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"neetcode150/heap/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, sorting, heap priority queue, quickselect</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    heap = nums[:k]\n    heapq.heapify(heap)  # min heap\n\n    for num in nums[k:]:\n        if num &gt; heap[0]:\n            heapq.heappop(heap)  # pop the smallest element\n            heapq.heappush(heap, num)  # push the new element\n\n    return heap[0]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\nnums = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(findKthLargest(nums, k))  # 5\n</code></pre>"},{"location":"neetcode150/heap/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, greedy, sorting, heap priority queue, counting</li> </ul> <pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"neetcode150/heap/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list, design, heap priority queue</li> <li>Similar question: 23. Merge K Sorted Lists (Hard)</li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"neetcode150/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: two pointers, design, sorting, heap priority queue, data stream</li> </ul> <pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"neetcode150/intervals/","title":"Intervals","text":""},{"location":"neetcode150/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array</li> </ul> <pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"neetcode150/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, sorting</li> <li>Merge all overlapping intervals.</li> </ul> <pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"neetcode150/intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy, sorting</li> </ul> <pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"neetcode150/intervals/#252-meeting-rooms","title":"252. Meeting Rooms","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(canAttendMeetings(intervals))  # False\n</code></pre>"},{"location":"neetcode150/intervals/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    heap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= heap[0]:\n            heapq.heappop(heap)\n        heapq.heappush(heap, intervals[i][1])\n\n    return len(heap)\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(minMeetingRooms(intervals))  # 2\n</code></pre>"},{"location":"neetcode150/intervals/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, line sweep, sorting, heap priority queue</li> </ul>"},{"location":"neetcode150/linked_list/","title":"Linked List","text":""},{"location":"neetcode150/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: linked list, recursion</li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[3]\nC --&gt; D[4]\nD --&gt; E[5]</code></pre> <pre><code>graph RL\nE[5] --&gt; D[4]\nD --&gt; C[3]\nC --&gt; B[2]\nB --&gt; A[1]</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"neetcode150/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: linked list, recursion</li> <li>Merge the two lists into one sorted list.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre>"},{"location":"neetcode150/linked_list/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, two pointers, stack, recursion</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\nhead = ListNode.create([1, 2, 3, 4, 5, 6])\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nreorderList(head)\nprint(head)  # 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n</code></pre>"},{"location":"neetcode150/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, two pointers</li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"neetcode150/linked_list/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list</li> </ul> <pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"neetcode150/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, math, recursion</li> <li>Represent the sum of two numbers as a linked list.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre>"},{"location":"neetcode150/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, linked list, two pointers</li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]</code></pre> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"neetcode150/linked_list/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, binary search, bit manipulation</li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> </ul> <pre><code>from typing import List\n\n\n# Fast Slow Pointer\ndef findDuplicate(nums: List[int]) -&gt; int:\n\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\n# | Algorithm          | TC   | SC   |\n# |--------------------|------|------|\n# | Fast Slow Pointer  | O(n) | O(1) |\n# |--------------------|------|------|\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"neetcode150/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list, design, doubly linked list</li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. Approach Time Complexity Space Complexity LRU O(1) O(n) <pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre>"},{"location":"neetcode150/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: linked list, divide and conquer, heap priority queue, merge sort</li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> <pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"neetcode150/linked_list/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: linked list, recursion</li> </ul>"},{"location":"neetcode150/math_geometry/","title":"Math Geometry","text":""},{"location":"neetcode150/math_geometry/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, math, matrix</li> </ul> <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"neetcode150/math_geometry/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, matrix, simulation</li> <li>Return all elements of the matrix in spiral order.</li> </ul> <pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"neetcode150/math_geometry/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, matrix</li> </ul> <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre>"},{"location":"neetcode150/math_geometry/#202-happy-number","title":"202. Happy Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: hash table, math, two pointers</li> <li>Return <code>True</code> if the number is a happy number, otherwise, return <code>False</code>.</li> <li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> </ul> <pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"neetcode150/math_geometry/#66-plus-one","title":"66. Plus One","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, math</li> </ul> <pre><code>from typing import List\n\n\n# Math\ndef plusOne(digits: List[int]) -&gt; List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] &lt; 9:\n            digits[i] += 1\n            return digits\n        else:\n            digits[i] = 0\n\n    return [1] + digits\n\n\ndigits = [4, 3, 2, 1]\nprint(plusOne(digits))  # [4, 3, 2, 2]\n</code></pre>"},{"location":"neetcode150/math_geometry/#50-powx-n","title":"50. Pow(x, n)","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, recursion</li> </ul> <pre><code># Iterative\ndef myPowIterative(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    result = 1\n    cur = x\n\n    while n &gt; 0:\n        if n % 2 == 1:\n            result *= cur\n\n        cur *= cur\n        n //= 2\n\n    return result\n\n\n# Recursive\ndef myPowRecursive(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    if n % 2 == 0:\n        return myPowRecursive(x * x, n // 2)\n    else:\n        return x * myPowRecursive(x * x, n // 2)\n\n\nx = 2.00000\nn = 10\nprint(myPowIterative(x, n))  # 1024.0\nprint(myPowRecursive(x, n))  # 1024.0\n</code></pre>"},{"location":"neetcode150/math_geometry/#43-multiply-strings","title":"43. Multiply Strings","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: math, string, simulation</li> </ul> <pre><code># Math\ndef multiply(num1: str, num2: str) -&gt; str:\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n\n    m, n = len(num1), len(num2)\n    result = [0 for _ in range(m + n)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            mul = int(num1[i]) * int(num2[j])\n            sum = mul + result[i + j + 1]\n\n            result[i + j + 1] = sum % 10\n            result[i + j] += sum // 10\n\n    result_str = \"\".join(map(str, result)).lstrip(\"0\")\n\n    return result_str if result_str else \"0\"\n\n\nnum1 = \"2\"\nnum2 = \"3\"\nprint(multiply(num1, num2))  # \"6\"\n</code></pre>"},{"location":"neetcode150/math_geometry/#166-fraction-to-recurring-decimal","title":"166. Fraction to Recurring Decimal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, math, string</li> </ul> <pre><code># Math\ndef fractionToDecimal(numerator: int, denominator: int) -&gt; str:\n    if numerator == 0:\n        return \"0\"\n\n    res = []\n\n    if (numerator &lt; 0) ^ (denominator &lt; 0):\n        res.append(\"-\")\n\n    numerator, denominator = abs(numerator), abs(denominator)\n\n    # Integer part\n    res.append(str(numerator // denominator))\n    remainder = numerator % denominator\n\n    if remainder == 0:\n        return \"\".join(res)\n\n    res.append(\".\")\n\n    # Dictionary to store remainders and their corresponding indices\n    remainder_map = {}\n\n    while remainder != 0:\n        if remainder in remainder_map:\n            res.insert(remainder_map[remainder], \"(\")\n            res.append(\")\")\n            break\n\n        remainder_map[remainder] = len(res)\n        remainder *= 10\n        res.append(str(remainder // denominator))\n        remainder %= denominator\n\n    return \"\".join(res)\n\n\nnumerator = 4\ndenominator = 333\nprint(fractionToDecimal(numerator, denominator))  # 0.(012)\n</code></pre>"},{"location":"neetcode150/sliding_window/","title":"Sliding Window","text":""},{"location":"neetcode150/sliding_window/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"neetcode150/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(len(s)):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"neetcode150/sliding_window/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"neetcode150/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, sliding window</li> </ul> <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"neetcode150/sliding_window/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, two pointers, string, sliding window</li> </ul> <pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"neetcode150/sliding_window/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, queue, sliding window, heap priority queue, monotonic queue</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"neetcode150/stack/","title":"Stack","text":""},{"location":"neetcode150/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, stack</li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" <pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"neetcode150/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: stack, design</li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> <pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"neetcode150/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, math, stack</li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> <pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"neetcode150/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming, backtracking</li> </ul> <pre><code>from typing import List\n\n\n# Stack\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"neetcode150/stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, stack, monotonic stack</li> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> Index Temp &gt; stack last stack result 0 73 False <code>[ [73, 0] ]</code> 1 - 0 = 1 1 74 True <code>[ [74, 1] ]</code> 2 - 1 = 1 2 75 True <code>[ [75, 2] ]</code> 6 - 2 = 4 3 71 False <code>[ [75, 2], [71, 3] ]</code> 5 - 3 = 2 4 69 False <code>[ [75, 2], [71, 3], [69, 4] ]</code> 5 - 4 = 1 5 72 True <code>[ [75, 2], [72, 5] ]</code> 6 - 5 = 1 6 76 True <code>[ [76, 6] ]</code> 0 7 73 False <code>[[76, 6], [73, 7]]</code> 0 <pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []\n\n    for idx, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, last_index = stack.pop()\n            res[last_index] = idx - last_index\n\n        stack.append([temp, idx])\n\n    return res\n\n\ndef utils_plot(idx: int, temps: List[int], stack: List[List[int]]) -&gt; None:\n    \"\"\"Plot the current state of the stack and the temperatures.\"\"\"\n    plt.figure(figsize=(8, 3))\n    plt.plot(\n        range(len(temps)),\n        temps,\n        marker=\"o\",\n        linestyle=\"-\",\n        color=\"b\",\n        label=\"Temperatures\",\n    )\n\n    # Highlight the current temperature in red\n    plt.scatter(idx, temps[idx], color=\"r\", s=100, label=\"Current\")\n\n    # Display the current state of the stack\n    for temp, stack_idx in stack:\n        plt.scatter(stack_idx, temp, color=\"g\", s=70)\n        plt.text(\n            stack_idx,\n            temp,\n            f\"({temp}, {stack_idx})\",\n            fontsize=10,\n            ha=\"center\",\n            va=\"bottom\",\n            color=\"red\",\n        )\n\n    plt.title(f\"Day {idx}\")\n    plt.xlabel(\"Days\")\n    plt.ylabel(\"Temperature\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"neetcode150/stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, stack, sorting, monotonic stack</li> </ul> <pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"neetcode150/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, stack, monotonic stack</li> </ul> <pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"neetcode150/trees/","title":"Trees","text":""},{"location":"neetcode150/trees/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"neetcode150/trees/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return depth\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    return 1 + max(maxDepthRecursive(root.left), maxDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthRecursive(root))  # 4\n</code></pre>"},{"location":"neetcode150/trees/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# Tree DFS\ndef diameterOfBinaryTree(root: Optional[TreeNode]) -&gt; int:\n    diameter = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left = dfs(node.left)\n        right = dfs(node.right)\n\n        nonlocal diameter\n        diameter = max(diameter, left + right)\n\n        return 1 + max(left, right)\n\n    dfs(root)\n    return diameter\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n)    | O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nprint(diameterOfBinaryTree(root))  # 3\n</code></pre>"},{"location":"neetcode150/trees/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"neetcode150/trees/#100-same-tree","title":"100. Same Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"neetcode150/trees/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: tree, depth first search, string matching, binary tree, hash function</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre>"},{"location":"neetcode150/trees/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"neetcode150/trees/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, breadth first search, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"neetcode150/trees/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, breadth first search, binary tree <pre><code>    ____1       &lt;---\n   /     \\\n  2__     2     &lt;--- Look at the rightmost node at each level\n /   \\     \\\n3     4     3   &lt;---\n     /\n    5           &lt;---\n</code></pre></li> </ul> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n\n        for i in range(n):\n            cur = q.popleft()\n\n            # rightmost element\n            if i == n - 1:\n                res.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"neetcode150/trees/#1448-count-good-nodes-in-binary-tree","title":"1448. Count Good Nodes in Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, breadth first search, binary tree</li> </ul> <pre><code>from typing import List\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# Tree\ndef goodNodes(root: TreeNode) -&gt; int:\n    def dfs(node, max_val):\n        if not node:\n            return 0\n\n        good = 1 if node.val &gt;= max_val else 0\n\n        max_val = max(max_val, node.val)\n\n        good += dfs(node.left, max_val)\n        good += dfs(node.right, max_val)\n\n        return good\n\n    return dfs(root, root.val)\n\n\nroot = build([3, 1, 4, 3, None, 1, 5])\nprint(root)\n#     3__\n#    /   \\\n#   1     4\n#  /     / \\\n# 3     1   5\nprint(goodNodes(root))  # 4\n</code></pre>"},{"location":"neetcode150/trees/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"neetcode150/trees/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: tree, depth first search, binary search tree, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"neetcode150/trees/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, tree, binary tree</li> </ul> <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"neetcode150/trees/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: dynamic programming, tree, depth first search, binary tree</li> </ul> <pre><code>from typing import Optional\n\nfrom binarytree import build\n\nfrom helper import TreeNode\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"neetcode150/trees/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: string, tree, depth first search, breadth first search, design, binary tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"neetcode150/tries/","title":"Tries","text":""},{"location":"neetcode150/tries/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, design, trie</li> </ul>"},{"location":"neetcode150/tries/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"neetcode150/tries/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, depth first search, design, trie</li> </ul> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"neetcode150/tries/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, string, backtracking, trie, matrix</li> </ul> <pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"neetcode150/two_pointers/","title":"Two Pointers","text":""},{"location":"neetcode150/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: two pointers, string</li> </ul> <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"neetcode150/two_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II -   Input Array Is Sorted","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, binary search</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"neetcode150/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# |-----------|---------|---------|\n# | Approach  |   Time  |  Space  |\n# |-----------|---------|---------|\n# | LR Pointer|  O(n^2) |   O(1)  |\n# |-----------|---------|---------|\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))  # [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"neetcode150/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, greedy</li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"neetcode150/two_pointers/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, two pointers, dynamic programming, stack, monotonic stack</li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) <pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"sql50/","title":"SQL 50","text":"<ul> <li>List: LeetCode SQL 50 | \u9ad8\u9891 SQL 50 \u9898\uff08\u57fa\u7840\u7248\uff09</li> <li>YouTube Playlist: SQL 50 Series by Everyday Data Science</li> </ul>"},{"location":"sql50/advanced_select_and_joins/","title":"Advanced Select and Joins","text":""},{"location":"sql50/advanced_select_and_joins/#1731-the-number-of-employees-which-report-to-each-employee","title":"1731. The Number of Employees Which Report to Each Employee","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_select_and_joins/#1789-primary-department-for-each-employee","title":"1789. Primary Department for Each Employee","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_select_and_joins/#610-triangle-judgement","title":"610. Triangle Judgement","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_select_and_joins/#180-consecutive-numbers","title":"180. Consecutive Numbers","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_select_and_joins/#1164-product-price-at-a-given-date","title":"1164. Product Price at a Given Date","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_select_and_joins/#1204-last-person-to-fit-in-the-bus","title":"1204. Last Person to Fit in the Bus","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_select_and_joins/#1907-count-salary-categories","title":"1907. Count Salary Categories","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/","title":"Advanced String Functions Regex Clause","text":""},{"location":"sql50/advanced_string_functions_regex_clause/#1667-fix-names-in-a-table","title":"1667. Fix Names in a Table","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#1527-patients-with-a-condition","title":"1527. Patients With a Condition","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#196-delete-duplicate-emails","title":"196. Delete Duplicate Emails","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#176-second-highest-salary","title":"176. Second Highest Salary","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#1484-group-sold-products-by-the-date","title":"1484. Group Sold Products By The Date","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#1327-list-the-products-ordered-in-a-period","title":"1327. List the Products Ordered in a Period","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#1517-find-users-with-valid-e-mails","title":"1517. Find Users With Valid E-Mails","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/basic_aggregate_functions/","title":"Basic Aggregate Functions","text":""},{"location":"sql50/basic_aggregate_functions/#620-not-boring-movies","title":"620. Not Boring Movies","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT\n    id,\n    movie,\n    description,\n    rating\nFROM\n    cinema\nWHERE\n    id % 2 = 1\n    AND LOWER(description) NOT LIKE '%boring%'\nORDER BY\n    rating DESC;\n</code></pre></p>"},{"location":"sql50/basic_aggregate_functions/#1251-average-selling-price","title":"1251. Average Selling Price","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT\n    p.product_id,\n    COALESCE(\n        ROUND(SUM(p.price * u.units) / SUM(u.units), 2),\n        0\n    ) AS average_price\nFROM\n    prices AS p\nLEFT JOIN unitssold AS u\n    ON\n        p.product_id = u.product_id\n        AND u.purchase_date BETWEEN p.start_date AND p.end_date\nGROUP BY\n    p.product_id;\n</code></pre></p>"},{"location":"sql50/basic_aggregate_functions/#1075-project-employees-i","title":"1075. Project Employees I","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT\n    p.project_id,\n    ROUND(AVG(e.experience_years), 2) AS average_years\nFROM\n    project AS p\nLEFT JOIN employee AS e ON p.employee_id = e.employee_id\nGROUP BY\n    p.project_id\n</code></pre></p>"},{"location":"sql50/basic_aggregate_functions/#1633-percentage-of-users-attended-a-contest","title":"1633. Percentage of Users Attended a Contest","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT\n    r.contest_id,\n    ROUND(\n        COUNT(DISTINCT r.user_id) / COUNT(DISTINCT u.user_id) * 100,\n        2\n    ) AS percentage\nFROM\n    users AS u\nCROSS JOIN register AS r\nGROUP BY\n    r.contest_id\nORDER BY\n    percentage DESC,\n    contest_id ASC\n</code></pre></p>"},{"location":"sql50/basic_aggregate_functions/#1211-queries-quality-and-percentage","title":"1211. Queries Quality and Percentage","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p><pre><code>Input:\nQueries table:\n+------------+-------------------+----------+--------+\n| query_name | result            | position | rating |\n+------------+-------------------+----------+--------+\n| Dog        | Golden Retriever  | 1        | 5      |\n| Dog        | German Shepherd   | 2        | 5      |\n| Dog        | Mule              | 200      | 1      |\n| Cat        | Shirazi           | 5        | 2      |\n| Cat        | Siamese           | 3        | 3      |\n| Cat        | Sphynx            | 7        | 4      |\n+------------+-------------------+----------+--------+\nOutput:\n+------------+---------+-----------------------+\n| query_name | quality | poor_query_percentage |\n+------------+---------+-----------------------+\n| Dog        | 2.50    | 33.33                 |\n| Cat        | 0.66    | 33.33                 |\n+------------+---------+-----------------------+\n</code></pre> <pre><code>SELECT\n    query_name,\n    ROUND(AVG(rating / POSITION), 2) AS quality,\n    ROUND(SUM(IF(rating &lt; 3, 1, 0)) / COUNT(*) * 100, 2)\n        AS poor_query_percentage\nFROM\n    queries\nWHERE\n    query_name IS NOT NULL\nGROUP BY\n    query_name;\n</code></pre></p>"},{"location":"sql50/basic_aggregate_functions/#1193-monthly-transactions-i","title":"1193. Monthly Transactions I","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul> <p><pre><code>Input:\nTransactions table:\n+------+---------+----------+--------+------------+\n| id   | country | state    | amount | trans_date |\n+------+---------+----------+--------+------------+\n| 121  | US      | approved | 1000   | 2018-12-18 |\n| 122  | US      | declined | 2000   | 2018-12-19 |\n| 123  | US      | approved | 2000   | 2019-01-01 |\n| 124  | DE      | approved | 2000   | 2019-01-07 |\n+------+---------+----------+--------+------------+\nOutput:\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |\n| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |\n| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n</code></pre> <pre><code>SELECT\n    country,\n    DATE_FORMAT(trans_date, '%Y-%m') AS month,\n    COUNT(*) AS trans_count,\n    COUNT(IF(state = 'approved', 1, NULL)) AS approved_count,\n    SUM(amount) AS trans_total_amount,\n    SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount\nFROM\n    transactions\nGROUP BY\n    month,\n    country;\n</code></pre></p>"},{"location":"sql50/basic_aggregate_functions/#1174-immediate-food-delivery-ii","title":"1174. Immediate Food Delivery II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/basic_aggregate_functions/#550-game-play-analysis-iv","title":"550. Game Play Analysis IV","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/basic_joins/","title":"Basic Joins","text":""},{"location":"sql50/basic_joins/#1378-replace-employee-id-with-the-unique-identifier","title":"1378. Replace Employee ID With The Unique Identifier","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>-- Replace employee id with the unique identifier\nSELECT\n    unique_id,\n    name\nFROM\n    employees\nLEFT JOIN employeeuni ON employees.id = employeeuni.id;\n</code></pre></p>"},{"location":"sql50/basic_joins/#1068-product-sales-analysis-i","title":"1068. Product Sales Analysis I","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT\n    p.product_name,\n    s.year,\n    s.price\nFROM\n    sales AS s\nLEFT JOIN product AS p ON s.product_id = p.product_id;\n</code></pre></p>"},{"location":"sql50/basic_joins/#1581-customer-who-visited-but-did-not-make-any-transactions","title":"1581. Customer Who Visited but Did Not Make Any Transactions","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>-- 1. Left Join\nSELECT\n    v.customer_id,\n    COUNT(v.visit_id) AS count_no_trans\nFROM\n    visits AS v\nLEFT JOIN transactions AS t ON v.visit_id = t.visit_id\nWHERE\n    t.transaction_id IS NULL\nGROUP BY\n    v.customer_id;\n\n-- 2. Subquery\nSELECT\n    customer_id,\n    COUNT(DISTINCT visit_id) AS count_no_trans\nFROM\n    visits\nWHERE\n    visit_id NOT IN (\n        SELECT visit_id\n        FROM\n            transactions\n    )\nGROUP BY\n    customer_id;\n</code></pre></p>"},{"location":"sql50/basic_joins/#197-rising-temperature","title":"197. Rising Temperature","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT w1.id\nFROM\n    weather AS w1\nLEFT JOIN weather AS w2 ON w1.recorddate - INTERVAL 1 DAY = w2.recorddate\nWHERE\n    w1.temperature &gt; w2.temperature;\n</code></pre></p>"},{"location":"sql50/basic_joins/#1661-average-time-of-process-per-machine","title":"1661. Average Time of Process per Machine","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT\n    a1.machine_id,\n    ROUND(AVG(a2.timestamp - a1.timestamp), 3) AS processing_time\n    -- ROUND(SUM(a2.timestamp - a1.timestamp) / COUNT(*), 3) AS processing_time\nFROM\n    activity AS a1\nINNER JOIN activity AS a2\n    ON\n        a1.machine_id = a2.machine_id\n        AND a1.process_id = a2.process_id\n        AND a1.timestamp &lt; a2.timestamp\nGROUP BY\n    a1.machine_id;\n</code></pre></p>"},{"location":"sql50/basic_joins/#577-employee-bonus","title":"577. Employee Bonus","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>-- 1.\nSELECT\n    e.name,\n    b.bonus\nFROM\n    employee AS e\nLEFT JOIN bonus AS b ON e.empid = b.empid\nWHERE\n    b.bonus &lt; 1000\n    OR b.bonus IS NULL;\n\n-- 2.\nSELECT\n    e.name,\n    b.bonus\nFROM\n    employee AS e\nLEFT JOIN bonus AS b ON e.empid = b.empid\nWHERE\n    COALESCE(b.bonus, 0) &lt; 1000;\n</code></pre></p>"},{"location":"sql50/basic_joins/#1280-students-and-examinations","title":"1280. Students and Examinations","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT\n    st.student_id,\n    st.student_name,\n    su.subject_name,\n    COUNT(ex.student_id) AS attended_exams\nFROM\n    students AS st\nCROSS JOIN subjects AS su\nLEFT JOIN examinations AS ex\n    ON\n        st.student_id = ex.student_id\n        AND su.subject_name = ex.subject_name\nGROUP BY\n    st.student_id,\n    st.student_name,\n    su.subject_name\nORDER BY\n    st.student_id,\n    su.subject_name;\n</code></pre></p>"},{"location":"sql50/basic_joins/#570-managers-with-at-least-5-direct-reports","title":"570. Managers with at Least 5 Direct Reports","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT e2.name\nFROM\n    employee AS e1\nINNER JOIN employee AS e2 ON e1.managerid = e2.id\nGROUP BY\n    e2.id,\n    e2.name\nHAVING\n    COUNT(e1.id) &gt;= 5;\n</code></pre></p>"},{"location":"sql50/basic_joins/#1934-confirmation-rate","title":"1934. Confirmation Rate","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT\n    s.user_id,\n    ROUND(\n        SUM(IF(c.action = 'confirmed', 1, 0)) / COUNT(*),\n        2\n    ) AS confirmation_rate\nFROM\n    signups AS s\nLEFT JOIN confirmations AS c ON s.user_id = c.user_id\nGROUP BY\n    s.user_id;\n</code></pre></p>"},{"location":"sql50/select/","title":"Select","text":""},{"location":"sql50/select/#1757-recyclable-and-low-fat-products","title":"1757. Recyclable and Low Fat Products","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p><pre><code>Input:\nProducts table:\n+-------------+----------+------------+\n| product_id  | low_fats | recyclable |\n+-------------+----------+------------+\n| 0           | Y        | N          |\n| 1           | Y        | Y          |\n| 2           | N        | Y          |\n| 3           | Y        | Y          |\n| 4           | N        | N          |\n+-------------+----------+------------+\nOutput:\n+-------------+\n| product_id  |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n</code></pre> <pre><code>SELECT product_id\nFROM\n    products\nWHERE\n    low_fats = 'Y'\n    AND recyclable = 'Y';\n</code></pre></p>"},{"location":"sql50/select/#584-find-customer-referee","title":"584. Find Customer Referee","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>-- 1.\nSELECT NAME\nFROM\n    CUSTOMER\nWHERE\n    REFEREE_ID &lt;&gt; 2\n    OR REFEREE_ID IS NULL;\n\n-- 2.\nSELECT NAME\nFROM\n    CUSTOMER\nWHERE\n    COALESCE(REFEREE_ID, -1) &lt;&gt; 2;\n\n-- 3.\nSELECT NAME\nFROM\n    CUSTOMER\nWHERE\n    COALESCE(REFEREE_ID, -1) &lt;&gt; 2;\n</code></pre></p>"},{"location":"sql50/select/#595-big-countries","title":"595. Big Countries","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT\n    NAME,\n    POPULATION,\n    AREA\nFROM\n    WORLD\nWHERE\n    POPULATION &gt;= 25000000\n    OR AREA &gt;= 3000000;\n</code></pre></p>"},{"location":"sql50/select/#1148-article-views-i","title":"1148. Article Views I","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT DISTINCT author_id AS id\nFROM\n    views\nWHERE\n    author_id = viewer_id\nORDER BY\n    id ASC;\n</code></pre></p>"},{"location":"sql50/select/#1683-invalid-tweets","title":"1683. Invalid Tweets","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul> <p> <pre><code>SELECT tweet_id\nFROM\n    tweets\nWHERE\n    CHAR_LENGTH(content) &gt; 15;\n</code></pre></p>"},{"location":"sql50/sorting_and_grouping/","title":"Sorting and Grouping","text":""},{"location":"sql50/sorting_and_grouping/#2356-number-of-unique-subjects-taught-by-each-teacher","title":"2356. Number of Unique Subjects Taught by Each Teacher","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/sorting_and_grouping/#1141-user-activity-for-the-past-30-days-i","title":"1141. User Activity for the Past 30 Days I","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/sorting_and_grouping/#1070-product-sales-analysis-iii","title":"1070. Product Sales Analysis III","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/sorting_and_grouping/#596-classes-more-than-5-students","title":"596. Classes More Than 5 Students","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/sorting_and_grouping/#1729-find-followers-count","title":"1729. Find Followers Count","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/sorting_and_grouping/#619-biggest-single-number","title":"619. Biggest Single Number","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/sorting_and_grouping/#1045-customers-who-bought-all-products","title":"1045. Customers Who Bought All Products","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/subqueries/","title":"Subqueries","text":""},{"location":"sql50/subqueries/#1978-employees-whose-manager-left-the-company","title":"1978. Employees Whose Manager Left the Company","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/subqueries/#626-exchange-seats","title":"626. Exchange Seats","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/subqueries/#1341-movie-rating","title":"1341. Movie Rating","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/subqueries/#1321-restaurant-growth","title":"1321. Restaurant Growth","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/subqueries/#602-friend-requests-ii-who-has-the-most-friends","title":"602. Friend Requests II: Who Has the Most Friends","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/subqueries/#585-investments-in-2016","title":"585. Investments in 2016","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: database</li> </ul>"},{"location":"sql50/subqueries/#185-department-top-three-salaries","title":"185. Department Top Three Salaries","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: database</li> </ul>"}]}