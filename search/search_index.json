{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to \ud83d\ude80LeetPattern","text":"<ul> <li>Your ultimate guide to mastering coding interviews with LeetPattern.</li> <li>Learn essential problem-solving patterns and practice with real interview questions to boost your confidence and skills.</li> </ul>"},{"location":"#why-leetpattern","title":"Why \ud83d\ude80LeetPattern?","text":"<ul> <li>Comprehensive Guides: Dive into detailed tutorials that cover all major coding patterns you need to know for interviews.</li> <li>Structured Learning: Organized by difficulty and topic, our content helps you learn efficiently and effectively.</li> <li>Real Interview Questions: Practice with problems that are frequently asked in top tech interviews.</li> <li>Community Support: Join our community of learners and mentors. Get support, share insights, and grow together.</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python Basics: Python Distilled</li> </ul>"},{"location":"#to-do","title":"To Do","text":"<ul> <li>Add explanations for the most common question for each pattern.</li> <li>To be completed: 28 problems.</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>\u7b97\u6cd5\u7ade\u8d5b\u6a21\u677f\u5e93 by \u7075\u8336\u5c71\u827e\u5e9c</li> </ul>"},{"location":"arrays/","title":"Arrays","text":""},{"location":"arrays/#array-resources","title":"Array Resources","text":"<ul> <li>[Leetcode Discuss] Solved all two pointers problems in 100 days</li> </ul>"},{"location":"arrays/array/","title":"Array","text":""},{"location":"arrays/array/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0414 - Third Maximum Number (Easy)</li> <li>2022 - Convert 1D Array Into 2D Array (Easy)</li> <li>0054 - Spiral Matrix (Medium)</li> <li>0059 - Spiral Matrix II (Medium)</li> </ol>"},{"location":"arrays/array/#414-third-maximum-number","title":"414. Third Maximum Number","text":"<ul> <li>Return the third maximum number in an array. If the third maximum does not exist, return the maximum number.</li> </ul> <pre><code>from typing import List\n\n\n# Sort\ndef thirdMaxSort(nums: List[int]) -&gt; int:\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n\n    return nums[2] if len(nums) &gt;= 3 else nums[0]\n\n\n# Compare\ndef thirdMaxCompare(nums: List[int]) -&gt; int:\n    first, second, third = float(\"-inf\"), float(\"-inf\"), float(\"-inf\")\n\n    for num in nums:\n        if num &gt; first:\n            first, second, third = num, first, second\n        elif first &gt; num &gt; second:\n            second, third = num, second\n        elif second &gt; num &gt; third:\n            third = num\n\n    return third if third != float(\"-inf\") else first\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Sort     |    O(NlogN)     |     O(N)     |\n# |  Compare    |       O(N)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(thirdMaxSort([3, 2, 1]))  # 1\nprint(thirdMaxCompare([3, 2, 1]))  # 1\n</code></pre>"},{"location":"arrays/array/#2022-convert-1d-array-into-2d-array","title":"2022. Convert 1D Array Into 2D Array","text":"<pre><code>from typing import List\n\n\n# Brute Force\ndef construct2DArray(original: List[int], m: int, n: int) -&gt; List[List[int]]:\n    if len(original) != m * n:\n        return []\n    array = []\n\n    for i in range(m):\n        row = original[n * i : n * (i + 1)]\n        array.append(row)\n\n    return array\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Brute     |  O(m)  |  O(1)   |\n# |------------|--------|---------|\n\n\noriginal = [1, 2, 3, 4]\nm = 2\nn = 2\n\nprint(construct2DArray(original, m, n))  # [[1, 2], [3, 4]]\n</code></pre>"},{"location":"arrays/array/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li>Return all elements of the matrix in spiral order.</li> </ul> <pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"arrays/array/#59-spiral-matrix-ii","title":"59. Spiral Matrix II","text":"<ul> <li>Return a square matrix filled with elements from 1 to n^2 in spiral order.</li> </ul> <pre><code>from pprint import pprint\nfrom typing import List\n\n\n# Array\ndef generateMatrix(n: int) -&gt; List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n\n    for layer in range((n + 1) // 2):\n        for i in range(layer, n - layer):\n            matrix[layer][i] = num\n            num += 1\n        for j in range(layer + 1, n - layer):\n            matrix[j][n - 1 - layer] = num\n            num += 1\n        for i in range(n - 2 - layer, layer - 1, -1):\n            matrix[n - 1 - layer][i] = num\n            num += 1\n        for j in range(n - 2 - layer, layer, -1):\n            matrix[j][layer] = num\n            num += 1\n\n    return matrix\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Layer     |      O(N^2)     |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\npprint(generateMatrix(5))\n# [[ 1,  2,  3,  4, 5],\n#  [16, 17, 18, 19, 6],\n#  [15, 24, 25, 20, 7],\n#  [14, 23, 22, 21, 8],\n#  [13, 12, 11, 10, 9]]\n</code></pre>"},{"location":"arrays/binary_search/","title":"Binary Search","text":"<ul> <li>Binary search is a search algorithm that finds the position of a target value within a sorted array.</li> <li>We need to sort the array before applying binary search if it is not sorted.</li> <li>Time Complexity: \\(O(\\log{N})\\)</li> <li>Space Complexity: \\(O(1)\\)</li> </ul>"},{"location":"arrays/binary_search/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0704 - Binary Search (Easy)</li> <li>0035 - Search Insert Position (Easy)</li> <li>0278 - First Bad Version (Easy)</li> <li>0034 - Find First and Last Position of Element in Sorted Array (Medium)</li> <li>0367 - Valid Perfect Square (Easy)</li> <li>0875 - Koko Eating Bananas (Medium)</li> <li>1011 - Capacity To Ship Packages Within D Days (Medium)</li> <li>0378 - Kth Smallest Element in a Sorted Matrix (Medium)</li> </ol>"},{"location":"arrays/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li>Implement binary search algorithm.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &gt; target:\n            right = mid - 1\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            return mid\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"arrays/binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li>Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &gt; target:\n            right = mid - 1\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre>"},{"location":"arrays/binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> <pre><code># Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"arrays/binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li>Find the starting and ending position of a given target value in a sorted array.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef searchRange(nums: List[int], target: int) -&gt; List[int]:\n\n    def insertPosition(nums, target):\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    left = insertPosition(nums, target)\n    right = insertPosition(nums, target + 1) - 1\n\n    if left == len(nums) or nums[left] != target:\n        return [-1, -1]\n\n    return [left, right]\n\n\nnums = [5, 7, 7, 8, 8, 10]\ntarget = 8\nprint(searchRange(nums, target))  # [3, 4]\n</code></pre>"},{"location":"arrays/binary_search/#367-valid-perfect-square","title":"367. Valid Perfect Square","text":"<ul> <li>Determine if a positive integer is a perfect square without using any built-in library function.</li> </ul> <pre><code># Binary Search\ndef isPerfectSquare(num: int) -&gt; bool:\n    if num &lt; 2:\n        return True\n\n    left, right = 0, num // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if mid * mid == num:\n            return True\n        elif mid * mid &lt; num:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nnum = 16\nprint(isPerfectSquare(num))  # True\n</code></pre>"},{"location":"arrays/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"arrays/binary_search/#1011-capacity-to-ship-packages-within-d-days","title":"1011. Capacity To Ship Packages Within D Days","text":"<ul> <li>A conveyor belt has packages that must be shipped from one port to another within <code>D</code> days. The <code>i-th</code> package has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt. The ship will be loaded with packages up to its capacity. The ship will not be loaded beyond its capacity. Return the least weight capacity of the ship.</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef shipWithinDays(weights: List[int], days: int) -&gt; int:\n\n    def canShip(weights, D, capacity):\n        days = 1\n        current_weight = 0\n\n        for weight in weights:\n            if current_weight + weight &gt; capacity:\n                days += 1\n                current_weight = 0\n            current_weight += weight\n\n        return days &lt;= D\n\n    left, right = max(weights), sum(weights)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canShip(weights, days, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\nweights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndays = 5\nprint(shipWithinDays(weights, days))  # 15\n</code></pre>"},{"location":"arrays/binary_search/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> <pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"arrays/binary_search/#appendix","title":"Appendix","text":""},{"location":"arrays/binary_search/#binary-search-template","title":"Binary Search Template","text":"<p>Three ways to implement binary search</p> <ol> <li><code>[left, right]</code> \u2190 Most common</li> <li><code>[left, right)</code></li> <li>Recursive</li> </ol> <pre><code>from typing import List\n\n\n# 1. [left, right]\ndef search1(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n\n# 2. [left, right)\ndef search2(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            right = mid\n    return -1\n\n\n# 3. Recursive\ndef search3(nums: List[int], target: int) -&gt; int:\n\n    def binary_search(left, right):\n        if left &gt; right:\n            return -1\n\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] &lt; target:\n            return binary_search(mid + 1, right)\n        else:\n            return binary_search(left, mid - 1)\n\n    return binary_search(0, len(nums) - 1)\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search1(nums, target))  # 4\nprint(search2(nums, target))  # 4\nprint(search3(nums, target))  # 4\n</code></pre>"},{"location":"arrays/binary_search/#bisect-usage-to-be-updated","title":"bisect Usage [To be updated]","text":"<pre><code>from bisect import bisect_left, bisect_right, insort_left, insort_right\n\narray = [1, 3, 3, 3, 5, 7, 9, 9, 9]\nx = 3\n\n# 1. bisect_left: find the leftmost index to insert x\nprint(bisect_left(array, x))  # 1\n\n# 2. bisect_right: find the rightmost index to insert x\nprint(bisect_right(array, x))  # 4\n\n# 3. insort_left: insert x into the array at the leftmost index\ninsort_left(array, x)\nprint(array)  # [1, 3, 3, 3, 3, 5, 7, 9, 9, 9]\n\n# 4. insort_right: insert x into the array at the rightmost index\ninsort_right(array, x)\nprint(array)  # [1, 3, 3, 3, 3, 3, 5, 7, 9, 9, 9]\n</code></pre>"},{"location":"arrays/difference_array/","title":"Difference Array","text":""},{"location":"arrays/difference_array/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>1094 - Car Pooling (Medium)</li> <li>0370 - Range Addition (Medium) (Premium)</li> <li>2848 - Points That Intersect With Cars (Easy)</li> </ol>"},{"location":"arrays/difference_array/#1094-car-pooling","title":"1094. Car Pooling","text":"<ul> <li>Return <code>False</code> if the total number of passengers at any point is greater than <code>capacity</code>. Otherwise, return <code>True</code>.</li> </ul> <pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Difference Array\ndef carPooling1(trips: List[List[int]], capacity: int) -&gt; bool:\n    max_location = 0\n    for trip in trips:\n        max_location = max(max_location, trip[2])\n\n    diff = [0] * (max_location + 1)\n    n = len(diff)\n\n    for num, start, end in trips:\n        diff[start] += num\n        if end &lt; n:\n            diff[end] -= num\n\n    cur = 0\n    for i in range(n):\n        cur += diff[i]\n        if cur &gt; capacity:\n            return False\n\n    return True\n\n\n# Difference Array\ndef carPooling2(trips: List[List[int]], capacity: int) -&gt; bool:\n    diff = [0] * 1001\n\n    for num, start, end in trips:\n        diff[start] += num\n        diff[end] -= num\n\n    return all(s &lt;= capacity for s in accumulate(diff))\n\n\ntrips = [[2, 1, 5], [3, 3, 7]]\ncapacity = 4\nprint(carPooling1(trips, capacity))  # False\nprint(carPooling2(trips, capacity))  # False\n</code></pre>"},{"location":"arrays/difference_array/#0370-range-addition","title":"0370. Range Addition","text":"<ul> <li>Return the final array after applying all the Adition operations.</li> </ul> <pre><code>from typing import List\n\n\n# Difference Array\ndef getModifiedArray(length: int, updates: List[List[int]]) -&gt; List[int]:\n    result = [0 for _ in range(length)]\n\n    for start, end, inc in updates:\n        result[start] += inc\n\n        if end + 1 &lt; length:\n            result[end + 1] -= inc\n\n    for i in range(1, length):\n        result[i] += result[i - 1]\n\n    return result\n\n\nlength = 5\nupdates = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]\nprint(getModifiedArray(length, updates))  # [-2, 0, 3, 5, 3]\n</code></pre>"},{"location":"arrays/difference_array/#2848-points-that-intersect-with-cars","title":"2848. Points That Intersect With Cars","text":"<ul> <li>Return the number of points that intersect with cars.</li> </ul> <pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Differnce Array\ndef numberOfPoints(nums: List[List[int]]) -&gt; int:\n    max_end = max(end for _, end in nums)\n\n    diff = [0] * (max_end + 2)\n\n    for start, end in nums:\n        diff[start] += 1\n        diff[end + 1] -= 1\n\n    return sum(s &gt; 0 for s in accumulate(diff))\n\n\nnums = [[3, 6], [1, 5], [4, 7]]\nprint(numberOfPoints(nums))  # 7\n</code></pre>"},{"location":"arrays/fast_slow_pointers/","title":"Fast Slow Pointers","text":""},{"location":"arrays/fast_slow_pointers/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0027 - Remove Element (Easy)</li> <li>0026 - Remove Duplicates from Sorted Array (Easy)</li> <li>0080 - Remove Duplicates from Sorted Array II (Medium)</li> <li>0283 - Move Zeroes (Easy)</li> <li>1089 - Duplicate Zeros (Easy)</li> <li>0287 - Find the Duplicate Number (Medium)</li> </ol>"},{"location":"arrays/fast_slow_pointers/#27-remove-element","title":"27. Remove Element","text":"<ul> <li>Remove all instances of a given value in-place.</li> </ul> <pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [3, 2, 2, 3]\nval = 3\nprint(removeElement(nums, val))  # 2\n</code></pre>"},{"location":"arrays/fast_slow_pointers/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li>Remove duplicates in-place.</li> </ul> <pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre>"},{"location":"arrays/fast_slow_pointers/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li>Allow at most two duplicates.</li> <li>fast pointer: explore the array</li> <li>slow pointer: point to the position to be replaced</li> </ul> <pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre>"},{"location":"arrays/fast_slow_pointers/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li>Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.</li> </ul> <pre><code>from typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre>"},{"location":"arrays/fast_slow_pointers/#1089-duplicate-zeros","title":"1089. Duplicate Zeros","text":"<ul> <li>Duplicate each occurrence of zero, shifting the remaining elements to the right.</li> </ul> <pre><code>from typing import List\n\n\ndef duplicateZeros(arr: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    fast, slow = 0, 0\n\n    # First pass: find the position\n    # where the last element would be in the expanded array\n    while fast &lt; n:\n        if arr[slow] == 0:\n            fast += 1\n        slow += 1\n        fast += 1\n\n    slow -= 1\n    fast -= 1\n\n    # Second pass: move elements backwards\n    while slow &gt;= 0:\n        if fast &lt; n:\n            arr[fast] = arr[slow]\n\n        if arr[slow] == 0:\n            fast -= 1\n            if fast &lt; n:\n                arr[fast] = 0\n\n        slow -= 1\n        fast -= 1\n\n\narr = [1, 0, 2, 3, 0, 4, 5, 0]\nduplicateZeros(arr)\nprint(arr)  # [1, 0, 0, 2, 3, 0, 0, 4]\n</code></pre>"},{"location":"arrays/fast_slow_pointers/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> </ul> <pre><code>from typing import List\n\n\ndef findDuplicate(nums: List[int]) -&gt; int:\n\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"arrays/left_right_pointers/","title":"Left Right Pointers","text":""},{"location":"arrays/left_right_pointers/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0009 - Palindrome Number (Easy)</li> <li>0015 - 3Sum (Medium)</li> <li>0018 - 4Sum (Medium)</li> <li>0069 - Sqrt(x) (Easy)</li> <li>0088 - Merge Sorted Array (Easy)</li> <li>0977 - Squares of a Sorted Array (Easy)</li> <li>0881 - Boats to Save People (Medium)</li> <li>0075 - Sort Colors (Medium)</li> <li>0125 - Valid Palindrome (Easy)</li> <li>0167 - Two Sum II - Input array is sorted (Easy)</li> <li>0011 - Container With Most Water (Medium)</li> </ol>"},{"location":"arrays/left_right_pointers/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li>Return true if the given number is a palindrome. Otherwise, return false.</li> </ul> <pre><code># Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"arrays/left_right_pointers/#15-3sum","title":"15. 3Sum","text":"<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# |-----------|---------|---------|\n# | Approach  |   Time  |  Space  |\n# |-----------|---------|---------|\n# | LR Pointer|  O(n^2) |   O(1)  |\n# |-----------|---------|---------|\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))  # [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"arrays/left_right_pointers/#18-4sum","title":"18. 4Sum","text":"<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    \"\"\"Returns all unique quadruplets that sum up to the target.\"\"\"\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n# [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre>"},{"location":"arrays/left_right_pointers/#69-sqrtx","title":"69. Sqrt(x)","text":"<pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre>"},{"location":"arrays/left_right_pointers/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    \"\"\"Merges two sorted arrays in-place.\"\"\"\n    p1, p2, t = m - 1, n - 1, m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n\n        t -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre>"},{"location":"arrays/left_right_pointers/#977-squares-of-a-sorted-array","title":"977. Squares of a Sorted Array","text":"<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    \"\"\"Returns the squares of the sorted array.\"\"\"\n    n = len(nums)\n    result = [0 for _ in range(n)]\n\n    left, right, tail = 0, n - 1, n - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[tail] = nums[left] ** 2\n            left += 1\n        else:\n            result[tail] = nums[right] ** 2\n            right -= 1\n        tail -= 1\n\n    return result\n\n\n# |---------------------|------|-------|\n# | Approach            | Time | Space |\n# |---------------------|------|-------|\n# | Left Right Pointers | O(n) | O(n)  |\n# |---------------------|------|-------|\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre>"},{"location":"arrays/left_right_pointers/#881-boats-to-save-people","title":"881. Boats to Save People","text":"<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef numRescueBoats(people: List[int], limit: int) -&gt; int:\n    \"\"\"Returns the minimum number of boats to rescue people.\"\"\"\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n\n    while left &lt;= right:\n        if people[left] + people[right] &lt;= limit:\n            left += 1\n        right -= 1\n        boats += 1\n\n    return boats\n\n\npeople = [3, 2, 2, 1]\nlimit = 3\nprint(numRescueBoats(people, limit))  # 3\n</code></pre>"},{"location":"arrays/left_right_pointers/#75-sort-colors","title":"75. Sort Colors","text":"<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortColors(nums: List[int]) -&gt; None:\n    \"\"\"Sorts an array of 0, 1, and 2 in-place.\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    current = 0\n\n    while current &lt;= right:\n        if nums[current] == 0:\n            nums[left], nums[current] = nums[current], nums[left]\n            left += 1\n            current += 1\n        elif nums[current] == 2:\n            nums[right], nums[current] = nums[current], nums[right]\n            right -= 1\n        else:\n            current += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nsortColors(nums)\nprint(nums)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"arrays/left_right_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"arrays/left_right_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input array is sorted","text":"<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"arrays/left_right_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"arrays/prefix_sum/","title":"Prefix Sum","text":""},{"location":"arrays/prefix_sum/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>2574 - Left and Right Sum Difference (easy)</li> <li>1732 - Find the Highest Altitude (easy)</li> <li>0303 - Range Sum Query - Immutable (easy)</li> <li>0304 - Range Sum Query 2D - Immutable (medium)</li> <li>0560 - Subarray Sum Equals K (medium)</li> <li>0238 - Product of Array Except Self (medium)</li> <li>0974 - Subarray Sums Divisible by K (medium)</li> <li>0209 - Minimum Size Subarray Sum (medium)</li> <li>0523 - Continuous Subarray Sum (medium)</li> <li>1248 - Count Number of Nice Subarrays (medium)</li> <li>0325 - Maximum Size Subarray Sum Equals k (medium)</li> <li>0862 - Shortest Subarray with Sum at Least K (hard)</li> <li>1171 - Remove Zero Sum Consecutive Nodes from Linked List (medium)</li> </ol>"},{"location":"arrays/prefix_sum/#2574-left-and-right-sum-difference","title":"2574. Left and Right Sum Difference","text":"<pre><code>from typing import List\n\n\n# 1. Left Right Sum\ndef leftRightDifferenceSum(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    left = [0] * n\n    right = [0] * n\n\n    for i in range(1, n):\n        left[i] = left[i - 1] + nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right[i] = right[i + 1] + nums[i + 1]\n\n    return [abs(left[i] - right[i]) for i in range(n)]\n\n\n# 2. Left Right Pointer\ndef leftRightDifferencePointer(nums: List[int]) -&gt; List[int]:\n    left, right = 0, sum(nums)\n    result = []\n\n    for num in nums:\n        right -= num\n        result.append(abs(left - right))\n        left += num\n\n    return result\n\n\nnums = [10, 4, 8, 3]\nprint(leftRightDifferenceSum(nums))  # [15, 1, 11, 22]\nprint(leftRightDifferencePointer(nums))  # [15, 1, 11, 22]\n</code></pre>"},{"location":"arrays/prefix_sum/#1732-find-the-highest-altitude","title":"1732. Find the Highest Altitude","text":"<pre><code>from typing import List\n\n\ndef largestAltitude(gain: List[int]) -&gt; int:\n    result, altitude = 0, 0\n\n    for i in gain:\n        altitude += i\n        result = max(result, altitude)\n\n    return result\n\n\ngain = [-5, 1, 5, 0, -7]\nprint(largestAltitude(gain))  # 1\n</code></pre>"},{"location":"arrays/prefix_sum/#303-range-sum-query-immutable","title":"303. Range Sum Query - Immutable","text":"<pre><code>from typing import List\n\n\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.prefix_sum = [0 for _ in range(len(nums) + 1)]\n\n        for i in range(1, len(nums) + 1):\n            self.prefix_sum[i] = self.prefix_sum[i - 1] + nums[i - 1]\n\n    def sumRange(self, left: int, right: int) -&gt; int:\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\n\n\nnums = [-2, 0, 3, -5, 2, -1]\nobj = NumArray(nums)\nassert obj.sumRange(0, 2) == 1\nassert obj.sumRange(2, 5) == -1\nassert obj.sumRange(0, 5) == -3\nprint(\"PASSED\")\n</code></pre>"},{"location":"arrays/prefix_sum/#304-range-sum-query-2d-immutable","title":"304. Range Sum Query 2D - Immutable","text":"<pre><code>from typing import List\n\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return None\n\n        self.sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sum[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sum[i - 1][j]\n                    + self.sum[i][j - 1]\n                    - self.sum[i - 1][j - 1]  # to avoid double counting\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return (\n            self.sum[row2 + 1][col2 + 1]\n            - self.sum[row1][col2 + 1]\n            - self.sum[row2 + 1][col1]\n            + self.sum[row1][col1]\n        )\n\n\nmatrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5],\n]\nobj = NumMatrix(matrix)\nassert obj.sumRegion(2, 1, 4, 3) == 8\nassert obj.sumRegion(1, 1, 2, 2) == 11\nassert obj.sumRegion(1, 2, 2, 4) == 12\nprint(\"PASSED\")\n</code></pre>"},{"location":"arrays/prefix_sum/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"arrays/prefix_sum/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<pre><code>from typing import List\n\n\n# 1. Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# 2. Prefix - Optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |    Prefix   |    O(n)     |    O(n)      |\n# |Prefix - Opt |    O(n)     |    O(1)      |\n# |-------------|-------------|--------------|\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"arrays/prefix_sum/#974-subarray-sums-divisible-by-k","title":"974. Subarray Sums Divisible by K","text":"<pre><code>from typing import List\n\n\ndef subarraysDivByK_1(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n\n        if mod &lt; 0:\n            mod += k\n\n        if mod in mods:\n            result += mods[mod]\n\n        if mod in mods:\n            mods[mod] += 1\n        else:\n            mods[mod] = 1\n\n    return result\n\n\ndef subarraysDivByK_2(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n        result += mods.get(mod, 0)\n        mods[mod] = mods.get(mod, 0) + 1\n\n    return result\n\n\nnums = [4, 5, 0, -2, -3, 1]\nk = 5\nprint(subarraysDivByK_1(nums, k))  # 7\nprint(subarraysDivByK_2(nums, k))  # 7\n</code></pre>"},{"location":"arrays/prefix_sum/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding window - Fixed\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    left, right = 0, 0\n    curSum = 0\n    minLen = float(\"inf\")\n\n    while right &lt; len(nums):\n        curSum += nums[right]\n\n        while curSum &gt;= target:\n            minLen = min(minLen, right - left + 1)\n            curSum -= nums[left]\n            left += 1\n\n        right += 1\n\n    return minLen if minLen != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"arrays/prefix_sum/#523-continuous-subarray-sum","title":"523. Continuous Subarray Sum","text":""},{"location":"arrays/prefix_sum/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":""},{"location":"arrays/prefix_sum/#325-maximum-size-subarray-sum-equals-k","title":"325. Maximum Size Subarray Sum Equals k","text":""},{"location":"arrays/prefix_sum/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":""},{"location":"arrays/prefix_sum/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","text":""},{"location":"arrays/sliding_window_fixed/","title":"Sliding Window - Fixed Size","text":""},{"location":"arrays/sliding_window_fixed/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0643 - Maximum Average Subarray I (Easy)</li> <li>0219 - Contains Duplicate II (Easy)</li> <li>1456 - Maximum Number of Vowels in a Substring of Given Length (Medium)</li> <li>0567 - Permutation in String (Medium)</li> <li>0713 - Subarray Product Less Than K (Medium)</li> <li>1151 - Minimum Swaps to Group All 1's Together (Medium)</li> <li>0209 - Minimum Size Subarray Sum (Medium)</li> <li>0076 - Minimum Window Substring (Hard)</li> </ol>"},{"location":"arrays/sliding_window_fixed/#643-maximum-average-subarray-i","title":"643. Maximum Average Subarray I","text":"<ul> <li>Find the contiguous subarray of given length <code>k</code> that has the maximum average value.</li> </ul> <pre><code>from typing import List\n\n\n# Sliding Window - Fixed\ndef findMaxAverage(nums: List[int], k: int) -&gt; float:\n    cur = sum(nums[:k])\n    result = cur\n\n    for i in range(k, len(nums)):\n        cur += nums[i] - nums[i - k]\n        result = max(result, cur)\n\n    return result / k\n\n\nnums = [1, 12, -5, -6, 50, 3]\nk = 4\nprint(findMaxAverage(nums, k))  # 12.75\n</code></pre>"},{"location":"arrays/sliding_window_fixed/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li>Return <code>True</code> if there are two distinct indices <code>i</code> and <code>j</code> in the array such that <code>nums[i] == nums[j]</code> and <code>abs(i - j) &lt;= k</code>.</li> </ul> <pre><code>from typing import List\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicate(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicate(nums, k))  # True\n</code></pre>"},{"location":"arrays/sliding_window_fixed/#1456-maximum-number-of-vowels-in-a-substring-of-given-length","title":"1456. Maximum Number of Vowels in a Substring of Given Length","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Fixed\ndef maxVowels(s: str, k: int) -&gt; int:\n    vowel = set(\"aeiou\")\n    count = 0\n\n    for i in range(k):\n        if s[i] in vowel:\n            count += 1\n\n    max_count = count\n\n    for i in range(k, len(s)):\n        if s[i] in vowel:\n            count += 1\n        if s[i - k] in vowel:\n            count -= 1\n\n        max_count = max(max_count, count)\n\n        if max_count == k:\n            break\n\n    return max_count\n\n\ns = \"abciiidef\"\nk = 3\nprint(maxVowels(s, k))  # 3\n</code></pre>"},{"location":"arrays/sliding_window_fixed/#567-permutation-in-string","title":"567. Permutation in String","text":"<pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"arrays/sliding_window_fixed/#713-subarray-product-less-than-k","title":"713. Subarray Product Less Than K","text":"<pre><code>from typing import List\n\n\n# Sliding window - Fixed\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -&gt; int:\n    if k &lt;= 1:\n        return 0\n\n    left = 0\n    product = 1\n    count = 0\n\n    for right in range(len(nums)):\n        product *= nums[right]\n\n        while product &gt;= k:\n            product //= nums[left]\n            left += 1\n\n        count += right - left + 1\n\n    return count\n\n\nnums = [10, 5, 2, 6]\nk = 100\nprint(numSubarrayProductLessThanK(nums, k))  # 8\n</code></pre>"},{"location":"arrays/sliding_window_fixed/#1151-minimum-swaps-to-group-all-1s-together","title":"1151. Minimum Swaps to Group All 1's Together","text":"<ul> <li>Return the minimum number of swaps required to group all 1's together in any subarray of size <code>k</code>.</li> </ul> <pre><code>from typing import List\n\n\ndef minSwaps(data: List[int]) -&gt; int:\n    n = len(data)\n    total = sum(data)\n\n    if total == 0 or total == 1 or total == n:\n        return 0\n\n    max_count = 0\n    cur = 0\n    left = 0\n\n    for right in range(n):\n        cur += data[right]\n\n        if right - left + 1 &gt; total:\n            cur -= data[left]\n            left += 1\n\n        max_count = max(max_count, cur)\n\n    return total - max_count\n\n\ndata = [1, 0, 1, 0, 1]\nprint(minSwaps(data))  # 1\n</code></pre>"},{"location":"arrays/sliding_window_fixed/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding window - Fixed\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    left, right = 0, 0\n    curSum = 0\n    minLen = float(\"inf\")\n\n    while right &lt; len(nums):\n        curSum += nums[right]\n\n        while curSum &gt;= target:\n            minLen = min(minLen, right - left + 1)\n            curSum -= nums[left]\n            left += 1\n\n        right += 1\n\n    return minLen if minLen != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"arrays/sliding_window_fixed/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"arrays/sliding_window_variable/","title":"Sliding Window - Variable Size","text":""},{"location":"arrays/sliding_window_variable/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0003 - Longest Substring Without Repeating Characters (Medium)</li> <li>0424 - Longest Repeating Character Replacement (Medium)</li> <li>1208 - Get Equal Substrings Within Budget (Medium)</li> <li>1004 - Max Consecutive Ones III (Medium)</li> <li>0438 - Find All Anagrams in a String (Medium)</li> <li>0992 - Subarrays with K Different Integers (Hard)</li> <li>2024 - Maximize the Confusion of an Exam (Medium)</li> </ol>"},{"location":"arrays/sliding_window_variable/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(len(s)):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"arrays/sliding_window_variable/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"arrays/sliding_window_variable/#1208-get-equal-substrings-within-budget","title":"1208. Get Equal Substrings Within Budget","text":"<pre><code># Sliding Window - Variable\ndef equalSubstring(s: str, t: str, maxCost: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    currentCost = 0\n\n    for right in range(len(s)):\n        currentCost += abs(ord(s[right]) - ord(t[right]))\n\n        while currentCost &gt; maxCost:\n            currentCost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcd\"\nt = \"bcdf\"\nmaxCost = 3\nprint(equalSubstring(s, t, maxCost))  # 3\n</code></pre>"},{"location":"arrays/sliding_window_variable/#1004-max-consecutive-ones-iii","title":"1004. Max Consecutive Ones III","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef longestOnes(nums: List[int], k: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count &gt; k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\nnums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]\nk = 2\nprint(longestOnes(nums, k))  # 6\n</code></pre>"},{"location":"arrays/sliding_window_variable/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"arrays/sliding_window_variable/#992-subarrays-with-k-different-integers","title":"992. Subarrays with K Different Integers","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef subarraysWithKDistinct(nums: List[int], k: int) -&gt; int:\n    def atMost(k: int) -&gt; int:\n        count = 0\n        left = 0\n        freq = {}\n\n        for right in range(len(nums)):\n            if nums[right] not in freq:\n                freq[nums[right]] = 0\n            freq[nums[right]] += 1\n\n            while len(freq) &gt; k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n\n            count += right - left + 1\n\n        return count\n\n    return atMost(k) - atMost(k - 1)\n\n\nnums = [1, 2, 1, 2, 3]\nk = 2\nprint(subarraysWithKDistinct(nums, k))  # 7\n</code></pre>"},{"location":"arrays/sliding_window_variable/#2024-maximize-the-confusion-of-an-exam","title":"2024. Maximize the Confusion of an Exam","text":"<pre><code># Sliding Window - Variable\ndef maxConsecutiveAnswers1(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left = 0\n        count = 0  # num of str != char\n\n        for right in range(len(s)):\n            if s[right] != char:\n                count += 1\n\n            while count &gt; k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# Sliding Window - Variable\ndef maxConsecutiveAnswers2(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left, right = 0, 0\n\n        while right &lt; len(s):\n            if s[right] != char:\n                k -= 1\n\n            while k &lt; 0:\n                if s[left] != char:\n                    k += 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n            right += 1\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# |-----------------|---------|------------|\n# |  Approach       |  Time   |  Space     |\n# |-----------------|---------|------------|\n# | Sliding Window  |  O(N)   |  O(1)      |\n# |-----------------|---------|------------|\n\n\nanswerKey = \"TTFF\"\nk = 2\nprint(maxConsecutiveAnswers1(answerKey, k))  # 4\nprint(maxConsecutiveAnswers2(answerKey, k))  # 4\n</code></pre>"},{"location":"backtracking/","title":"Backtracking","text":""},{"location":"backtracking/backtracking_board/","title":"Backtracking - Board","text":""},{"location":"backtracking/backtracking_board/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0051 - N-Queens (Hard)</li> <li>0037 - Sudoku Solver (Hard)</li> <li>0079 - Word Search (Medium)</li> <li>0212 - Word Search II (Hard)</li> </ol>"},{"location":"backtracking/backtracking_board/#51-n-queens","title":"51. N-Queens","text":"<pre><code>from typing import List\n\n\n# Backtracking - Board\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    result = []\n    chessboard = [\".\" * n for _ in range(n)]\n\n    def backtracking(row):\n        if row == n:\n            result.append(chessboard[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, chessboard):\n                chessboard[row] = (\n                    chessboard[row][:col] + \"Q\" + chessboard[row][col + 1 :]\n                )\n                backtracking(row + 1)\n                chessboard[row] = (\n                    chessboard[row][:col] + \".\" + chessboard[row][col + 1 :]\n                )\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    backtracking(0)\n\n    return [[\"\".join(row) for row in solution] for solution in result]\n\n\nprint(solveNQueens(4))\n# [['.Q..', '...Q', 'Q...', '..Q.'],\n#  ['..Q.', 'Q...', '...Q', '.Q..']]\n</code></pre>"},{"location":"backtracking/backtracking_board/#37-sudoku-solver","title":"37. Sudoku Solver","text":"<pre><code>from pprint import pprint\nfrom typing import List\n\n\n# Backtracking - Board\ndef solveSudoku(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n\n    def backtracking(board: List[List[str]]) -&gt; bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] != \".\":\n                    continue\n                for k in range(1, 10):\n                    if is_valid(i, j, k, board):\n                        board[i][j] = str(k)\n                        if backtracking(board):\n                            return True\n                        board[i][j] = \".\"\n                return False\n        return True\n\n    def is_valid(row: int, col: int, val: int, board: List[List[str]]) -&gt; bool:\n        for i in range(9):\n            if board[row][i] == str(val):\n                return False\n        for j in range(9):\n            if board[j][col] == str(val):\n                return False\n        start_row = (row // 3) * 3\n        start_col = (col // 3) * 3\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == str(val):\n                    return False\n        return True\n\n    backtracking(board)\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\n\nsolveSudoku(board)\npprint(board)\n# [['5', '3', '4', '6', '7', '8', '9', '1', '2'],\n#  ['6', '7', '2', '1', '9', '5', '3', '4', '8'],\n#  ['1', '9', '8', '3', '4', '2', '5', '6', '7'],\n#  ['8', '5', '9', '7', '6', '1', '4', '2', '3'],\n#  ['4', '2', '6', '8', '5', '3', '7', '9', '1'],\n#  ['7', '1', '3', '9', '2', '4', '8', '5', '6'],\n#  ['9', '6', '1', '5', '3', '7', '2', '8', '4'],\n#  ['2', '8', '7', '4', '1', '9', '6', '3', '5'],\n#  ['3', '4', '5', '2', '8', '6', '1', '7', '9']]\n</code></pre>"},{"location":"backtracking/backtracking_board/#79-word-search","title":"79. Word Search","text":"<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"backtracking/backtracking_board/#212-word-search-ii","title":"212. Word Search II","text":"<pre><code>from typing import List\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\n    def addWord(self, word):\n        node = self\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.isWord = True\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for w in words:\n        root.addWord(w)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"backtracking/backtracking_combinations/","title":"Backtracking - Combinations","text":""},{"location":"backtracking/backtracking_combinations/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0077 - Combinations (Medium)</li> <li>0017 - Letter Combinations of a Phone Number (Medium)</li> <li>0039 - Combination Sum (Medium)</li> <li>0040 - Combination Sum II (Medium)</li> <li>0216 - Combination Sum III (Medium)</li> </ol>"},{"location":"backtracking/backtracking_combinations/#77-combinations","title":"77. Combinations","text":"<pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    path = []\n    result = []\n\n    def backtracking(start):\n        if len(path) == k:\n            result.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(start=1)\n\n    return result\n\n\n# 2. Itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre>"},{"location":"backtracking/backtracking_combinations/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<pre><code>from typing import List\n\n\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letterMap = [\n        \"\",  # 0\n        \"\",  # 1\n        \"abc\",  # 2\n        \"def\",  # 3\n        \"ghi\",  # 4\n        \"jkl\",  # 5\n        \"mno\",  # 6\n        \"pqrs\",  # 7\n        \"tuv\",  # 8\n        \"wxyz\",  # 9\n    ]\n    result = []\n\n    def backtracking(index, s):\n        if index == len(digits):\n            result.append(s)\n            return None\n\n        digit = int(digits[index])\n        letters = letterMap[digit]\n\n        for i in range(len(letters)):\n            backtracking(index + 1, s + letters[i])\n\n    if len(digits) == 0:\n        return result\n\n    backtracking(0, \"\")\n\n    return result\n\n\nprint(letterCombinations(\"23\"))\n# ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n</code></pre>"},{"location":"backtracking/backtracking_combinations/#39-combination-sum","title":"39. Combination Sum","text":"<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"backtracking/backtracking_combinations/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"backtracking/backtracking_combinations/#216-combination-sum-iii","title":"216. Combination Sum III","text":"<pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combinationSum3(k: int, n: int) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(start):\n        if len(path) == k and sum(path) == n:\n            result.append(path[:])\n            return\n\n        for i in range(start, 10):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(1)\n\n    return result\n\n\n# 2. Itertools\ndef combinationSum3Itertools(k: int, n: int) -&gt; List[List[int]]:\n    combinations = itertools.combinations(range(1, 10), k)\n    result = []\n\n    for i in combinations:\n        if sum(i) == n:\n            result.append(i)\n\n    return result\n\n\nprint(combinationSum3(3, 7))  # [[1, 2, 4]]\nprint(combinationSum3Itertools(3, 7))  # [(1, 2, 4)]\n</code></pre>"},{"location":"backtracking/backtracking_partitions/","title":"Backtracking - Partitions","text":""},{"location":"backtracking/backtracking_partitions/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0131 - Palindrome Partitioning (Medium)</li> <li>0093 - Restore IP Addresses (Medium)</li> </ol>"},{"location":"backtracking/backtracking_partitions/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<pre><code>from typing import List\n\n\ndef partition(s: str) -&gt; List[List[str]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if startIndex == len(s):\n            result.append(path[:])\n            return None\n\n        for i in range(startIndex, len(s)):\n            if is_palindrome(s, startIndex, i):\n                path.append(s[startIndex : i + 1])\n                backtracking(i + 1)\n                path.pop()\n\n    def is_palindrome(s: str, start, end) -&gt; bool:\n        while start &lt; end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n\n        return True\n\n    backtracking(0)\n\n    return result\n\n\nprint(partition(\"aab\"))  # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"backtracking/backtracking_partitions/#93-restore-ip-addresses","title":"93. Restore IP Addresses","text":"<pre><code>from typing import List\n\n\ndef restoreIpAddresses(s: str) -&gt; List[str]:\n    result = []\n\n    def backtracking(start_index, point_num, current, result):\n        # stop condition\n        if point_num == 3:\n            if is_valid(s, start_index, len(s) - 1):\n                current += s[start_index:]\n                result.append(current)\n            return\n\n        for i in range(start_index, len(s)):\n            if is_valid(s, start_index, i):\n                sub = s[start_index : i + 1]\n                backtracking(i + 1, point_num + 1, current + sub + \".\", result)\n            else:\n                break\n\n    def is_valid(s, start, end):\n        if start &gt; end:\n            return False\n\n        if s[start] == \"0\" and start != end:\n            return False\n\n        num = 0\n        for i in range(start, end + 1):\n            if not s[i].isdigit():\n                return False\n            num = num * 10 + int(s[i])\n            if num &gt; 255:\n                return False\n        return True\n\n    backtracking(0, 0, \"\", result)\n\n    return result\n\n\nprint(restoreIpAddresses(\"25525511135\"))\n# ['255.255.11.135', '255.255.111.35']\n</code></pre>"},{"location":"backtracking/backtracking_permutations/","title":"Backtracking - Permutations","text":""},{"location":"backtracking/backtracking_permutations/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0046 - Permutations (Medium)</li> <li>0047 - Permutations II (Medium)</li> </ol>"},{"location":"backtracking/backtracking_permutations/#46-permutations","title":"46. Permutations","text":"<pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"backtracking/backtracking_permutations/#47-permutations-ii","title":"47. Permutations II","text":"<pre><code>from typing import List\n\n\ndef permuteUnique(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permuteUnique([1, 1, 2]))\n# [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n</code></pre>"},{"location":"backtracking/backtracking_subsets/","title":"Backtracking - Subsets","text":""},{"location":"backtracking/backtracking_subsets/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0078 - Subsets (Medium)</li> <li>0090 - Subsets II (Medium)</li> <li>0491 - Non-decreasing Subsequences (Medium)</li> </ol>"},{"location":"backtracking/backtracking_subsets/#78-subsets","title":"78. Subsets","text":"<pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"backtracking/backtracking_subsets/#90-subsets-ii","title":"90. Subsets II","text":"<pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"backtracking/backtracking_subsets/#491-non-decreasing-subsequences","title":"491. Non-decreasing Subsequences","text":"<pre><code>from typing import List\n\n\ndef findSubsequences(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if len(path) &gt; 1:\n            result.append(path[:])\n\n        used = set()\n        for i in range(startIndex, len(nums)):\n\n            if (path and nums[i] &lt; path[-1]) or nums[i] in used:\n                continue\n\n            used.add(nums[i])\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(0)\n\n    return result\n\n\nprint(findSubsequences([4, 6, 7, 7]))\n# [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]\n</code></pre>"},{"location":"challenge/","title":"Challenges","text":""},{"location":"challenge/202409_cn/","title":"2024 September Challenge - CN","text":"<ol> <li>1450 - Number of Students Doing Homework at a Given Time (Easy)</li> <li>2024 - Maximize the Confusion of an Exam</li> <li>2708 - Maximum Strength of a Group</li> <li>2860 - Happy Students</li> <li>3174 - Clear Digits (Easy)</li> <li>3176 - Find the Maximum Length of a Good Subsequence I (Medium)</li> <li>3177 - Find the Maximum Length of a Good Subsequence II (Hard)</li> <li>0977 - Squares of a Sorted Array (Easy)</li> <li>2181 - Merge Nodes in Between Zeros (Medium)</li> <li>2552 - Count Increasing Quadruplets (Hard)</li> <li>2555 - Maximize Win From Two Segments (Medium)</li> <li>2576 - Find the Maximum Number of Marked Indices (Medium)</li> <li>2398 - Maximum Number of Robots Within Budget (Hard)</li> <li>2390 - Removing Stars From a String (Medium)</li> <li>2848 - Points That Intersect With Cars (Easy)</li> <li>1184 - Distance Between Bus Stops (Easy)</li> </ol>"},{"location":"challenge/202409_cn/#1450-number-of-students-doing-homework-at-a-given-time","title":"1450. Number of Students Doing Homework at a Given Time","text":"<pre><code>from typing import List\n\n\n# Brute Force\ndef busyStudent(\n    startTime: List[int], endTime: List[int], queryTime: int\n) -&gt; int:\n    num = 0\n    for i, j in zip(startTime, endTime):\n        if i &lt;= queryTime &lt;= j:\n            num += 1\n\n    return num\n\n\n# |----------|---------|----------|\n# | Approach |  Time   |  Space   |\n# |----------|---------|----------|\n# |   BF     |  O(n)   |  O(1)    |\n# |----------|---------|----------|\n\n\nstartTime = [1, 2, 3]\nendTime = [3, 2, 7]\nqueryTime = 4\n\nprint(busyStudent(startTime, endTime, queryTime))  # 1\n</code></pre>"},{"location":"challenge/202409_cn/#2024-maximize-the-confusion-of-an-exam","title":"2024. Maximize the Confusion of an Exam","text":"<pre><code># Sliding Window - Variable\ndef maxConsecutiveAnswers1(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left = 0\n        count = 0  # num of str != char\n\n        for right in range(len(s)):\n            if s[right] != char:\n                count += 1\n\n            while count &gt; k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# Sliding Window - Variable\ndef maxConsecutiveAnswers2(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left, right = 0, 0\n\n        while right &lt; len(s):\n            if s[right] != char:\n                k -= 1\n\n            while k &lt; 0:\n                if s[left] != char:\n                    k += 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n            right += 1\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# |-----------------|---------|------------|\n# |  Approach       |  Time   |  Space     |\n# |-----------------|---------|------------|\n# | Sliding Window  |  O(N)   |  O(1)      |\n# |-----------------|---------|------------|\n\n\nanswerKey = \"TTFF\"\nk = 2\nprint(maxConsecutiveAnswers1(answerKey, k))  # 4\nprint(maxConsecutiveAnswers2(answerKey, k))  # 4\n</code></pre>"},{"location":"challenge/202409_cn/#2708-maximum-strength-of-a-group","title":"2708. Maximum Strength of a Group","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxStrength(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    cur_min, cur_max = nums[0], nums[0]\n\n    for i, num in enumerate(nums):\n        if i == 0:\n            continue\n\n        temp_min = min(cur_min, num, num * cur_min, num * cur_max)\n        temp_max = max(cur_max, num, num * cur_min, num * cur_max)\n        cur_min, cur_max = temp_min, temp_max\n\n    return cur_max\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  DP        |  O(N)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnums = [3, -1, -5, 2, 5, -9]\nprint(maxStrength(nums))  # 1350\n</code></pre>"},{"location":"challenge/202409_cn/#2860-happy-students","title":"2860. Happy Students","text":"<pre><code>from typing import List\n\n\n# Sort\ndef countWays(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    count = 0\n\n    if nums[0] &gt; 0:\n        count += 1\n\n    for x in range(1, n):\n        if nums[x - 1] &lt; x &lt; nums[x]:\n            count += 1\n\n    if nums[n - 1] &lt; n:\n        count += 1\n\n    return count\n\n\nnums = [6, 0, 3, 3, 6, 7, 2, 7]\nprint(countWays(nums))  # 3\n</code></pre>"},{"location":"challenge/202409_cn/#3174-clear-digits","title":"3174. Clear Digits","text":"<pre><code># Stack\ndef clearDigits(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char.isdigit():\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"abc\"\nprint(clearDigits(s))  # abc\n</code></pre>"},{"location":"challenge/202409_cn/#3176-find-the-maximum-length-of-a-good-subsequence-i","title":"3176. Find the Maximum Length of a Good Subsequence I","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DP\ndef maximumLength(nums: List[int], k: int) -&gt; int:\n    frequency = defaultdict(lambda: [0 for _ in range(k + 1)])\n    dp = [0 for _ in range(k + 1)]\n\n    for num in nums:\n        f = frequency[num]\n        for j in range(k, -1, -1):\n            f[j] += 1\n            if j &gt; 0:\n                f[j] = max(f[j], dp[j - 1] + 1)\n            dp[j] = max(f[j], dp[j])\n\n    return dp[-1]\n\n\nnums = [1, 2, 1, 1, 3]\nk = 2\nprint(maximumLength(nums, k))  # 4\n</code></pre>"},{"location":"challenge/202409_cn/#3177-find-the-maximum-length-of-a-good-subsequence-ii","title":"3177. Find the Maximum Length of a Good Subsequence II","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DP\ndef maximumLength(nums: List[int], k: int) -&gt; int:\n    count = [defaultdict(int) for _ in range(k + 1)]\n    result = [0 for _ in range(k + 1)]\n\n    for num in nums:\n        for c in range(k, -1, -1):\n            count[c][num] = (\n                max(count[c][num], result[c - 1] if c &gt; 0 else 0) + 1\n            )\n            result[c] = max(result[c], count[c][num])\n\n    return max(result)\n\n\nnums = [1, 2, 1, 1, 3]\nk = 2\nprint(maximumLength(nums, k))  # 4\n</code></pre>"},{"location":"challenge/202409_cn/#0977-squares-of-a-sorted-array","title":"0977. Squares of a Sorted Array","text":"<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    \"\"\"Returns the squares of the sorted array.\"\"\"\n    n = len(nums)\n    result = [0 for _ in range(n)]\n\n    left, right, tail = 0, n - 1, n - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[tail] = nums[left] ** 2\n            left += 1\n        else:\n            result[tail] = nums[right] ** 2\n            right -= 1\n        tail -= 1\n\n    return result\n\n\n# |---------------------|------|-------|\n# | Approach            | Time | Space |\n# |---------------------|------|-------|\n# | Left Right Pointers | O(n) | O(n)  |\n# |---------------------|------|-------|\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre>"},{"location":"challenge/202409_cn/#2181-merge-nodes-in-between-zeros","title":"2181. Merge Nodes in Between Zeros","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# Linked List\ndef mergeNodes(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    head = head.next\n    temp = 0\n\n    while head.next:\n        if head.val == 0:\n            cur.next = ListNode(val=temp)\n            cur = cur.next\n            temp = 0\n        else:\n            temp += head.val\n\n        head = head.next\n\n    if temp != 0:\n        cur.next = ListNode(val=temp)\n\n    return dummy.next\n\n\nroot = ListNode.create([0, 3, 1, 0, 4, 5, 2, 0])\nprint(root)  # 0 -&gt; 3 -&gt; 1 -&gt; 0 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 0\nprint(mergeNodes(root))  # 4 -&gt; 11\n</code></pre>"},{"location":"challenge/202409_cn/#2552-count-increasing-quadruplets","title":"2552. Count Increasing Quadruplets","text":"<pre><code>from typing import List\n\n\n# DP\ndef countQuadruplets(nums: List[int]) -&gt; int:\n    n = len(nums)\n    great = [[0] * (n + 1) for _ in range(n)]\n    less = [0 for _ in range(n + 1)]\n\n    for k in range(n - 2, 1, -1):\n        great[k] = great[k + 1].copy()\n        for x in range(1, nums[k + 1]):\n            great[k][x] += 1\n\n    ans = 0\n\n    for j in range(1, n - 1):\n        for x in range(nums[j - 1] + 1, n + 1):\n            less[x] += 1\n        for k in range(j + 1, n - 1):\n            if nums[j] &gt; nums[k]:\n                ans += less[nums[k]] * great[k][nums[j]]\n    return ans\n\n\nnums = [1, 3, 2, 4, 5]\nprint(countQuadruplets(nums))  # 2\n</code></pre>"},{"location":"challenge/202409_cn/#2555-maximize-win-from-two-segments","title":"2555. Maximize Win From Two Segments","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef maximizeWin(prizePositions: List[int], k: int) -&gt; int:\n    n = len(prizePositions)\n\n    if 2 * k &gt;= prizePositions[-1] - prizePositions[0]:\n        return n\n\n    ans = left = 0\n    mx = [0] * (n + 1)\n\n    for right, p in enumerate(prizePositions):\n        while p - prizePositions[left] &gt; k:\n            left += 1\n        ans = max(ans, mx[left] + right - left + 1)\n        mx[right + 1] = max(mx[right], right - left + 1)\n\n    return ans\n\n\nprizePositions = [1, 1, 2, 2, 3, 3, 5]\nk = 2\nprint(maximizeWin(prizePositions, k))  # 7\n</code></pre>"},{"location":"challenge/202409_cn/#2576-find-the-maximum-number-of-marked-indices","title":"2576. Find the Maximum Number of Marked Indices","text":"<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef maxNumOfMarkedIndices(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    slow, fast = 0, n // 2\n    count = 0\n\n    while slow &lt; n // 2 and fast &lt; n:\n        if nums[fast] &gt;= 2 * nums[slow]:\n            count += 2\n            slow += 1\n        fast += 1\n\n    return count\n\n\nnums = [3, 5, 2, 4]\nprint(maxNumOfMarkedIndices(nums))  # 2\n</code></pre>"},{"location":"challenge/202409_cn/#2398-maximum-number-of-robots-within-budget","title":"2398. Maximum Number of Robots Within Budget","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maximumRobots(\n    chargeTimes: List[int], runningCosts: List[int], budget: int\n) -&gt; int:\n    ans = sum_cost = left = 0\n    q = deque()\n\n    for right, (time, cost) in enumerate(zip(chargeTimes, runningCosts)):\n        # 1. Add\n        while q and time &gt;= chargeTimes[q[-1]]:\n            q.pop()\n        q.append(right)\n        sum_cost += cost\n\n        # 2. Remove\n        while q and chargeTimes[q[0]] + (right - left + 1) * sum_cost &gt; budget:\n            if q[0] == left:\n                q.popleft()\n            sum_cost -= runningCosts[left]\n            left += 1\n\n        # 3. Update\n        ans = max(ans, right - left + 1)\n    return ans\n\n\nchargeTimes = [3, 6, 1, 3, 4]\nrunningCosts = [2, 1, 3, 4, 5]\nbudget = 25\nprint(maximumRobots(chargeTimes, runningCosts, budget))  # 3\n</code></pre>"},{"location":"challenge/202409_cn/#2390-removing-stars-from-a-string","title":"2390. Removing Stars From a String","text":"<pre><code># Stack\ndef removeStars(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char == \"*\":\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"leet**cod*e\"\nprint(removeStars(s))  # \"lecoe\"\n</code></pre>"},{"location":"challenge/202409_cn/#2848-points-that-intersect-with-cars","title":"2848. Points That Intersect With Cars","text":"<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Differnce Array\ndef numberOfPoints(nums: List[List[int]]) -&gt; int:\n    max_end = max(end for _, end in nums)\n\n    diff = [0] * (max_end + 2)\n\n    for start, end in nums:\n        diff[start] += 1\n        diff[end + 1] -= 1\n\n    return sum(s &gt; 0 for s in accumulate(diff))\n\n\nnums = [[3, 6], [1, 5], [4, 7]]\nprint(numberOfPoints(nums))  # 7\n</code></pre>"},{"location":"challenge/202409_cn/#1184-distance-between-bus-stops","title":"1184. Distance Between Bus Stops","text":"<pre><code>from typing import List\n\n\n# Simulation\ndef distanceBetweenBusStops(\n    distance: List[int], start: int, destination: int\n) -&gt; int:\n    if start &gt; destination:\n        start, destination = destination, start\n\n    clock = sum(distance[start:destination])\n    counter = sum(distance) - clock\n\n    return min(clock, counter)\n\n\ndistance = [1, 2, 3, 4]\nstart = 0\ndestination = 1\nprint(distanceBetweenBusStops(distance, start, destination))  # 1\n</code></pre>"},{"location":"challenge/202410_cn/","title":"2024 October Challenge - CN","text":""},{"location":"challenge/202410_cn/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0983 - Minimum Cost For Tickets (Medium) Dynamic Programming</li> <li>1870 - Minimum Speed to Arrive on Time (Medium) Binary Search</li> </ol>"},{"location":"challenge/202410_cn/#0983-minimum-cost-for-tickets","title":"0983. Minimum Cost For Tickets","text":"<ul> <li>Dynamic Programming - Memoization</li> <li>Return the minimum cost to cover all the days in <code>days</code>.</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef mincostTickets(days: List[int], costs: List[int]) -&gt; int:\n    last = days[-1]\n    dayset = set(days)\n    dp = [0 for _ in range(last + 1)]\n\n    for i in range(1, last + 1):\n        if i not in dayset:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = min(\n                dp[i - 1] + costs[0],\n                dp[max(0, i - 7)] + costs[1],\n                dp[max(0, i - 30)] + costs[2],\n            )\n\n    return dp[last]\n\n\ndays = [1, 4, 6, 7, 8, 20]\ncosts = [2, 7, 15]\nprint(mincostTickets(days, costs))  # 11\n</code></pre>"},{"location":"challenge/202410_cn/#1870-minimum-speed-to-arrive-on-time","title":"1870. Minimum Speed to Arrive on Time","text":"<ul> <li>Binary Search</li> <li>Return the minimum integer speed such that you can reach the destination on time.</li> </ul> <pre><code>import math\nfrom typing import List\n\n\n# Binary Search\ndef minSpeedOnTime(dist: List[int], hour: float) -&gt; int:\n    if hour &lt; len(dist) - 1:\n        return -1\n\n    def time_needed(speed):\n        total_time = 0\n        for i in range(len(dist) - 1):\n            total_time += math.ceil(dist[i] / speed)\n        total_time += dist[-1] / speed\n        return total_time\n\n    left, right = 1, 10**7\n    result = -1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if time_needed(mid) &lt;= hour:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n\ndist = [1, 3, 2]\nhour = 6\nprint(minSpeedOnTime(dist, hour))  # 1\n</code></pre>"},{"location":"design/","title":"Design","text":""},{"location":"design/design/","title":"Design","text":""},{"location":"design/design/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0146 - LRU Cache (Medium)</li> <li>0355 - Design Twitter (Medium)</li> <li>0588 - Design In-Memory File System (Hard)</li> <li>0460 - LFU Cache (Hard)</li> <li>1166 - Design File System (Medium)</li> <li>0380 - Insert Delete GetRandom O(1) (Medium)</li> <li>0362 - Design Hit Counter (Medium)</li> <li>0297 - Serialize and Deserialize Binary Tree (Hard)</li> <li>0622 - Design Circular Queue (Medium)</li> <li>0353 - Design Snake Game (Medium)</li> <li>1244 - Design A Leaderboard (Medium)</li> </ol>"},{"location":"design/design/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> </ul> <ul> <li>Data structure<ul> <li>Doubly Linked List: to store the key-value pairs.</li> <li>Hash Map: to store the key-node pairs.</li> </ul> </li> </ul> <pre><code>class ListNode:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_node_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_node_to_last(self, node):\n        self.remove_node(node)\n        self.add_node_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_node_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_node_to_last(node)\n            return\n\n        if len(self.cache) == self.capacity:\n            del self.cache[self.head.next.key]\n            self.remove_node(self.head.next)\n\n        node = ListNode(key, value)\n        self.cache[key] = node\n        self.add_node_to_last(node)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   LRU       |      O(1)       |    O(n)      |\n# |-------------|-----------------|--------------|\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\n</code></pre>"},{"location":"design/design/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li>Similar question: 23. Merge K Sorted Lists (Hard)</li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"design/design/#588-design-in-memory-file-system","title":"588. Design In-Memory File System","text":"<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre>"},{"location":"design/design/#460-lfu-cache","title":"460. LFU Cache","text":"<pre><code>from collections import defaultdict\n\n\nclass Node:\n    def __init__(self, key: int, value: int):\n        self.key = key\n        self.value = value\n        self.freq = 1\n\n\nclass DoubleLinkedList:\n    def __init__(self):\n        self.head = Node(0, 0)  # dummy head\n        self.tail = Node(0, 0)  # dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def insert(self, node: Node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n\n    def remove(self, node: Node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def pop(self) -&gt; Node:\n        if self.head.next == self.tail:\n            return None\n        node = self.tail.prev\n        self.remove(node)\n        return node\n\n    def is_empty(self) -&gt; bool:\n        return self.head.next == self.tail\n\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_table = {}\n        self.freq_table = defaultdict(DoubleLinkedList)\n        self.size = 0\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.key_table:\n            return -1\n        node = self.key_table[key]\n        self._update(node)\n        return node.value\n\n    def put(self, key: int, value: int) -&gt; None:\n        if self.capacity == 0:\n            return\n        if key in self.key_table:\n            node = self.key_table[key]\n            node.value = value\n            self._update(node)\n        else:\n            if self.size == self.capacity:\n                list_to_remove = self.freq_table[self.min_freq]\n                node_to_remove = list_to_remove.pop()\n                del self.key_table[node_to_remove.key]\n                self.size -= 1\n            new_node = Node(key, value)\n            self.key_table[key] = new_node\n            self.freq_table[1].insert(new_node)\n            self.min_freq = 1\n            self.size += 1\n\n    def _update(self, node: Node):\n        freq = node.freq\n        self.freq_table[freq].remove(node)\n        if self.freq_table[freq].is_empty() and freq == self.min_freq:\n            self.min_freq += 1\n        node.freq += 1\n        self.freq_table[node.freq].insert(node)\n\n\nobj = LFUCache(2)\nobj.put(1, 1)\nobj.put(2, 2)\nprint(obj.get(1))  # 1\nobj.put(3, 3)\nprint(obj.get(2))  # -1\n</code></pre>"},{"location":"design/design/#1166-design-file-system","title":"1166. Design File System","text":"<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self, name):\n        self.name = name\n        self.children = defaultdict(TrieNode)\n        self.value = -1\n\n\n# Trie\nclass FileSystem:\n    def __init__(self):\n        self.root = TrieNode(\"\")\n\n    def createPath(self, path: str, value: int) -&gt; bool:\n        paths = path.split(\"/\")[1:]\n        cur = self.root\n\n        for idx, path in enumerate(paths):\n            if path not in cur.children:\n                if idx == len(paths) - 1:\n                    cur.children[path] = TrieNode(path)\n                else:\n                    return False\n            cur = cur.children[path]\n\n        if cur.value != -1:\n            return False\n        cur.value = value\n        return True\n\n    def get(self, path: str) -&gt; int:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n\n        for path in paths:\n            if path not in cur.children:\n                return -1\n            cur = cur.children[path]\n\n        return cur.value\n\n\n# Your FileSystem object will be instantiated and called as such:\npath = \"/a\"\nvalue = 1\nobj = FileSystem()\nprint(obj.createPath(path, value))  # False\nprint(obj.get(path))  # 1\n</code></pre>"},{"location":"design/design/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.dict = {}\n        self.list = []\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.dict:\n            return False\n        self.dict[val] = len(self.list)\n        self.list.append(val)\n\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.dict:\n            return False\n        last_element = self.list[-1]\n        idx = self.dict[val]\n        self.list[idx] = last_element\n        self.dict[last_element] = idx\n        self.list.pop()\n        del self.dict[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.list)\n\n\nobj = RandomizedSet()\nprint(obj.insert(1))  # True\nprint(obj.remove(2))  # False\nprint(obj.insert(2))  # True\nprint(obj.getRandom())  # 1 or 2\nprint(obj.remove(1))  # True\n</code></pre>"},{"location":"design/design/#362-design-hit-counter","title":"362. Design Hit Counter","text":""},{"location":"design/design/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"design/design/#622-design-circular-queue","title":"622. Design Circular Queue","text":""},{"location":"design/design/#353-design-snake-game","title":"353. Design Snake Game","text":""},{"location":"design/design/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard","text":""},{"location":"design/design_patterns/","title":"Design Patterns","text":""},{"location":"design/design_patterns/#creational-patterns","title":"Creational Patterns","text":""},{"location":"design/design_patterns/#factory-method","title":"Factory Method","text":""},{"location":"dp/","title":"Dynamic Programming","text":""},{"location":"dp/#dp-resources","title":"DP Resources","text":"<ul> <li>[Leetcode Discuss] Solved all dynamic programming (dp) problems in 7 months</li> </ul>"},{"location":"dp/#steps-to-solve-dp-problems","title":"Steps to Solve DP Problems","text":"<ol> <li>Define the <code>dp</code> array and its meaning.</li> <li>Define the <code>dp</code> formula.</li> <li>Initialize the <code>dp</code> array.</li> <li>Determine the traversal direction.</li> <li>Derive the <code>dp</code> array.</li> </ol>"},{"location":"dp/dp_2d/","title":"Dynamic Programming - 2 Dimensional Table","text":""},{"location":"dp/dp_2d/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0118 - Pascal's Triangle (Easy)</li> <li>0119 - Pascal's Triangle II (Easy)</li> <li>0062 - Unique Paths (Medium)</li> <li>0063 - Unique Paths II (Medium)</li> </ol>"},{"location":"dp/dp_2d/#118-pascals-triangle","title":"118. Pascal's Triangle","text":"<ul> <li>Generate the first <code>numRows</code> of Pascal's triangle.</li> </ul> <pre><code>                 numRows    index\n     1              1         0\n    1 1             2         1\n   1 2 1            3         2\n  1 3 3 1           4         3\n 1 4 6 4 1          5         4\n</code></pre> <pre><code>from typing import List\n\n\ndef generate(numRows: int) -&gt; List[List[int]]:\n    dp = [[1] * i for i in range(1, numRows + 1)]\n\n    if numRows &lt;= 2:\n        return dp\n\n    for i in range(2, numRows):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp\n\n\nprint(generate(numRows=5))\n#     [[1],\n#    [1, 1],\n#   [1, 2, 1],\n#  [1, 3, 3, 1],\n# [1, 4, 6, 4, 1]]\n</code></pre>"},{"location":"dp/dp_2d/#119-pascals-triangle-ii","title":"119. Pascal's Triangle II","text":"<ul> <li>Return the <code>rowIndex</code>th row of Pascal's triangle.</li> </ul> <pre><code>from typing import List\n\n\ndef getRow(rowIndex: int) -&gt; List[int]:\n    # TC: O(n^2)\n    # SC: O(n^2)\n    rowNum = rowIndex + 1\n    dp = [[0] * i for i in range(1, rowNum + 1)]\n\n    for i in range(rowNum):\n        dp[i][0], dp[i][i] = 1, 1\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n\n    return dp[rowIndex]\n\n\nprint(getRow(rowIndex=3))  # [1, 3, 3, 1]\n</code></pre>"},{"location":"dp/dp_2d/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"dp/dp_2d/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid with obstacles.</li> </ul> <pre><code>from typing import List\n\n\n# DP - 2D\ndef uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -&gt; int:\n    if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n        return 0\n\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        if obstacleGrid[i][0] == 0:\n            dp[i][0] = 1\n        else:\n            break\n\n    for j in range(n):\n        if obstacleGrid[0][j] == 0:\n            dp[0][j] = 1\n        else:\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if obstacleGrid[i][j] == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nobstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nprint(uniquePathsWithObstacles(obstacleGrid))  # 2\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 2]]\n</code></pre>"},{"location":"dp/dp_basic/","title":"Dynamic Programming - Basic","text":""},{"location":"dp/dp_basic/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0509 - Fibonacci Number (Easy)</li> <li>0070 - Climbing Stairs (Easy)</li> <li>0746 - Min Cost Climbing Stairs (Easy)</li> <li>0198 - House Robber (Easy)</li> <li>0213 - House Robber II (Medium)</li> <li>0376 - Wiggle Subsequence (Medium)</li> <li>0343 - Integer Break (Medium)</li> <li>1025 - Divisor Game (Easy)</li> </ol>"},{"location":"dp/dp_basic/#509-fibonacci-number","title":"509. Fibonacci Number","text":"<ul> <li>Return the <code>n-th</code> Fibonacci number.</li> </ul> <pre><code># DP\ndef fibDP(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# Recursive\ndef fibRecursive(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    return fibRecursive(n - 1) + fibRecursive(n - 2)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |  Recursive  |     O(2^n)      |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nn = 10\nprint(fibDP(n))  # 55\nprint(fibRecursive(n))  # 55\n</code></pre> <ul> <li><code>dp[n]</code> stores the <code>n-th</code> Fibonacci number.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code> and <code>dp[1] = 1</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - 0 1 2 0 1 1 3 1 1 2 4 1 2 3 5 2 3 5 6 3 5 8 7 5 8 13 8 8 13 21 9 13 21 34 10 21 34 55"},{"location":"dp/dp_basic/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li>Return the number of distinct ways to reach the top of the stairs.</li> </ul> <pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre> <ul> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89"},{"location":"dp/dp_basic/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li>Return the minimum cost to reach the top of the stairs.</li> </ul> <pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre> <ul> <li><code>dp[n]</code> stores the minimum cost to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])</code>.</li> <li>Initialize <code>dp[0] = cost[0]</code> and <code>dp[1] = cost[1]</code>.</li> <li> <p>Return <code>min(dp[-1], dp[-2])</code>.</p> </li> <li> <p>Example: <code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code></p> </li> </ul> n <code>cost[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 1 - - 1 1 100 - 1 100 2 1 1 100 2 3 1 100 2 3 4 1 2 3 3 5 100 3 3 103 6 1 3 103 4 7 1 103 4 5 8 100 4 5 104 9 1 5 104 6"},{"location":"dp/dp_basic/#198-house-robber","title":"198. House Robber","text":"<ul> <li>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</li> </ul> <pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 12\n</code></pre> <ul> <li><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12"},{"location":"dp/dp_basic/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> <ul> <li> <p>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</p> </li> <li> <p>Rob from <code>0</code> to <code>n - 2</code></p> </li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10"},{"location":"dp/dp_basic/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li>Return the length of the longest wiggle subsequence.</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre> <ul> <li><code>up[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a rising wiggle.</li> <li><code>down[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a falling wiggle.</li> <li>Initialize <code>up[0] = 1</code> and <code>down[0] = 1</code>.</li> <li>Example: <code>nums = [1, 7, 4, 9, 2, 5]</code></li> </ul> <code>nums[n]</code> <code>nums[n-1]</code> <code>up[n-1]</code> <code>down[n-1]</code> <code>up[n]</code> <code>down[n]</code> 1 - - - 1 1 7 1 1 1 2 1 4 7 2 1 2 3 9 4 2 3 4 3 2 9 4 3 4 5 5 2 4 5 6 5"},{"location":"dp/dp_basic/#343-integer-break","title":"343. Integer Break","text":"<ul> <li>Return the maximum product of the integer after breaking it into at least two positive integers.</li> </ul> <pre><code>def integerBreak(n: int) -&gt; int:\n    dp = [0 for _ in range(n + 1)]\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        for j in range(2, i):\n            dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n^2)     |     O(n)     |\n# |-------------|-----------------|--------------|\n\nn = 8\nprint(integerBreak(n))  # 18\n</code></pre> <ul> <li><code>dp[i]</code> stores the maximum product of the integer <code>i</code>.</li> <li>Formula: <code>dp[i] = max(dp[i - j] * j, (i - j) * j)</code></li> </ul> dp 3 4 5 6 7 8 2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 dp[2]=1 1*1=2 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 3 3*1=3 3*2=6 3*3=9 3*4=12 3*5=15 dp[3]=2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 4 4*1=4 4*2=8 4*3=12 4*4=16 dp[4]=4 4*1=4 4*2=8 4*3=12 4*4=16 5 5*1=5 5*2=10 5*3=15 dp[5]=6 6*1=6 6*2=12 6*3=18 6 6*1=6 6*2=12 dp[6]=9 9*1=9 9*2=18 7 7*1=7 dp[7]=12 12*1=12 <code>dp[n]</code> 2 4 6 9 12 18"},{"location":"dp/dp_basic/#1025-divisor-game","title":"1025. Divisor Game","text":"<ul> <li>Return <code>True</code> if Alice wins the game, assuming both players play optimally.</li> </ul> <pre><code># DP\ndef divisorGameDP(n: int) -&gt; bool:\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\n# Math\ndef divisorGameDPMath(n: int) -&gt; bool:\n    return n % 2 == 0\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  DP         |      O(n^2)     |    O(n)      |\n# |  Math       |      O(1)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\nn = 2\nprint(divisorGameDP(n))  # True\nprint(divisorGameDPMath(n))  # True\n</code></pre> <ul> <li><code>dp[n]</code> stores the result of the game when the number is <code>n</code>.</li> <li>Initialize <code>dp[1] = False</code>.</li> </ul>"},{"location":"dp/dp_interval/","title":"Dynamic Programming - Interval","text":""},{"location":"dp/dp_interval/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0516 - Longest Palindromic Subsequence (Medium)</li> <li>0647 - Palindromic Substrings (Medium)</li> <li>0005 - Longest Palindromic Substring (Medium)</li> </ol>"},{"location":"dp/dp_interval/#516-longest-palindromic-subsequence","title":"516. Longest Palindromic Subsequence","text":"<ul> <li>Return the length of the longest palindromic subsequence in <code>s</code>.</li> </ul> <pre><code>def longestPalindromeSubseq(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    return dp[0][-1]\n\n\nprint(longestPalindromeSubseq(\"bbbab\"))  # 4\n</code></pre> <ul> <li>Bottom-up DP table</li> </ul> dp b b b a b b 1 2 3 3 4 b 0 1 2 2 3 <code>dp[i][j]</code> b 0 0 1 1 <code>dp[i+1][j-1]</code> 2 a 0 0 0 1 1 b 0 0 0 0 1"},{"location":"dp/dp_interval/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li>Return the number of palindromic substrings in <code>s</code>.</li> </ul> <pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre> <ul> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1"},{"location":"dp/dp_interval/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> <pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n    print(dp)\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"dp/dp_kadane/","title":"Dynamic Programming - Kadane's Algorithm","text":""},{"location":"dp/dp_kadane/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0053 - Maximum Subarray (Medium)</li> <li>0918 - Maximum Sum Circular Subarray (Medium)</li> <li>0152 - Maximum Product Subarray (Medium)</li> <li>0978 - Longest Turbulent Subarray (Medium)</li> <li>1186 - Maximum Subarray Sum with One Deletion (Medium)</li> </ol>"},{"location":"dp/dp_kadane/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li>Return the maximum sum of a contiguous subarray from the given array.</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"dp/dp_kadane/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li>Return the maximum sum of a circular subarray from the given array.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"dp/dp_kadane/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li>Return the maximum product of a contiguous subarray from the given array.</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"dp/dp_kadane/#978-longest-turbulent-subarray","title":"978. Longest Turbulent Subarray","text":"<ul> <li>Return the length of the longest turbulent subarray of the given array.</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxTurbulenceSize(arr: List[int]) -&gt; int:\n    n = len(arr)\n    up = [1 for _ in range(n)]\n    down = [1 for _ in range(n)]\n    maxLen = 1\n\n    for i in range(1, n):\n        if arr[i - 1] &lt; arr[i]:\n            up[i] = down[i - 1] + 1\n            down[i] = 1\n        elif arr[i - 1] &gt; arr[i]:\n            down[i] = up[i - 1] + 1\n            up[i] = 1\n        else:\n            up[i] = 1\n            down[i] = 1\n\n        maxLen = max(maxLen, up[i], down[i])\n\n    return maxLen\n\n\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxTurbulenceSize(arr))  # 5\n</code></pre>"},{"location":"dp/dp_kadane/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<ul> <li>Return the maximum sum of a contiguous subarray with at most one deletion.</li> </ul> <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maximumSum(arr: List[int]) -&gt; int:\n    dp0 = arr[0]\n    dp1 = 0\n    maxSum = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        maxSum = max(maxSum, dp0, dp1)  # update result\n\n    return maxSum\n\n\narr = [1, -2, 0, 3]\nprint(maximumSum(arr))  # 4\n</code></pre>"},{"location":"dp/dp_knapsack_01/","title":"Dynamic Programming - 0/1 Knapsack Problem","text":""},{"location":"dp/dp_knapsack_01/#01-knapsack-problem","title":"0/1 Knapsack Problem","text":"<ul> <li>The 0/1 knapsack problem is a variation of the knapsack problem where the items can be selected only once.</li> </ul> <pre><code>from typing import List\n\n\n# 01 Knapsack - Manual Initialization\ndef knapsack01_1(weights: List[int], values: List[int], capacity: int) -&gt; int:\n    n = len(weights)\n\n    # DP table initialization\n    dp = [[0] * (capacity + 1) for _ in range(n)]\n    for j in range(capacity + 1):\n        if weights[0] &lt;= j:\n            dp[0][j] = values[0]\n\n    for i in range(1, n):\n        for j in range(1, capacity + 1):\n            if weights[i] &gt; j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(\n                    dp[i - 1][j],  # skip\n                    dp[i - 1][j - weights[i]] + values[i],  # take\n                )\n\n    return dp[-1][-1]\n\n\n# 01 Knapsack - Zero Initialization\ndef knapsack01_2(weights: List[int], values: List[int], capacity: int) -&gt; int:\n    n = len(weights)\n\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, capacity + 1):\n            if weights[i - 1] &gt; j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(\n                    dp[i - 1][j],  # skip\n                    dp[i - 1][j - weights[i - 1]] + values[i - 1],  # take\n                )\n\n    return dp[-1][-1]\n\n\nweights = [1, 4, 1, 2, 12]\nvalues = [2, 10, 1, 2, 4]\ncapacity = 15\n\nprint(knapsack01_1(weights, values, capacity))  # 15\n# [[0, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2],\n#  [0, 2, 2, 2, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],\n#  [0, 2, 3, 3, 10, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],\n#  [0, 2, 3, 4, 10, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15],\n#  [0, 2, 3, 4, 10, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15]]\n\nprint(knapsack01_2(weights, values, capacity))  # 15\n# [[0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n#  [0, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2],\n#  [0, 2, 2, 2, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],\n#  [0, 2, 3, 3, 10, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],\n#  [0, 2, 3, 4, 10, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15],\n#  [0, 2, 3, 4, 10, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15]]\n</code></pre>"},{"location":"dp/dp_knapsack_01/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0416 - Partition Equal Subset Sum (Medium)</li> <li>0474 - Ones and Zeroes (Medium)</li> <li>0494 - Target Sum (Medium)</li> <li>1046 - Last Stone Weight (Easy)</li> <li>1049 - Last Stone Weight II (Medium)</li> </ol>"},{"location":"dp/dp_knapsack_01/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<pre><code>from typing import List\n\n\ndef canPartition(nums: List[int]) -&gt; bool:\n    total_sum = sum(nums)\n\n    if total_sum % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total_sum // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nnums = [1, 5, 11, 5]\nprint(canPartition(nums))  # True\n</code></pre>"},{"location":"dp/dp_knapsack_01/#474-ones-and-zeroes","title":"474. Ones and Zeroes","text":"<pre><code>from typing import List\n\n\ndef findMaxForm(strs: List[str], m: int, n: int) -&gt; int:\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        zerosNum = s.count(\"0\")\n        onesNum = len(s) - zerosNum\n\n        for i in range(m, zerosNum - 1, -1):\n            for j in range(n, onesNum - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zerosNum][j - onesNum] + 1)\n\n    return dp[m][n]\n\n\nstrs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"]\nm = 5\nn = 3\nprint(findMaxForm(strs, m, n))  # 4\n</code></pre>"},{"location":"dp/dp_knapsack_01/#494-target-sum","title":"494. Target Sum","text":"<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"dp/dp_knapsack_01/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n    dp = [0 for _ in range(target + 1)]\n\n    for stone in stones:\n        for j in range(target, stone - 1, -1):\n            dp[j] = max(dp[j], dp[j - stone] + stone)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"dp/dp_knapsack_01/#1049-last-stone-weight-ii","title":"1049. Last Stone Weight II","text":"<pre><code>from typing import List\n\n\ndef lastStoneWeightII(stones: List[int]) -&gt; int:\n    target = sum(stones) // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(stones)):\n        for j in range(target, stones[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])\n\n    result = (sum(stones) - dp[target]) - dp[target]\n\n    return result\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightII(stones))  # 1\n</code></pre>"},{"location":"dp/dp_knapsack_unbounded/","title":"Dynamic Programming - Unbounded Knapsack Problem","text":""},{"location":"dp/dp_knapsack_unbounded/#unbounded-knapsack-problem","title":"Unbounded Knapsack Problem","text":"<ul> <li>The unbounded knapsack problem is a variation of the knapsack problem where the items can be repeated.</li> </ul> <pre><code>from typing import List\n\n\n# 1. Unbounded Knapsack - first loop on capacity\ndef knapsack_unbounded_1(\n    weights: List[int], values: List[int], capacity: int\n) -&gt; int:\n    n = len(weights)\n    dp = [0] * (capacity + 1)\n\n    for i in range(capacity + 1):\n        for j in range(n):\n            if weights[j] &lt;= i:\n                dp[i] = max(dp[i], dp[i - weights[j]] + values[j])\n\n    return dp[capacity]\n\n\n# 2. Unbounded Knapsack - first loop on items\ndef knapsack_unbounded_2(\n    weights: List[int], values: List[int], capacity: int\n) -&gt; int:\n    n = len(weights)\n    dp = [0] * (capacity + 1)\n\n    for i in range(n):\n        for j in range(weights[i], capacity + 1):\n            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])\n\n    return dp[capacity]\n\n\nweights = [1, 4, 1, 2, 12]\nvalues = [2, 10, 1, 2, 4]\ncapacity = 15\n\nprint(knapsack_unbounded_1(weights, values, capacity))  # 36\n# [0, 2, 4, 6, 10, 12, 14, 16, 20, 22, 24, 26, 30, 32, 34, 36]\nprint(knapsack_unbounded_2(weights, values, capacity))  # 36\n# [0, 2, 4, 6, 10, 12, 14, 16, 20, 22, 24, 26, 30, 32, 34, 36]\n</code></pre>"},{"location":"dp/dp_knapsack_unbounded/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0139 - Word Break (Medium)</li> <li>0279 - Perfect Squares (Medium)</li> <li>0322 - Coin Change (Medium)</li> <li>0518 - Coin Change 2 (Medium)</li> <li>0377 - Combination Sum IV (Medium)</li> </ol>"},{"location":"dp/dp_knapsack_unbounded/#0139-word-break","title":"0139. Word Break","text":"<pre><code>from typing import List\n\n\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    wordSet = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[len(s)]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"dp/dp_knapsack_unbounded/#0279-perfect-squares","title":"0279. Perfect Squares","text":"<pre><code>import math\n\n\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre>"},{"location":"dp/dp_knapsack_unbounded/#0322-coin-change","title":"0322. Coin Change","text":"<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"dp/dp_knapsack_unbounded/#0518-coin-change-2","title":"0518. Coin Change 2","text":"<pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"dp/dp_knapsack_unbounded/#0377-combination-sum-iv","title":"0377. Combination Sum IV","text":"<pre><code>from typing import List\n\n\ndef combinationSum4(nums: List[int], target: int) -&gt; int:\n    dp = [0 for _ in range(target + 1)]\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i - nums[j] &gt;= 0:\n                dp[i] += dp[i - nums[j]]\n\n        return dp[target]\n\n\nnums = [1, 2, 3]\ntarget = 4\nprint(combinationSum4(nums, target))  # 7\n</code></pre>"},{"location":"dp/dp_lcs/","title":"Dynamic Programming - Longest Common Subsequence","text":""},{"location":"dp/dp_lcs/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li> <p>1143 - Longest Common Subsequence (Medium)</p> </li> <li> <p>0072 - Edit Distance (Hard)</p> </li> <li>0115 - Distinct Subsequences (Hard)</li> <li>0392 - Is Subsequence (Easy)</li> <li>0583 - Delete Operation for Two Strings (Medium)</li> <li>0674 - Longest Continuous Increasing Subsequence (Easy)</li> <li>0718 - Maximum Length of Repeated Subarray (Medium)</li> <li>1035 - Uncrossed Lines (Medium)</li> </ol>"},{"location":"dp/dp_lcs/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li>Return the length of the longest common subsequence of two strings.</li> </ul> <pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n            if res &lt; dp[i][j]:\n                res = dp[i][j]\n\n    return res\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"dp/dp_lcs/#72-edit-distance","title":"72. Edit Distance","text":"<pre><code>def minDistance(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nword1 = \"horse\"\nword2 = \"ros\"\nprint(minDistance(word1, word2))  # 3\n</code></pre>"},{"location":"dp/dp_lcs/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre>"},{"location":"dp/dp_lcs/#392-is-subsequence","title":"392. Is Subsequence","text":"<pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre>"},{"location":"dp/dp_lcs/#583-delete-operation-for-two-strings","title":"583. Delete Operation for Two Strings","text":"<pre><code># DP - LCS\ndef minDistance1(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no need to delete\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,  # delete word1[i]\n                    dp[i][j - 1] + 1,  # delete word2[j]\n                    dp[i - 1][j - 1] + 2,  # delete both\n                )\n    return dp[-1][-1]\n\n\n# DP - LCS\ndef minDistance2(word1: str, word2: str) -&gt; int:\n    def LCS(word1: str, word2: str) -&gt; int:\n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        lcs = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n                if lcs &lt; dp[i][j]:\n                    lcs = dp[i][j]\n        return lcs\n\n    lcs = LCS(word1, word2)\n    return len(word1) + len(word2) - 2 * lcs\n\n\nword1 = \"sea\"\nword2 = \"eat\"\nprint(minDistance1(word1, word2))  # 2\nprint(minDistance2(word1, word2))  # 2\n</code></pre>"},{"location":"dp/dp_lcs/#674-longest-continuous-increasing-subsequence","title":"674. Longest Continuous Increasing Subsequence","text":"<pre><code>from typing import List\n\n\ndef findLengthOfLCIS(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if nums[i] &gt; nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\n\nprint(findLengthOfLCIS([1, 3, 5, 4, 7]))  # 3\n</code></pre>"},{"location":"dp/dp_lcs/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre>"},{"location":"dp/dp_lcs/#1035-uncrossed-lines","title":"1035. Uncrossed Lines","text":"<pre><code>from typing import List\n\n\ndef maxUncrossedLines(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    num = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            if num &lt; dp[i][j]:\n                num = dp[i][j]\n\n    return num\n\n\nprint(maxUncrossedLines([1, 4, 2], [1, 2, 4]))  # 2\n</code></pre>"},{"location":"dp/dp_lis/","title":"Dynamic Programming - Longest Increasing Subsequence","text":""},{"location":"dp/dp_lis/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0300 - Longest Increasing Subsequence (Medium)</li> <li>0673 - Number of Longest Increasing Subsequence (Medium)</li> <li>0354 - Russian Doll Envelopes (Hard)</li> <li>0960 - Delete Columns to Make Sorted III (Hard)</li> <li>1671 - Minimum Number of Removals to Make Mountain Array (Hard)</li> </ol>"},{"location":"dp/dp_lis/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<pre><code>from typing import List\n\n\n# DP - LIS\ndef lengthOfLIS(nums: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(n)\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # 4\n</code></pre>"},{"location":"dp/dp_lis/#673-number-of-longest-increasing-subsequence","title":"673. Number of Longest Increasing Subsequence","text":""},{"location":"dp/dp_lis/#354-russian-doll-envelopes","title":"354. Russian Doll Envelopes","text":""},{"location":"dp/dp_lis/#960-delete-columns-to-make-sorted-iii","title":"960. Delete Columns to Make Sorted III","text":""},{"location":"dp/dp_lis/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":""},{"location":"dp/dp_stock/","title":"Dynamic Programming - Stock","text":""},{"location":"dp/dp_stock/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0121 - Best Time to Buy and Sell Stock (Easy)</li> <li>0122 - Best Time to Buy and Sell Stock II (Medium)</li> <li>0123 - Best Time to Buy and Sell Stock III (Hard)</li> <li>0188 - Best Time to Buy and Sell Stock IV (Hard)</li> <li>0309 - Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li>0714 - Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> </ol>"},{"location":"dp/dp_stock/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"dp/dp_stock/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"dp/dp_stock/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre>"},{"location":"dp/dp_stock/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre>"},{"location":"dp/dp_stock/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"dp/dp_stock/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"graph/","title":"Graph","text":""},{"location":"graph/#resources","title":"Resources","text":"<ul> <li>Graph Editor: Create and visualize graphs.</li> <li>\u3010\u9898\u5355\u3011\u56fe\u8bba\u7b97\u6cd5\uff08DFS/BFS/\u62d3\u6251\u6392\u5e8f/\u6700\u77ed\u8def/\u6700\u5c0f\u751f\u6210\u6811/\u4e8c\u5206\u56fe/\u57fa\u73af\u6811/\u6b27\u62c9\u8def\u5f84\uff09</li> </ul>"},{"location":"graph/#concepts","title":"Concepts","text":"<ul> <li>Graph</li> <li>Vertex (Node)</li> <li>Edge</li> <li>Weight</li> </ul>"},{"location":"graph/#types","title":"Types","text":"<ul> <li>Undirected graph: A graph in which edges have no direction.</li> </ul> <ul> <li>Directed graph: A graph in which edges have direction.</li> </ul> <ul> <li>Cyclic graph: A graph in which there is a cycle. A cycle is a path of edges that starts and ends at the same vertex, e.g., <code>1 -&gt; 3 -&gt; 4 -&gt; 1</code>.</li> </ul> <ul> <li>Acyclic graph: A graph in which there is no cycle.</li> </ul> <ul> <li>Directed Acyclic Graph (DAG): A directed graph with no cycles.<ul> <li>Topological sort</li> </ul> </li> </ul> <ul> <li>Weighted graph: A graph in which edges have weights.</li> </ul> <ul> <li>Connected Graph: A graph in which there is a path between every pair of vertices.</li> </ul> <ul> <li>Disconnected Graph: A graph in which there is no path between some pairs of vertices.</li> </ul> <ul> <li>Eulerian path: A path that visits every edge exactly once, e.g., <code>5 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 3</code>.</li> </ul>"},{"location":"graph/#representation","title":"Representation","text":"<ol> <li>Adjacency Matrix</li> <li>Adjacency List</li> </ol> <pre><code>flowchart LR\n1((1))\n2((2))\n3((3))\n4((4))\n1 --&gt; 3\n1 --&gt; 2\n3 --&gt; 4\n2 --&gt; 3</code></pre> <p>Adjacency Matrix</p> Node 1 Node 2 Node 3 Node 4 Node 1 0 1 1 0 Node 2 0 0 1 0 Node 3 0 0 0 1 Node 4 0 0 0 0 <pre><code>grid = [\n    [0, 1, 1, 0],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1],\n    [0, 0, 0, 0]\n]\n</code></pre> <p>Adjacency List</p> <pre><code>classDiagram\ndirection LR\nclass 1{2, 3}\nclass 2{3}\nclass 3{4}\nclass 4{-}\n1 -- 2\n2 -- 3\n3 -- 4</code></pre> <pre><code>graph = {\n    1: [2, 3],\n    2: [3],\n    3: [4],\n    4: []\n}\n</code></pre>"},{"location":"graph/#degree","title":"Degree","text":"<ol> <li>Degree: Number of edges connected to a node</li> <li>In-degree: Number of edges coming into a node</li> <li>Out-degree: Number of edges going out of a node</li> </ol> <pre><code>flowchart LR\n1((1))\n2((2))\n3((3))\n4((4))\n1 --&gt; 3\n1 --&gt; 2\n3 --&gt; 4\n2 --&gt; 3</code></pre> <ul> <li>In-degree of Node 1: 0</li> <li>Out-degree of Node 1: 2</li> <li>In-degree of Node 2: 1</li> <li>Out-degree of Node 2: 1</li> </ul> <pre><code># List\nin_degree = [0, 1, 2, 1]\nout_degree = [2, 1, 1, 0]\n\n# Dict\nin_degree = {1: 0, 2: 1, 3: 2, 4: 1}\nout_degree = {1: 2, 2: 1, 3: 1, 4: 0}\n</code></pre>"},{"location":"graph/graph_bellman_ford/","title":"Graph - Bellman-Ford Algorithm","text":"<ul> <li>The Bellman-Ford algorithm is used to find the shortest path from a source vertex to all other vertices in a weighted graph.</li> <li>It is slower than Dijkstra's algorithm, but it is more versatile, as it is able to handle graphs with negative edge weights.</li> <li>Time Complexity: O(V * E), where V is the number of vertices and E is the number of edges in the graph.</li> <li>Space Complexity: O(V), where V is the number of vertices in the graph.</li> </ul>"},{"location":"graph/graph_bellman_ford/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0743 - Network Delay Time (Medium)</li> <li>0787 - Cheapest Flights Within K Stops (Medium)</li> <li>0207 - Course Schedule (Medium)</li> <li>1109 - Corporate Flight Bookings (Medium)</li> </ol>"},{"location":"graph/graph_bellman_ford/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li>Return the minimum time taken to reach all nodes starting from the source node.</li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"graph/graph_bellman_ford/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li>Return the cheapest price to reach the destination within K stops.</li> </ul> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\")] * n\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n\n        for s, d, p in flights:\n            if prices[s] == float(\"inf\"):\n                continue\n            if prices[s] + p &lt; temp_prices[d]:\n                temp_prices[d] = prices[s] + p\n\n        prices = temp_prices\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"graph/graph_bellman_ford/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>Return whether it is possible to finish all courses.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visited = set()\n\n    def dfs(crs):\n        if crs in visited:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visited.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    visited = [0] * numCourses\n\n    def dfs(crs):\n        if visited[crs] == 1:  # cycle detected\n            return False\n        if visited[crs] == 2:\n            return True\n\n        visited[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"graph/graph_bellman_ford/#1109-corporate-flight-bookings","title":"1109. Corporate Flight Bookings","text":"<ul> <li>Return the number of seats booked on each flight.</li> </ul>"},{"location":"graph/graph_bfs/","title":"Graph - Breadth First Search (BFS)","text":""},{"location":"graph/graph_bfs/#prerequisites-problems","title":"Prerequisites problems","text":"<ol> <li>0102 - Binary Tree Level Order Traversal (Medium)</li> <li>0733 - Flood Fill (Easy)</li> <li>0200 - Number of Islands (Medium)</li> </ol>"},{"location":"graph/graph_bfs/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0994 - Rotting Oranges (Medium)</li> <li>0127 - Word Ladder (Hard)</li> <li>1466 - Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li>0286 - Walls and Gates (Medium)</li> <li>0815 - Bus Routes (Hard)</li> </ol>"},{"location":"graph/graph_bfs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    # 1. Init\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    # 2. Make a queue of rotten oranges and count fresh oranges\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    # 3. BFS\n    while q and fresh &gt; 0:\n        size = len(q)\n\n        for _ in range(size):\n            r, c = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if nr &lt; 0 or nc &lt; 0 or nr &gt;= m or nc &gt;= n or grid[nr][nc] != 1:\n                    continue\n                grid[nr][nc] = 2\n                q.append([nr, nc])\n                fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"graph/graph_bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li>Return the length of the shortest transformation sequence from <code>beginWord</code> to <code>endWord</code>.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # Edge case\n    if endWord not in wordList:\n        return 0\n\n    # Init\n    graph = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    # BFS\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\n# |------------|---------|---------|\n# |  Approach  |  Time   |  Space  |\n# |------------|---------|---------|\n# |    BFS     | O(n*m^2)| O(n*m)  |\n# |------------|---------|---------|\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"graph/graph_bfs/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li>Return the minimum number of connections needed to connect all the cities such that all the roads are used in the right direction.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"graph/graph_bfs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li>Fill each empty room with the distance to its nearest gate.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            r in range(m)\n            and c in range(n)\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nrooms = [\n    [2147483647, -1, 0, 2147483647],\n    [2147483647, 2147483647, 2147483647, -1],\n    [2147483647, -1, 2147483647, -1],\n    [0, -1, 2147483647, 2147483647],\n]\nwallsAndGates(rooms)\nprint(rooms)\n# [[3, -1, 0,  1],\n#  [2,  2, 1, -1],\n#  [1, -1, 2, -1],\n#  [0, -1, 3,  4]]\n</code></pre>"},{"location":"graph/graph_bfs/#0815-bus-routes","title":"0815. Bus Routes","text":"<ul> <li>Return the least number of buses one must take to reach the destination from the source.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef numBusesToDestination(\n    routes: List[List[int]], source: int, target: int\n) -&gt; int:\n    if source == target:\n        return 0\n\n    graph = defaultdict(set)  # {stop: buses}\n    for buses, route in enumerate(routes):\n        for stop in route:\n            graph[stop].add(buses)\n\n    q = deque([(source, 0)])  # (stop, bus)\n    visited_stops = set([source])\n    visited_buses = set()\n\n    while q:\n        stop, bus = q.popleft()\n\n        if stop == target:\n            return bus\n\n        for buses in graph[stop]:\n            if buses not in visited_buses:\n                visited_buses.add(buses)\n                for next_stop in routes[buses]:\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        q.append((next_stop, bus + 1))\n\n    return -1\n\n\nroutes = [[1, 2, 7], [3, 6, 7]]\nsource = 1\ntarget = 6\nprint(numBusesToDestination(routes, source, target))  # 2\n</code></pre>"},{"location":"graph/graph_coloring/","title":"Graph - Coloring","text":""},{"location":"graph/graph_coloring/#bipartite-graph","title":"Bipartite Graph","text":"<p>How to group</p> Uncolored Color 1 Color 2 Operation Method 1 -1 0 1 <code>1 - color</code> Method 2 0 1 -1 <code>-color</code>"},{"location":"graph/graph_coloring/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0785 - Is Graph Bipartite? (Medium)</li> <li>886 - Possible Bipartition (Medium)</li> <li>0924 - Minimize Malware Spread (Hard)</li> </ol>"},{"location":"graph/graph_coloring/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li>Determine if a graph is bipartite.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"graph/graph_coloring/#886-possible-bipartition","title":"886. Possible Bipartition","text":"<ul> <li>Determine if a graph can be divided into two groups such that no two nodes of the same group are connected.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef possibleBipartitionBFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n\n    # Undirected graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def bfs(person):\n        q = deque([person])\n        group[person] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if group[neighbor] == -1:\n                    group[neighbor] = 1 - group[cur]\n                    q.append(neighbor)\n                elif group[neighbor] == group[cur]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not bfs(i):\n                return False\n    return True\n\n\n# DFS\ndef possibleBipartitionDFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def dfs(person, g):\n        group[person] = g\n\n        for neighbor in graph[person]:\n            if group[neighbor] == -1:\n                if not dfs(neighbor, 1 - g):\n                    return False\n            elif group[neighbor] == g:\n                return False\n\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V+E) |\n# |    DFS     | O(V+E) |  O(V+E) |\n# |------------|--------|---------|\n\n\nn = 4\ndislikes = [[1, 2], [1, 3], [2, 4]]\nprint(possibleBipartitionBFS(n, dislikes))  # True\nprint(possibleBipartitionDFS(n, dislikes))  # True\n</code></pre>"},{"location":"graph/graph_coloring/#0924-minimize-malware-spread","title":"0924. Minimize Malware Spread","text":"<pre><code>from typing import List\n\n\n# Coloring\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -&gt; int:\n    n = len(graph)\n    initial = set(initial)\n\n    def dfs(x):\n        visited.add(x)\n        mark[x] = 1\n        if x in initial:\n            v.append(x)\n        for nxt in range(n):\n            if graph[x][nxt] and nxt != x and not mark[nxt]:\n                dfs(nxt)\n\n    ans = min(initial)\n    mx = 0\n    mark = [0] * n\n    for i in range(n):\n        if not mark[i]:\n            visited = set()\n            v = []\n            dfs(i)\n            if len(v) == 1 and (\n                len(visited) &gt; mx or len(visited) == mx and v[0] &lt; ans\n            ):\n                ans, mx = v[0], len(visited)\n    return ans\n\n\ngraph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\ninitial = [0, 1]\nprint(minMalwareSpread(graph, initial))  # 0\n</code></pre>"},{"location":"graph/graph_flood_fill/","title":"Graph - Flood Fill","text":"<ul> <li>Flood Fill is essentially a graph traversal algorithm (like BFS or DFS) applied to matrices (2D grids).     It checks adjacent cells (up, down, left, right) of a starting point to determine whether they belong to the same region.     Typically, it involves modifying or marking the cells that belong to the same connected component.</li> </ul>"},{"location":"graph/graph_flood_fill/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0733 - Flood Fill (Easy)</li> <li>0200 - Number of Islands (Medium)</li> <li>0695 - Max Area of Island (Medium)</li> <li>0463 - Island Perimeter (Easy)</li> <li>0130 - Surrounded Regions (Medium)</li> <li>0417 - Pacific Atlantic Water Flow (Medium)</li> <li>0827 - Making A Large Island (Hard)</li> </ol>"},{"location":"graph/graph_flood_fill/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li>Replace all the pixels of the same color starting from the given pixel.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef floodFillDFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if org == color:\n        return image\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or image[r][c] != org:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# BFS\ndef floodFillBFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if org == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        r, c = q.popleft()\n        image[r][c] = color\n\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and image[nr][nc] == org:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre>"},{"location":"graph/graph_flood_fill/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == \"0\":\n            return None\n\n        grid[r][c] = \"0\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                ):\n                    continue\n                q.append((nr, nc))\n                grid[nr][nc] = \"0\"\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                grid[r][c] = \"0\"\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"graph/graph_flood_fill/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li>Find the maximum area of an island in a 2D grid.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    visited = set()\n    area = 0\n\n    def dfs(r, c):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return 0\n\n        visited.add((r, c))\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1)\n        )\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"graph/graph_flood_fill/#463-island-perimeter","title":"463. Island Perimeter","text":"<ul> <li>Calculate the perimeter of an island in a 2D grid.</li> </ul> <pre><code>from typing import List\n\n\n# DFS\ndef islandPerimeterDFS(grid: List[List[int]]) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n\n    visited = set()\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if (r, c) in visited or grid[r][c] == 0:\n            return 0\n        visited.add((r, c))\n        perimeter = 0\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr not in range(m) or nc not in range(n) or grid[nr][nc] == 0:\n                perimeter += 1\n            else:\n                perimeter += dfs(nr, nc)\n\n        return perimeter\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                return dfs(r, c)\n    return 0\n\n\ndef islandPerimeter(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    perimeter = 0\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                perimeter += 4\n\n                if r &gt; 0 and grid[r - 1][c] == 1:\n                    perimeter -= 2\n\n                if c &gt; 0 and grid[r][c - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\n\ngrid = [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]\nprint(islandPerimeterDFS(grid))  # 16\nprint(islandPerimeter(grid))  # 16\n</code></pre>"},{"location":"graph/graph_flood_fill/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li>Replace all the 'O's with 'X's if surrounded by 'X's.</li> </ul> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom typing import List\n\n\n# 1. DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r not in range(m) or c not in range(n) or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# 2. BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and board[nr][nc] == \"O\":\n                    q.append((nr, nc))\n                    board[nr][nc] = \"T\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nboard = [\n    [\"X\", \"X\", \"X\", \"X\"],\n    [\"X\", \"O\", \"O\", \"X\"],\n    [\"X\", \"X\", \"O\", \"X\"],\n    [\"X\", \"O\", \"X\", \"X\"],\n]\nboard1 = deepcopy(board)\nsolveDFS(board1)\npprint(board1)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n\nboard2 = deepcopy(board)\nsolveBFS(board2)\npprint(board2)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n</code></pre>"},{"location":"graph/graph_flood_fill/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li>Find the list of coordinates where water can flow to both the Pacific and Atlantic oceans.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"graph/graph_flood_fill/#827-making-a-large-island","title":"827. Making A Large Island","text":"<ul> <li>Find the area of the largest island after changing at most one '0' to '1'.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Flood Fill\ndef largestIsland(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    areas = defaultdict(int)  # {index: area}\n    index = 2\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(r, c, index):\n        area = 1\n        grid[r][c] = index\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                area += dfs(nr, nc, index)\n        return area\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 1:\n                areas[index] = dfs(r, c, index)\n                index += 1\n\n    if not areas:\n        return 1\n\n    res = max(areas.values())\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 0:\n                connected = set()\n                area = 1\n                for dr, dc in dirs:\n                    nr, nc = r + dr, c + dc\n                    if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] &gt; 1:\n                        connected.add(grid[nr][nc])\n\n                for island in connected:\n                    area += areas[island]\n                res = max(res, area)\n\n    return res\n\n\ngrid = [[1, 0], [0, 1]]\nprint(largestIsland(grid))  # 3\n</code></pre>"},{"location":"graph/graph_mst/","title":"Graph - Minimum Spanning Tree (MST)","text":""},{"location":"graph/graph_mst/#minimum-spanning-tree","title":"Minimum Spanning Tree","text":"<ul> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li> <p>Algorithm</p> </li> <li> <p>Prim's Algorithm</p> <ul> <li>Data Structure: Heap</li> <li>Time Ciomplexity: \\(O(E \\log V)\\)</li> <li>Space Complexity: \\(O(V + E)\\)</li> </ul> </li> <li> <p>Kruskal's Algorithm</p> <ul> <li>Union Find</li> <li>Time Complexity: \\(O(E \\log V)\\)</li> <li>Space Complexity: \\(O(V + E)\\)</li> </ul> </li> <li> <p>Demonstration</p> </li> </ul> <p>Example graph</p> <p></p> <p>MST</p> <p></p> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\n\n# Prim\ndef prim(\n    connections: List[Tuple[int, int, int]]\n) -&gt; Dict[int, List[Tuple[int, int]]]:\n\n    graph = defaultdict(list)\n    for u, v, w in connections:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    mst = defaultdict(list)  # {node: [(neighbour, weight)]}\n    visited = set()\n    start = next(iter(graph))\n    visited.add(start)\n    heap = []  # [(weight, src, dst)]\n\n    for n, w in graph[start]:\n        heapq.heappush(heap, (w, start, n))\n\n    while heap:\n        w, u, v = heapq.heappop(heap)\n\n        if v in visited:\n            continue\n\n        visited.add(v)\n        mst[u].append((v, w))\n        mst[v].append((u, w))\n\n        for n, w in graph[v]:\n            heapq.heappush(heap, (w, v, n))\n\n    return mst\n\n\n# Kruskal\ndef kruskal(\n    num: int, connections: List[Tuple[int, int, int]]\n) -&gt; Dict[int, List[Tuple[int, int]]]:\n\n    par = {i: i for i in range(num)}\n    rank = {i: 0 for i in range(num)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    mst = defaultdict(list)\n    heap = []\n    for u, v, w in connections:\n        heapq.heappush(heap, (w, u, v))\n\n    while heap:\n        w, u, v = heapq.heappop(heap)\n\n        if union(u, v):\n            mst[u].append((v, w))\n            mst[v].append((u, w))\n\n    return mst\n\n\nconnections = [\n    (0, 1, 4),\n    (0, 2, 3),\n    (1, 2, 1),\n    (1, 3, 2),\n    (2, 3, 4),\n    (3, 4, 2),\n    (4, 0, 4),\n]\nnum = 5\n\nprint(prim(connections))\n# {\n#     0: [(2, 3)],\n#     2: [(0, 3), (1, 1)],\n#     1: [(2, 1), (3, 2)],\n#     3: [(1, 2), (4, 2)],\n#     4: [(3, 2)],\n# }\nprint(kruskal(num, connections))\n# {\n#     1: [(2, 1), (3, 2)],\n#     2: [(1, 1), (0, 3)],\n#     3: [(1, 2), (4, 2)],\n#     4: [(3, 2)],\n#     0: [(2, 3)]\n# }\n</code></pre>"},{"location":"graph/graph_mst/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>1584 - Min Cost to Connect All Points (Medium)</li> <li>1135 - Connecting Cities With Minimum Cost (Medium)</li> <li>1168 - Optimize Water Distribution in a Village (Hard)</li> <li>1489 - Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> <li>1631 - Path With Minimum Effort (Medium)</li> <li>1579 - Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> <li>1589 - Maximum Sum Obtained of Any Permutation (Medium)</li> </ol>"},{"location":"graph/graph_mst/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"graph/graph_mst/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"graph/graph_mst/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"graph/graph_mst/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"graph/graph_mst/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"graph/graph_mst/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li>Return the maximum number of edges you can remove so that the graph remains fully traversable.</li> </ul> <pre><code>from typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"graph/graph_mst/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":""},{"location":"graph/graph_shortest_path/","title":"Graph - Shortest Path Problems","text":"<ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> </ul>"},{"location":"graph/graph_shortest_path/#dijkstras-algorithm","title":"Dijkstra's Algorithm","text":"<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; HashSet</li> <li>Time Complexity: \\(O(E \\cdot \\log{V})\\)</li> <li>Space Complexity: \\(O(V)\\)</li> </ul>"},{"location":"graph/graph_shortest_path/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0743 - Network Delay Time (Medium)</li> <li>0778 - Swim in Rising Water (Hard)</li> <li>1631 - Path With Minimum Effort (Medium)</li> <li>0787 - Cheapest Flights Within K Stops (Medium)</li> <li>1514 - Path with Maximum Probability (Medium)</li> <li>0505 - The Maze II (Medium)</li> <li>0499 - The Maze III (Hard)</li> <li>0882 - Reachable Nodes In Subdivided Graph (Hard)</li> <li>1376 - Time Needed to Inform All Employees (Medium)</li> <li>1168 - Optimize Water Distribution in a Village (Hard)</li> <li>1976 - Number of Ways to Arrive at Destination (Hard)</li> </ol>"},{"location":"graph/graph_shortest_path/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"graph/graph_shortest_path/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li>Return the minimum time when you can reach the target.</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"graph/graph_shortest_path/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"graph/graph_shortest_path/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\")] * n\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n\n        for s, d, p in flights:\n            if prices[s] == float(\"inf\"):\n                continue\n            if prices[s] + p &lt; temp_prices[d]:\n                temp_prices[d] = prices[s] + p\n\n        prices = temp_prices\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"graph/graph_shortest_path/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"graph/graph_shortest_path/#505-the-maze-ii","title":"505. The Maze II","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"graph/graph_shortest_path/#499-the-maze-iii","title":"499. The Maze III","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"graph/graph_shortest_path/#882-reachable-nodes-in-subdivided-graph","title":"882. Reachable Nodes In Subdivided Graph","text":""},{"location":"graph/graph_shortest_path/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre>"},{"location":"graph/graph_shortest_path/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"graph/graph_shortest_path/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":""},{"location":"graph/graph_shortest_path/#appendix","title":"Appendix","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List, Tuple\n\n\n# Dijkstra\ndef dijkstra(connections: List[Tuple[int, int, int]], start: int):\n    graph = defaultdict(dict)\n    nodes = set()\n\n    for u, v, w in connections:\n        graph[u][v] = w\n        nodes.add(u)\n        nodes.add(v)\n\n    distances = {node: float(\"inf\") for node in nodes}\n    distances[start] = 0\n    heap = [(0, start)]\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if d1 &gt; distances[n1]:\n            continue\n\n        for n2, d2 in graph[n1].items():\n            dist = d1 + d2\n            if dist &lt; distances[n2]:\n                distances[n2] = dist\n                heapq.heappush(heap, (dist, n2))\n\n    return distances\n\n\n# Bellman-Ford\ndef bellman_ford(connections: List[Tuple[int, int, int]], start: int):\n    nodes = set()\n\n    for u, v, _ in connections:\n        nodes.add(u)\n        nodes.add(v)\n\n    distances = {node: float(\"inf\") for node in nodes}\n    distances[start] = 0\n\n    for _ in range(len(nodes) - 1):\n        for u, v, w in connections:\n            if distances[u] + w &lt; distances[v]:\n                distances[v] = distances[u] + w\n\n    return distances\n\n\nconnections = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nstart = 2\nprint(dijkstra(connections, start))\n# {1: 1, 2: 0, 3: 1, 4: 2}\nprint(bellman_ford(connections, start))\n# {1: 1, 2: 0, 3: 1, 4: 2}\n</code></pre>"},{"location":"graph/graph_tarjan/","title":"Graph - Tarjan's Algorithm","text":""},{"location":"graph/graph_tarjan/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>1192 - Critical Connections in a Network (Hard)</li> </ol>"},{"location":"graph/graph_tarjan/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"graph/graph_topological_sort/","title":"Graph - Topological Sort","text":""},{"location":"graph/graph_topological_sort/#topological-sort","title":"Topological Sort","text":"<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: \\(O(V+E)\\)</li> <li>Space complexity: \\(O(V+E)\\)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul>"},{"location":"graph/graph_topological_sort/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>1557 - Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li>0207 - Course Schedule (Medium)</li> <li>0210 - Course Schedule II (Medium)</li> <li>0269 - Alien Dictionary (Hard)</li> <li>1203 - Sort Items by Groups Respecting Dependencies (Hard)</li> <li>1857 - Largest Color Value in a Directed Graph (Hard)</li> <li>1136 - Parallel Courses (Hard)</li> </ol>"},{"location":"graph/graph_topological_sort/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li>Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.</li> <li>\u2705 Return the vertices with indegree 0.</li> </ul> <pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for a, b in edges:\n        indegree[b] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(findSmallestSetOfVertices(n, edges))  # [0, 3]\n</code></pre>"},{"location":"graph/graph_topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visited = set()\n\n    def dfs(crs):\n        if crs in visited:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visited.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    visited = [0] * numCourses\n\n    def dfs(crs):\n        if visited[crs] == 1:  # cycle detected\n            return False\n        if visited[crs] == 2:\n            return True\n\n        visited[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"graph/graph_topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"graph/graph_topological_sort/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li>Return the correct order of characters in the alien language.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"graph/graph_topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li>Return any permutation of the items that satisfies the requirements.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"graph/graph_topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li>Return the largest color value of any node in the graph.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"graph/graph_topological_sort/#1136-parallel-courses","title":"1136. Parallel Courses","text":"<ul> <li>Return the minimum number of semesters needed to take all courses.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"graph/graph_topological_sort/#appendix","title":"Appendix","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import Dict, List\n\n\n# 1. BFS - Khan's algorithm\ndef topologicalSortBFS(graph: Dict[str, List[str]]) -&gt; List[str]:\n    \"\"\"Topological sort of a directed acyclic graph using BFS\n\n    Args:\n        graph (Dict[List]): Adjacency list representation of the graph\n        Example:\n        {\n            'A': ['B', 'C'],\n            'B': ['D'],\n            'C': ['D'],\n            'D': []\n        }\n\n    Returns:\n        List: Topological order of the graph\n    \"\"\"\n    indegree = defaultdict(int)\n    for node in graph:\n        for neighbor in graph[node]:\n            indegree[neighbor] += 1\n\n    q = deque([node for node in graph if indegree[node] == 0])\n    order = []\n\n    while q:\n        node = q.popleft()\n        order.append(node)\n\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    if len(order) == len(graph):\n        return order\n    else:\n        return []\n\n\n# 2. DFS\ndef topologicalSortDFS(graph: Dict[str, List[str]]) -&gt; List[str]:\n    \"\"\"Topological sort of a directed acyclic graph using DFS\n\n    Args:\n        graph (Dict[List]): Adjacency list representation of the graph\n        Example:\n        {\n            'A': ['B', 'C'],\n            'B': ['D'],\n            'C': ['D'],\n            'D': []\n        }\n\n    Returns:\n        List: Topological order of the graph\n    \"\"\"\n\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n        order.append(node)\n\n    visited = set()\n    order = []\n    for node in graph:\n        if node not in visited:\n            dfs(node)\n\n    return order[::-1]\n\n\ngraph = {\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"D\"], \"D\": []}\n\nprint(topologicalSortBFS(graph))  # ['A', 'B', 'C', 'D']\nprint(topologicalSortDFS(graph))  # ['A', 'C', 'B', 'D']\n</code></pre>"},{"location":"graph/graph_union_find/","title":"Union Find (Disjoint Set)","text":""},{"location":"graph/graph_union_find/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0547 - Number of Provinces (Medium)</li> <li>0684 - Redundant Connection (Medium)</li> <li>0323 - Number of Connected Components in an Undirected Graph (Medium)</li> <li>0721 - Accounts Merge (Medium)</li> <li>0990 - Satisfiability of Equality Equations (Medium)</li> <li>0952 - Largest Component Size by Common Factor (Hard)</li> <li>0839 - Similar String Groups (Hard)</li> <li>0305 - Number of Islands II (Hard)</li> <li>1202 - Smallest String With Swaps (Medium)</li> <li>0685 - Redundant Connection II (Hard)</li> <li>0399 - Evaluate Division (Medium)</li> <li>1101 - The Earliest Moment When Everyone Become Friends (Medium)</li> </ol>"},{"location":"graph/graph_union_find/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li>Return the number of provinces.</li> </ul> <pre><code>from typing import List\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    parent = list(range(n))\n    rank = [1 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    provinces = len(set(find(i) for i in range(n)))\n\n    return provinces\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNum(isConnected))  # 2\n</code></pre>"},{"location":"graph/graph_union_find/#684-redundant-connection","title":"684. Redundant Connection","text":"<pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    par = {i: i for i in range(len(edges) + 1)}\n    rank = {i: 1 for i in range(len(edges) + 1)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n        else:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n\n        return True\n\n    for n1, n2 in edges:\n        if not union(n1, n2):\n            return (n1, n2)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"graph/graph_union_find/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    parent = [i for i in range(n)]\n    rank = [1 for _ in range(n)]\n\n    def find(node):\n        root = node\n\n        while root != parent[root]:\n            parent[root] = parent[parent[root]]\n            root = parent[root]\n        return root\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if rank[p2] &gt; rank[p1]:\n            parent[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            parent[p2] = p1\n            rank[p1] += rank[p2]\n        return 1\n\n    count = n\n    for n1, n2 in edges:\n        count -= union(n1, n2)\n\n    return count\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))\n</code></pre>"},{"location":"graph/graph_union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"graph/graph_union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"graph/graph_union_find/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":""},{"location":"graph/graph_union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"graph/graph_union_find/#305-number-of-islands-ii","title":"305. Number of Islands II","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre>"},{"location":"graph/graph_union_find/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre>"},{"location":"graph/graph_union_find/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre>"},{"location":"graph/graph_union_find/#399-evaluate-division","title":"399. Evaluate Division","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre>"},{"location":"graph/graph_union_find/#1101-the-earliest-moment-when-everyone-become-friends","title":"1101. The Earliest Moment When Everyone Become Friends","text":"<pre><code>from typing import List\n\n\n# Union Find\ndef earliestAcq(logs: List[List[int]], n: int) -&gt; int:\n    logs.sort()\n    par = {i: i for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    for time, a, b in logs:\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            par[pa] = pb\n            n -= 1\n        if n == 1:\n            return time\n    return -1\n\n\nlogs = [[0, 2, 0], [1, 0, 1], [3, 0, 3], [4, 1, 2], [7, 3, 1]]\nn = 4\nprint(earliestAcq(logs, n))  # 3\n</code></pre>"},{"location":"graph/graph_union_find/#appendix","title":"Appendix","text":""},{"location":"graph/graph_union_find/#union-find","title":"Union Find","text":"<ol> <li>Path Compression</li> <li>Union by Rank</li> </ol> <pre><code>class UnionFind:\n    def __init__(self, n: int):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 0 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return None\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n\n\nuf = UnionFind(7)\nuf.union(1, 2)\nuf.union(3, 4)\nuf.union(1, 4)\nuf.union(5, 6)\nprint(uf.connected(2, 3))  # True\nprint(uf.connected(1, 3))  # True\nprint(uf.connected(1, 5))  # False\n</code></pre>"},{"location":"greedy/","title":"Greedy","text":""},{"location":"greedy/greedy/","title":"Greedy","text":""},{"location":"greedy/greedy/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0455 - Assign Cookies (Easy)</li> <li>1005 - Maximize Sum Of Array After K Negations (Easy)</li> <li>0860 - Lemonade Change (Easy)</li> <li>2037 - Minimum Number of Moves to Seat Everyone (Easy)</li> <li>0376 - Wiggle Subsequence (Medium)</li> <li>0738 - Monotone Increasing Digits (Medium)</li> <li>0122 - Best Time to Buy and Sell Stock II (Easy)</li> <li>0714 - Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> <li>0135 - Candy (Hard)</li> <li>0406 - Queue Reconstruction by Height (Medium)</li> <li>3075 - Maximize Happiness of Selected Children (Medium)</li> <li>0945 - Minimum Increment to Make Array Unique (Medium)</li> <li>0053 - Maximum Subarray (Medium)</li> <li>0134 - Gas Station (Medium)</li> <li>0968 - Binary Tree Cameras (Hard)</li> </ol>"},{"location":"greedy/greedy/#455-assign-cookies","title":"455. Assign Cookies","text":"<ul> <li>Return the maximum number of your content children that can be satisfied.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef findContentChildren(g: List[int], s: List[int]) -&gt; int:\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n\n    while i &lt; len(g) and j &lt; len(s):\n        if g[i] &lt;= s[j]:\n            i += 1\n        j += 1\n\n    return i\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Greedy    | O(N * logN) |    O(1)      |\n# |-------------|-------------|--------------|\n\n\ng = [1, 2, 3]\ns = [1, 1]\nprint(findContentChildren(g, s))  # 1\n</code></pre>"},{"location":"greedy/greedy/#1005-maximize-sum-of-array-after-k-negations","title":"1005. Maximize Sum Of Array After K Negations","text":"<ul> <li>Return the maximum sum of the array after changing at most <code>k</code> elements.</li> </ul> <pre><code>from heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Greedy\ndef largestSumAfterKNegationsGreedy(nums: List[int], k: int) -&gt; int:\n    nums.sort(key=abs, reverse=True)\n\n    for i in range(len(nums)):\n        if nums[i] &lt; 0 and k &gt; 0:\n            nums[i] *= -1\n            k -= 1\n\n    if k % 2:\n        nums[-1] *= -1\n\n    return sum(nums)\n\n\n# Heap\ndef largestSumAfterKNegationsHeap(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n\n    while k and nums[0] &lt; 0:\n        heapreplace(nums, -nums[0])\n        k -= 1\n\n    if k % 2:\n        heapreplace(nums, -nums[0])\n\n    return sum(nums)\n\n\nprint(largestSumAfterKNegationsGreedy([4, 2, 3], 1))  # 5\nprint(largestSumAfterKNegationsHeap([4, 2, 3], 1))\n</code></pre>"},{"location":"greedy/greedy/#860-lemonade-change","title":"860. Lemonade Change","text":"<ul> <li>Return <code>True</code> if and only if you can provide every customer with correct change.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef lemonadeChange(bills: List[int]) -&gt; bool:\n    hashmap = {5: 0, 10: 0, 20: 0}\n\n    for i in bills:\n        if i == 5:\n            hashmap[5] += 1\n\n        if i == 10:\n            if hashmap[5] &lt; 1:\n                return False\n\n            hashmap[5] -= 1\n            hashmap[10] += 1\n\n        if i == 20:\n            if hashmap[5] &gt;= 1 and hashmap[10] &gt;= 1:\n                hashmap[5] -= 1\n                hashmap[10] -= 1\n                hashmap[20] += 1\n\n            elif hashmap[5] &gt;= 3:\n                hashmap[5] -= 3\n                hashmap[20] += 1\n\n            else:\n                return False\n\n    return True\n\n\nprint(lemonadeChange([5, 5, 5, 10, 20]))  # True\n</code></pre>"},{"location":"greedy/greedy/#2037-minimum-number-of-moves-to-seat-everyone","title":"2037. Minimum Number of Moves to Seat Everyone","text":"<ul> <li>Return the minimum number of moves needed to seat everyone.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef minMovesToSeat(seats: List[int], students: List[int]) -&gt; int:\n    seats.sort()\n    students.sort()\n    moves = 0\n\n    for i, j in zip(seats, students):\n        moves += abs(i - j)\n\n    return moves\n\n\nprint(minMovesToSeat([3, 1, 5], [2, 7, 4]))  # 4\n</code></pre>"},{"location":"greedy/greedy/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li>Return the length of the longest subsequence that is a wiggle sequence.</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"greedy/greedy/#738-monotone-increasing-digits","title":"738. Monotone Increasing Digits","text":"<ul> <li>Return the largest number that is less than or equal to <code>n</code> with monotone increasing digits.</li> </ul> <pre><code># Greedy\ndef monotoneIncreasingDigits(n: int) -&gt; int:\n    strNum = list(str(n))\n\n    for i in range(len(strNum) - 2, -1, -1):\n        if int(strNum[i]) &gt; int(strNum[i + 1]):\n            strNum[i] = str(int(strNum[i]) - 1)\n            strNum[i + 1 :] = [\"9\"] * (len(strNum) - (i + 1))\n\n    return int(\"\".join(strNum))\n\n\nn = 332\nprint(monotoneIncreasingDigits(n))  # 299\n</code></pre>"},{"location":"greedy/greedy/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li>Return the maximum profit you can achieve.</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"greedy/greedy/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li>Return the maximum profit you can achieve with the given transaction fee.</li> </ul> <pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"greedy/greedy/#135-candy","title":"135. Candy","text":"<ul> <li>Return the minimum number of candies you must give.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"greedy/greedy/#406-queue-reconstruction-by-height","title":"406. Queue Reconstruction by Height","text":"<ul> <li>Reconstruct the queue.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy\ndef reconstructQueue(people: List[List[int]]) -&gt; List[List[int]]:\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for i in people:\n        queue.insert(i[1], i)\n\n    return queue\n\n\npeople = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nprint(reconstructQueue(people))\n# [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n</code></pre>"},{"location":"greedy/greedy/#3075-maximize-happiness-of-selected-children","title":"3075. Maximize Happiness of Selected Children","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef maximumHappinessSum(happiness: List[int], k: int) -&gt; int:\n    selected = 0\n    happinessScore = 0\n    happiness.sort(reverse=True)\n\n    for score in happiness:\n        if selected == k:\n            return happinessScore\n        happinessScore += max(0, score - selected)\n        selected += 1\n\n    return happinessScore\n\n\nhappiness = [1, 2, 3]\nk = 2\nprint(maximumHappinessSum(happiness, k))  # 4\n</code></pre>"},{"location":"greedy/greedy/#945-minimum-increment-to-make-array-unique","title":"945. Minimum Increment to Make Array Unique","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef minIncrementForUnique(nums: List[int]) -&gt; int:\n    nums.sort()\n    moves = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] &lt;= nums[i - 1]:\n            moves += nums[i - 1] + 1 - nums[i]\n            nums[i] = nums[i - 1] + 1\n\n    return moves\n\n\nnums = [1, 2, 2]\nprint(minIncrementForUnique(nums))  # 1\n</code></pre>"},{"location":"greedy/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"greedy/greedy/#134-gas-station","title":"134. Gas Station","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre>"},{"location":"greedy/greedy/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":""},{"location":"greedy/greedy_interval/","title":"Greedy Algorithm - Interval Problems","text":""},{"location":"greedy/greedy_interval/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0055 - Jump Game (Medium)</li> <li>0045 - Jump Game II (Hard)</li> <li>0452 - Minimum Number of Arrows to Burst Balloons (Medium)</li> <li>0435 - Non-overlapping Intervals (Medium)</li> <li>0763 - Partition Labels (Medium)</li> <li>0056 - Merge Intervals (Medium)</li> </ol>"},{"location":"greedy/greedy_interval/#55-jump-game","title":"55. Jump Game","text":"<ul> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    reach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= reach:\n        reach = max(reach, i + nums[i])\n        if reach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True"},{"location":"greedy/greedy_interval/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li>Return the minimum number of jumps to reach the last index.</li> </ul> <pre><code>from typing import List\n\n\ndef jump(nums: List[int]) -&gt; int:\n    if len(nums) == 1:\n        return 0\n\n    cover = 0\n    count = 0\n    i = 0\n\n    while cover &gt;= 0:\n        for i in range(i, cover + 1):\n            cover = max(cover, nums[i] + i)\n            if cover &gt;= len(nums) - 1:\n                return count + 1\n        count += 1\n\n    return count\n\n\nprint(jump([2, 3, 1, 1, 4]))  # 2\n</code></pre>"},{"location":"greedy/greedy_interval/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n == 0:\n        return 0\n\n    points.sort(key=lambda x: x[0])\n    arrow = 1\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            arrow += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n\n    return arrow\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    result = len(points)\n    if result == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            result -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return result\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"greedy/greedy_interval/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"greedy/greedy_interval/#763-partition-labels","title":"763. Partition Labels","text":"<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    # Time complexity: O(nlogn)\n    # Space complexity: O(n)\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    result = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            result.append(intervals[i][0])\n\n    result.append(intervals[-1][1] + 1)\n\n    if len(result) == 1:\n        return result\n    else:\n        for i in range(len(result) - 1, 0, -1):\n            result[i] -= result[i - 1]\n        return result\n\n\n# 2. Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    last = {c: i for i, c in enumerate(s)}\n\n    start, end = 0, 0\n    result = []\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if i == end:\n            result.append(end - start + 1)\n            start = i + 1\n\n    return result\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"greedy/greedy_interval/#56-merge-intervals","title":"56. Merge Intervals","text":"<pre><code>from typing import List\n\n\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt;= result[-1][1]:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"hash/","title":"Hash","text":""},{"location":"hash/hash_counting/","title":"Hash - Counting","text":""},{"location":"hash/hash_counting/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0242 - Valid Anagram (Easy)</li> <li>0560 - Subarray Sum Equals K (Medium)</li> <li>0049 - Group Anagrams (Medium)</li> <li>0438 - Find All Anagrams in a String (Medium)</li> </ol>"},{"location":"hash/hash_counting/#242-valid-anagram","title":"242. Valid Anagram","text":"<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"hash/hash_counting/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"hash/hash_counting/#49-group-anagrams","title":"49. Group Anagrams","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"hash/hash_counting/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"hash/hash_map/","title":"Hash Map","text":""},{"location":"hash/hash_map/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0383 - Ransom Note (Easy)</li> <li>0350 - Intersection of Two Arrays II (Easy)</li> <li>0001 - Two Sum (Easy)</li> <li>0409 - Longest Palindrome (Easy)</li> <li>1365 - How Many Numbers Are Smaller Than the Current Number (Easy)</li> <li>0202 - Happy Number (Easy)</li> <li>0454 - 4Sum II (Medium)</li> </ol>"},{"location":"hash/hash_map/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li>Return <code>True</code> if the ransom note can be constructed from the magazines, otherwise, return <code>False</code>.</li> </ul> <pre><code>graph LR\n    A[\"Magazine: abcdef\"] --&gt; C(True)\n    B[\"Ransom Note: abc\"] --&gt; C</code></pre> <pre><code>from collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"hash/hash_map/#350-intersection-of-two-arrays-ii","title":"350. Intersection of Two Arrays II","text":"<ul> <li>Return the intersection of two arrays.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hashmap\ndef intersect(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    hashmap = defaultdict(int)  # {num: count}\n    result = []\n\n    for i in nums1:\n        hashmap[i] += 1\n\n    for i in nums2:\n        if hashmap[i] &gt; 0:\n            result.append(i)\n            hashmap[i] -= 1\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Hashmap   |   O(n + m)  | O(min(n, m)) |\n# |-------------|-------------|--------------|\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersect(nums1, nums2))  # [2, 2]\n</code></pre>"},{"location":"hash/hash_map/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> <pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = dict()  # {val: idx}\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n        hashmap[val] = idx\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Hashmap    |      O(n)       |    O(n)      |\n# |-------------|-----------------|--------------|\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nprint(twoSum(nums, target))  # [1, 2]\n</code></pre>"},{"location":"hash/hash_map/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> <pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"hash/hash_map/#1365-how-many-numbers-are-smaller-than-the-current-number","title":"1365. How Many Numbers Are Smaller Than the Current Number","text":"<ul> <li>For each number in the array, return how many numbers are smaller than it.</li> </ul> <pre><code>from typing import List\n\n\ndef smallerNumbersThanCurrent(nums: List[int]) -&gt; List[int]:\n    sortedNums = sorted(nums)\n\n    hashmap = dict()\n\n    for i, num in enumerate(sortedNums):\n        if num not in hashmap:\n            hashmap[num] = i\n\n    result = []\n    for i in range(len(sortedNums)):\n        result.append(hashmap[nums[i]])\n\n    return result\n\n\nnums = [8, 1, 2, 2, 3]\nprint(smallerNumbersThanCurrent(nums))  # [4, 0, 1, 1, 3]\n</code></pre>"},{"location":"hash/hash_map/#202-happy-number","title":"202. Happy Number","text":"<ul> <li>Return <code>True</code> if the number is a happy number, otherwise, return <code>False</code>.</li> <li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> </ul> <pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"hash/hash_map/#454-4sum-ii","title":"454. 4Sum II","text":"<ul> <li>Return the number of tuples <code>(i, j, k, l)</code> such that <code>A[i] + B[j] + C[k] + D[l] == 0</code>.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef fourSumCount(\n    nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n) -&gt; int:\n\n    sumAB = defaultdict(int)\n    result = 0\n\n    for i in nums1:\n        for j in nums2:\n            sumAB[i + j] += 1\n\n    for i in nums3:\n        for j in nums4:\n            if -(i + j) in sumAB:\n                result += sumAB[-(i + j)]\n\n    return result\n\n\nnums1 = [1, 2]\nnums2 = [-2, -1]\nnums3 = [-1, 2]\nnums4 = [0, 2]\nprint(fourSumCount(nums1, nums2, nums3, nums4))  # 2\n</code></pre>"},{"location":"hash/hash_set/","title":"Hash Set","text":""},{"location":"hash/hash_set/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0349 - Intersection of Two Arrays (Easy)</li> </ol>"},{"location":"hash/hash_set/#349-intersection-of-two-arrays","title":"349. Intersection of Two Arrays","text":"<pre><code>from typing import List\n\n\n# Set\ndef intersectionSet(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return list(set1 &amp; set2)\n\n\n# Hash\ndef intersectionHash(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    result = set()\n\n    for num in nums2:\n        if num in set1:\n            result.add(num)\n\n    return list(result)\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     Set    | O(n+m) |  O(n+m) |\n# |    Hash    | O(n+m) |   O(n)  |\n# |------------|--------|---------|\n\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersectionSet(nums1, nums2))  # [2]\nprint(intersectionHash(nums1, nums2))  # [2]\n</code></pre>"},{"location":"heap/","title":"Heap","text":"<p>Source: GeeksforGeeks</p>"},{"location":"heap/#heapq-module","title":"heapq Module","text":"<pre><code>import heapq\n\nheap = []\n\n# Add\nheapq.heappush(heap, 3)\nheapq.heappush(heap, 1)\nheapq.heappush(heap, 4)\nheapq.heappush(heap, 2)\nprint(heap)  # [1, 2, 4, 3]\n\n# Pop\nheapq.heappop(heap)\nprint(heap)  # [2, 3, 4]\nheapq.heappop(heap)\nprint(heap)  # [3, 4]\n</code></pre>"},{"location":"heap/heap_heap/","title":"Heap","text":""},{"location":"heap/heap_heap/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>1046 - Last Stone Weight (Easy)</li> </ol>"},{"location":"heap/heap_heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n    dp = [0 for _ in range(target + 1)]\n\n    for stone in stones:\n        for j in range(target, stone - 1, -1):\n            dp[j] = max(dp[j], dp[j - stone] + stone)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"heap/heap_merge_k_sorted/","title":"Heap - Merge K Sorted","text":""},{"location":"heap/heap_merge_k_sorted/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0023 - Merge k Sorted Lists (Hard)</li> <li>0373 - Find K Pairs with Smallest Sums (Medium)</li> <li>0378 - Kth Smallest Element in a Sorted Matrix (Medium)</li> </ol>"},{"location":"heap/heap_merge_k_sorted/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<pre><code>import heapq\nfrom typing import List, Optional\n\nfrom helper import ListNode\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    heap = []\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(heap, (head.val, idx, head))\n\n    while heap:\n        _, idx, node = heapq.heappop(heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(heap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nprint(mergeKLists(lists))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"heap/heap_merge_k_sorted/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(\n    nums1: List[int], nums2: List[int], k: int\n) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    result = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return result\n\n\nnums1 = [1, 2, 4, 5, 6]\nnums2 = [3, 5, 7, 9]\nk = 3\nprint(kSmallestPairs(nums1, nums2, k))\n# [[1, 3], [2, 3], [1, 5]]\n</code></pre>"},{"location":"heap/heap_merge_k_sorted/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"heap/heap_top_k/","title":"Heap - Top K Pattern","text":""},{"location":"heap/heap_top_k/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0215 - Kth Largest Element in an Array (Medium)</li> <li>0973 - K Closest Points to Origin (Medium)</li> <li>0347 - Top K Frequent Elements (Medium)</li> <li>0692 - Top K Frequent Words (Medium)</li> <li>0264 - Ugly Number II (Medium)</li> <li>0451 - Sort Characters By Frequency (Medium)</li> <li>703 - Kth Largest Element in a Stream (Easy)</li> <li>0767 - Reorganize String (Medium)</li> <li>0786 - K-th Smallest Prime Fraction (Hard)</li> </ol>"},{"location":"heap/heap_top_k/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    heap = nums[:k]\n    heapq.heapify(heap)  # min heap\n\n    for num in nums[k:]:\n        if num &gt; heap[0]:\n            heapq.heappop(heap)  # pop the smallest element\n            heapq.heappush(heap, num)  # push the new element\n\n    return heap[0]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\nnums = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(findKthLargest(nums, k))  # 5\n</code></pre>"},{"location":"heap/heap_top_k/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"heap/heap_top_k/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# 1. Heap + Counter\ndef topKFrequent1(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, count in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (count, val))\n        else:\n            heapq.heappushpop(minHeap, (count, val))\n\n    return [i for (_, i) in minHeap]\n\n\n# 2. Heap + Dict\ndef topKFrequent2(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    counts = dict()\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for val, count in counts.items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (count, val))\n        else:\n            heapq.heappushpop(minHeap, (count, val))\n\n    return [i for (_, i) in minHeap]\n\n\n# 3. Counter - Most Common\ndef topKFrequent3(nums: List[int], k: int) -&gt; List[int]:\n    common = Counter(nums).most_common(k)\n    return [i for i, _ in common]\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Heap      |    O(n)     |    O(n)      |\n# |   Counter   |    O(n)     |    O(n)      |\n# |-------------|-------------|--------------|\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent1(nums, k))  # [2, 1]\nprint(topKFrequent2(nums, k))  # [2, 1]\nprint(topKFrequent3(nums, k))  # [1, 2]\n</code></pre>"},{"location":"heap/heap_top_k/#692-top-k-frequent-words","title":"692. Top K Frequent Words","text":"<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\nclass WordFrequency:\n    def __init__(self, word, freq):\n        self.word = word\n        self.freq = freq\n\n    def __lt__(self, other):\n        # If the frequency is different\n        if self.freq != other.freq:\n            # The word with the lower frequency comes first\n            return self.freq &lt; other.freq\n        else:\n            # The word with the lower alphabetical order comes first\n            return self.word &gt; other.word\n\n\ndef topKFrequent(words: List[str], k: int) -&gt; List[str]:\n    heap = []\n\n    for word, freq in Counter(words).items():\n        heapq.heappush(heap, WordFrequency(word, freq))\n\n        if len(heap) &gt; k:\n            heapq.heappop(heap)\n\n    heap.sort(reverse=True)\n    return [x.word for x in heap]\n\n\nwords = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"]\nk = 2\nprint(topKFrequent(words, k))  # [\"i\", \"love\"]\n</code></pre>"},{"location":"heap/heap_top_k/#264-ugly-number-ii","title":"264. Ugly Number II","text":"<pre><code>import heapq\n\n\ndef nthUglyNumber(n: int) -&gt; int:\n    heap = [1]\n    seen = set(heap)\n\n    factors = [2, 3, 5]\n    current = 1\n\n    # Pop the smallest ugly number n times\n    for _ in range(n):\n        current = heapq.heappop(heap)  # Pop the smallest ugly number\n\n        for factor in factors:\n            new = current * factor\n            if new not in seen:\n                seen.add(new)\n                heapq.heappush(heap, new)\n\n    return current\n\n\nprint(nthUglyNumber(10))  # 12\n</code></pre>"},{"location":"heap/heap_top_k/#451-sort-characters-by-frequency","title":"451. Sort Characters By Frequency","text":"<pre><code>import heapq\nfrom collections import Counter\n\n\ndef frequencySort(s: str) -&gt; str:\n    result = \"\"\n\n    # Max Heap\n    heap = [(-freq, val) for val, freq in Counter(s).items()]\n    heapq.heapify(heap)\n\n    while heap:\n        freq, val = heapq.heappop(heap)\n        result += val * -freq\n\n    return result\n\n\nprint(frequencySort(\"tree\"))  # eert\n</code></pre>"},{"location":"heap/heap_top_k/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"heap/heap_top_k/#767-reorganize-string","title":"767. Reorganize String","text":"<pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if (\n            prev_count &lt; 0\n        ):  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = (\n            count + 1\n        )  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre>"},{"location":"heap/heap_top_k/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre>"},{"location":"heap/heap_two_heaps/","title":"Heap - Two Heaps","text":""},{"location":"heap/heap_two_heaps/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0295 - Find Median from Data Stream (Hard)</li> <li>0480 - Sliding Window Median (Hard)</li> <li>0502 - IPO (Hard)</li> </ol>"},{"location":"heap/heap_two_heaps/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"heap/heap_two_heaps/#480-sliding-window-median","title":"480. Sliding Window Median","text":"<pre><code>import heapq\nfrom typing import List\n\nfrom sortedcontainers import SortedList\n\n\n# Heap - Two Heaps\ndef medianSlidingWindow1(nums: List[int], k: int) -&gt; List[float]:\n    min_heap, max_heap = [], []\n\n    for i in range(k):\n        heapq.heappush(min_heap, (nums[i], i))\n    for i in range(k // 2):\n        n, idx = heapq.heappop(min_heap)\n        heapq.heappush(max_heap, (-n, idx))\n\n    res = [\n        (\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n    ]\n\n    for i in range(k, len(nums)):\n        if nums[i] &lt; min_heap[0][0]:\n            heapq.heappush(max_heap, (-nums[i], i))\n\n            if nums[i - k] &gt;= min_heap[0][0]:\n                n, idx = heapq.heappop(max_heap)\n                heapq.heappush(min_heap, (-n, idx))\n        else:\n            heapq.heappush(min_heap, (nums[i], i))\n\n            if nums[i - k] &lt;= min_heap[0][0]:\n                n, idx = heapq.heappop(min_heap)\n                heapq.heappush(max_heap, (-n, idx))\n\n        while min_heap and min_heap[0][1] &lt;= i - k:\n            heapq.heappop(min_heap)\n        while max_heap and max_heap[0][1] &lt;= i - k:\n            heapq.heappop(max_heap)\n\n        res.append(\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n\n    return res\n\n\n# Sorted List\ndef medianSlidingWindow2(nums: List[int], k: int) -&gt; List[float]:\n    window = SortedList()\n    res = []\n\n    for i in range(len(nums)):\n        window.add(nums[i])\n\n        if len(window) == k:\n            if k % 2 == 1:\n                res.append(window[k // 2])\n            else:\n                res.append((window[k // 2 - 1] + window[k // 2]) / 2.0)\n\n            window.remove(nums[i - k + 1])\n\n    return res\n\n\nnums = [1, 2, 3, 4, 2, 3, 1, 4, 2]\nk = 3\nprint(medianSlidingWindow1(nums, k))\nprint(medianSlidingWindow2(nums, k))\n</code></pre>"},{"location":"heap/heap_two_heaps/#502-ipo","title":"502. IPO","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(\n    k: int, w: int, profits: List[int], capital: List[int]\n) -&gt; int:\n    if not profits or not capital:\n        return w\n\n    minHeap = []\n    maxHeap = []\n\n    for i in range(len(profits)):\n        heapq.heappush(minHeap, (capital[i], profits[i]))\n\n    for _ in range(k):\n        while minHeap and minHeap[0][0] &lt;= w:\n            capital, profit = heapq.heappop(minHeap)\n            heapq.heappush(maxHeap, -profit)\n\n        if not maxHeap:\n            break\n\n        w += -heapq.heappop(maxHeap)\n\n    return w\n\n\nk = 2\nw = 0\nprofits = [1, 2, 3]\ncapital = [0, 1, 1]\nprint(findMaximizedCapital(k, w, profits, capital))  # 4\n</code></pre>"},{"location":"neetcode150/","title":"Neetcode 150","text":"<ul> <li>Neetcode - YouTube</li> <li>Website</li> </ul>"},{"location":"neetcode150/#to-do","title":"To Do","text":"<ul> <li> Arrays &amp; Hashing (9)<ol> <li>Contains Duplicate</li> <li>Valid Anagram</li> <li>Two Sum</li> <li>Group Anagrams</li> <li>Top K Frequent Elements</li> <li>Encode and Decode Strings</li> <li>Product of Array Except Self</li> <li>Valid Sudoku</li> <li>Longest Consecutive Sequence</li> </ol> </li> <li> Two Pointers (5)<ol> <li>Valid Palindrome</li> <li>Two Sum II Input Array Is Sorted</li> <li>3Sum</li> <li>Container With Most Water</li> <li>Trapping Rain Water</li> </ol> </li> <li> Sliding Window (6)<ol> <li>Best Time to Buy and Sell Stock</li> <li>Longest Substring Without Repeating Characters</li> <li>Longest Repeating Character Replacement</li> <li>Permutation In String</li> <li>Minimum Window Substring</li> <li>Sliding Window Maximum</li> </ol> </li> <li> Stack (7)<ol> <li>Valid Parentheses</li> <li>Min Stack</li> <li>Evaluate Reverse Polish Notation</li> <li>Generate Parentheses</li> <li>Daily Temperatures</li> <li>Car Fleet</li> <li>Largest Rectangle In Histogram</li> </ol> </li> <li> Binary Search (7)<ol> <li>Binary Search</li> <li>Search a 2D Matrix</li> <li>Koko Eating Bananas</li> <li>Find Minimum In Rotated Sorted Array</li> <li>Search In Rotated Sorted Array</li> <li>Time Based Key Value Store</li> <li>Median of Two Sorted Arrays</li> </ol> </li> <li> Linked List (11)<ol> <li>Reverse Linked List</li> <li>Merge Two Sorted Lists</li> <li>Reorder List</li> <li>Remove Nth Node From End of List</li> <li>Copy List With Random Pointer</li> <li>Add Two Numbers</li> <li>Linked List Cycle</li> <li>Find The Duplicate Number</li> <li>LRU Cache</li> <li>Merge K Sorted Lists</li> <li>Reverse Nodes In K Group</li> </ol> </li> <li> Trees (15)<ol> <li>Invert Binary Tree</li> <li>Maximum Depth of Binary Tree</li> <li>Diameter of Binary Tree</li> <li>Balanced Binary Tree</li> <li>Same Tree</li> <li>Subtree of Another Tree</li> <li>Lowest Common Ancestor of a Binary Search Tree</li> <li>Binary Tree Level Order Traversal</li> <li>Binary Tree Right Side View</li> <li>Count Good Nodes In Binary Tree</li> <li>Validate Binary Search Tree</li> <li>Kth Smallest Element In a Bst</li> <li>Construct Binary Tree From Preorder And Inorder Traversal</li> <li>Binary Tree Maximum Path Sum</li> <li>Serialize And Deserialize Binary Tree</li> </ol> </li> <li> Heap (7)<ol> <li>Kth Largest Element In a Stream</li> <li>Last Stone Weight</li> <li>K Closest Points to Origin</li> <li>Kth Largest Element In An Array</li> <li>Task Scheduler</li> <li>Design Twitter</li> <li>Find Median From Data Stream</li> </ol> </li> <li> Backtracking (9)<ol> <li>Subsets</li> <li>Combination Sum</li> <li>Permutations</li> <li>Subsets II</li> <li>Combination Sum II</li> <li>Word Search</li> <li>Palindrome Partitioning</li> <li>Letter Combinations of a Phone Number</li> <li>N Queens</li> </ol> </li> <li> Tries (3)<ol> <li>Implement Trie Prefix Tree</li> <li>Design Add And Search Words Data Structure</li> <li>Word Search II</li> </ol> </li> <li> Graphs (13)<ol> <li>Number of Islands</li> <li>Max Area of Island</li> <li>Clone Graph</li> <li>Walls And Gates</li> <li>Rotting Oranges</li> <li>Pacific Atlantic Water Flow</li> <li>Surrounded Regions</li> <li>Course Schedule</li> <li>Course Schedule II</li> <li>Graph Valid Tree</li> <li>Number of Connected Components In An Undirected Graph</li> <li>Redundant Connection</li> <li>Word Ladder</li> </ol> </li> <li> Advanced Graphs (6)<ol> <li>Reconstruct Itinerary</li> <li>Min Cost to Connect All Points</li> <li>Network Delay Time</li> <li>Swim In Rising Water</li> <li>Alien Dictionary</li> <li>Cheapest Flights Within K Stops</li> </ol> </li> <li> 1D Dynamic Programming (12)<ol> <li>Climbing Stairs</li> <li>Min Cost Climbing Stairs</li> <li>House Robber</li> <li>House Robber II</li> <li>Longest Palindromic Substring</li> <li>Palindromic Substrings</li> <li>Decode Ways</li> <li>Coin Change</li> <li>Maximum Product Subarray</li> <li>Word Break</li> <li>Longest Increasing Subsequence</li> <li>Partition Equal Subset Sum</li> </ol> </li> <li> 2D Dynamic Programming (11)<ol> <li>Unique Paths</li> <li>Longest Common Subsequence</li> <li>Best Time to Buy And Sell Stock With Cooldown</li> <li>Coin Change II</li> <li>Target Sum</li> <li>Interleaving String</li> <li>Longest Increasing Path In a Matrix</li> <li>Distinct Subsequences</li> <li>Edit Distance</li> <li>Burst Balloons</li> <li>Regular Expression Matching</li> </ol> </li> <li> Greedy (8)<ol> <li>Maximum Subarray</li> <li>Jump Game</li> <li>Jump Game II</li> <li>Gas Station</li> <li>Hand of Straights</li> <li>Merge Triplets to Form Target Triplet</li> <li>Partition Labels</li> <li>Valid Parenthesis String</li> </ol> </li> <li> Intervals (6)<ol> <li>Insert Interval</li> <li>Merge Intervals</li> <li>Non Overlapping Intervals</li> <li>Meeting Rooms</li> <li>Meeting Rooms II</li> <li>Minimum Interval to Include Each Query</li> </ol> </li> <li> Math &amp; Geometry (8)<ol> <li>Rotate Image</li> <li>Spiral Matrix</li> <li>Set Matrix Zeroes</li> <li>Happy Number</li> <li>Plus One</li> <li>Pow(x, n)</li> <li>Multiply Strings</li> <li>Detect Squares</li> </ol> </li> <li> Bit Manipulation (7)<ol> <li>Single Number</li> <li>Number of 1 Bits</li> <li>Counting Bits</li> <li>Reverse Bits</li> <li>Missing Number</li> <li>Sum of Two Integers</li> <li>Reverse Integer</li> </ol> </li> </ul>"},{"location":"neetcode150/1d_dynamic_programming/","title":"1-D Dynamic Programming","text":""},{"location":"neetcode150/1d_dynamic_programming/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0070 - Climbing Stairs (Easy)</li> <li>0746 - Min Cost Climbing Stairs (Easy)</li> <li>0198 - House Robber (Easy)</li> <li>0213 - House Robber II (Medium)</li> <li>0005 - Longest Palindromic Substring (Medium)</li> <li>0647 - Palindromic Substrings (Medium)</li> <li>0091 - Decode Ways (Medium)</li> <li>0322 - Coin Change (Medium)</li> <li>0152 - Maximum Product Subarray (Medium)</li> </ol>"},{"location":"neetcode150/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 12\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#213-house-robber-ii","title":"213. House Robber II","text":"<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n    print(dp)\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li>Return the number of ways to decode a string of digits.</li> </ul> <pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/","title":"2-D Dynamic Programming","text":""},{"location":"neetcode150/2d_dynamic_programming/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0062 - Unique Paths (Medium)</li> <li>1143 - Longest Common Subsequence (Medium)</li> <li>0309 - Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li>0518 - Coin Change 2 (Medium)</li> <li>0494 - Target Sum (Medium)</li> <li>0097 - Interleaving String (Hard)</li> <li>0329 - Longest Increasing Path in a Matrix (Hard)</li> </ol>"},{"location":"neetcode150/2d_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n            if res &lt; dp[i][j]:\n                res = dp[i][j]\n\n    return res\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#518-coin-change-2","title":"518. Coin Change 2","text":"<pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#494-target-sum","title":"494. Target Sum","text":"<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#97-interleaving-string","title":"97. Interleaving String","text":"<pre><code># DP - 2D\ndef isInterleaveDP(s1: str, s2: str, s3: str) -&gt; bool:\n    m, n, k = len(s1), len(s2), len(s3)\n\n    if m + n != k:\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (\n                dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n            )\n\n    return dp[m][n]\n\n\n# DFS\ndef isInterleaveDFS(s1: str, s2: str, s3: str) -&gt; bool:\n    memo = {}\n\n    def dfs(i, j, k):\n        if i == len(s1) and j == len(s2) and k == len(s3):\n            return True\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        res = False\n\n        if i &lt; len(s1) and k &lt; len(s3) and s1[i] == s3[k]:\n            res |= dfs(i + 1, j, k + 1)\n\n        if j &lt; len(s2) and k &lt; len(s3) and s2[j] == s3[k]:\n            res |= dfs(i, j + 1, k + 1)\n\n        memo[(i, j)] = res\n\n        return res\n\n    return dfs(0, 0, 0)\n\n\ns1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbbaccc\"\nprint(isInterleaveDP(s1, s2, s3))  # False\nprint(isInterleaveDFS(s1, s2, s3))  # False\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":""},{"location":"neetcode150/advanced_graphs/","title":"Advanced Graphs","text":""},{"location":"neetcode150/advanced_graphs/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0332 - Reconstruct Itinerary (Medium)</li> <li>1584 - Min Cost to Connect All Points (Medium)</li> <li>0743 - Network Delay Time (Medium)</li> <li>0778 - Swim in Rising Water (Hard)</li> <li>0269 - Alien Dictionary (Hard)</li> <li>0787 - Cheapest Flights Within K Stops (Medium)</li> </ol>"},{"location":"neetcode150/advanced_graphs/#332-reconstruct-itinerary","title":"332. Reconstruct Itinerary","text":"<ul> <li>Return the itinerary in order that visits every airport exactly once.</li> <li>The starting airport is <code>JFK</code>.</li> <li>If there are multiple valid itineraries, return the lexicographically smallest one.</li> <li>Eulerian path: A path that visits every edge exactly once.</li> </ul> <pre><code>graph TD\nJFK((JFK))\nSFO((SFO))\nATL((ATL))\nJFK --&gt; SFO\nSFO --&gt; ATL\nATL --&gt; JFK\nJFK --&gt; ATL\nATL --&gt; SFO</code></pre> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hierholzer\ndef findItinerary1(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    for u, v in sorted(tickets, reverse=True):\n        graph[u].append(v)\n\n    route = []\n\n    def dfs(node):\n        while graph[node]:\n            dest = graph[node].pop()\n            dfs(dest)\n        route.append(node)\n\n    dfs(\"JFK\")\n\n    return route[::-1]\n\n\n# Backtracking\ndef findItinerary2(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    tickets.sort()\n    for u, v in tickets:\n        graph[u].append(v)\n\n    route = [\"JFK\"]\n\n    def backtraking(node):\n        if len(route) == len(tickets) + 1:\n            return True\n        if node not in graph:\n            return False\n\n        temp = list(graph[node])\n        for i, v in enumerate(temp):\n            graph[node].pop(i)\n            route.append(v)\n\n            if backtraking(v):\n                return True\n\n            graph[node].insert(i, v)\n            route.pop()\n\n        return False\n\n    backtraking(\"JFK\")\n\n    return route\n\n\ntickets = tickets = [\n    [\"JFK\", \"SFO\"],\n    [\"JFK\", \"ATL\"],\n    [\"SFO\", \"ATL\"],\n    [\"ATL\", \"JFK\"],\n    [\"ATL\", \"SFO\"],\n]\nprint(findItinerary1(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nprint(findItinerary2(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#743-network-delay-time","title":"743. Network Delay Time","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\")] * n\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n\n        for s, d, p in flights:\n            if prices[s] == float(\"inf\"):\n                continue\n            if prices[s] + p &lt; temp_prices[d]:\n                temp_prices[d] = prices[s] + p\n\n        prices = temp_prices\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"neetcode150/arrays_hashing/","title":"Arrays &amp; Hashing","text":"<ol> <li>0217 - Contains Duplicate (Easy)</li> <li>0242 - Valid Anagram (Easy)</li> <li>0001 - Two Sum (Easy)</li> <li>0049 - Group Anagrams (Medium)</li> <li>0347 - Top K Frequent Elements (Medium)</li> <li>0271 - Encode and Decode Strings (Medium)</li> <li>0238 - Product of Array Except Self (Medium)</li> <li>0036 - Valid Sudoku (Medium)</li> <li>0128 - Longest Consecutive Sequence (Medium)</li> </ol>"},{"location":"neetcode150/arrays_hashing/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li>Return <code>True</code> if the array contains any duplicates, otherwise return <code>False</code>.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li>Return <code>True</code> if <code>t</code> is an anagram of <code>s</code>, otherwise return <code>False</code>.</li> </ul> <pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> <pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = dict()  # {val: idx}\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n        hashmap[val] = idx\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Hashmap    |      O(n)       |    O(n)      |\n# |-------------|-----------------|--------------|\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nprint(twoSum(nums, target))  # [1, 2]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li>Given an array of strings <code>strs</code>, group the anagrams together.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li>Return the <code>k</code> most frequent elements in the array.</li> </ul> <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# 1. Heap + Counter\ndef topKFrequent1(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, count in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (count, val))\n        else:\n            heapq.heappushpop(minHeap, (count, val))\n\n    return [i for (_, i) in minHeap]\n\n\n# 2. Heap + Dict\ndef topKFrequent2(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    counts = dict()\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for val, count in counts.items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (count, val))\n        else:\n            heapq.heappushpop(minHeap, (count, val))\n\n    return [i for (_, i) in minHeap]\n\n\n# 3. Counter - Most Common\ndef topKFrequent3(nums: List[int], k: int) -&gt; List[int]:\n    common = Counter(nums).most_common(k)\n    return [i for i, _ in common]\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Heap      |    O(n)     |    O(n)      |\n# |   Counter   |    O(n)     |    O(n)      |\n# |-------------|-------------|--------------|\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent1(nums, k))  # [2, 1]\nprint(topKFrequent2(nums, k))  # [2, 1]\nprint(topKFrequent3(nums, k))  # [1, 2]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<ul> <li>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</li> </ul> <pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# 2. Prefix - Optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |    Prefix   |    O(n)     |    O(n)      |\n# |Prefix - Opt |    O(n)     |    O(1)      |\n# |-------------|-------------|--------------|\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<ul> <li>Determine if a <code>9x9</code> Sudoku board is valid.</li> <li>Only the filled cells need to be validated according to the following rules:<ul> <li>Each row must contain the digits <code>1-9</code> without repetition.</li> <li>Each column must contain the digits <code>1-9</code> without repetition.</li> <li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li> </ul> </li> </ul> <pre><code>from typing import List\n\n\n# Set\ndef isValidSudoku(board: List[List[str]]) -&gt; bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == \".\":\n                continue\n\n            if board[i][j] in rows[i]:\n                return False\n            rows[i].add(board[i][j])\n\n            if board[i][j] in cols[j]:\n                return False\n            cols[j].add(board[i][j])\n\n            box_index = (i // 3) * 3 + j // 3\n            if board[i][j] in boxes[box_index]:\n                return False\n            boxes[box_index].add(board[i][j])\n\n    return True\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\nprint(isValidSudoku(board))  # True\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li>Given an unsorted array of integers <code>nums</code>, return the length of the longest consecutive elements sequence.</li> </ul> <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"neetcode150/backtracking/","title":"Backtracking","text":""},{"location":"neetcode150/backtracking/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0078 - Subsets (Medium)</li> <li>0039 - Combination Sum (Medium)</li> <li>0046 - Permutations (Medium)</li> <li>0079 - Word Search (Medium)</li> <li>0131 - Palindrome Partitioning (Medium)</li> </ol>"},{"location":"neetcode150/backtracking/#78-subsets","title":"78. Subsets","text":"<pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"neetcode150/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"neetcode150/backtracking/#46-permutations","title":"46. Permutations","text":"<pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"neetcode150/backtracking/#79-word-search","title":"79. Word Search","text":"<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"neetcode150/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<pre><code>from typing import List\n\n\ndef partition(s: str) -&gt; List[List[str]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if startIndex == len(s):\n            result.append(path[:])\n            return None\n\n        for i in range(startIndex, len(s)):\n            if is_palindrome(s, startIndex, i):\n                path.append(s[startIndex : i + 1])\n                backtracking(i + 1)\n                path.pop()\n\n    def is_palindrome(s: str, start, end) -&gt; bool:\n        while start &lt; end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n\n        return True\n\n    backtracking(0)\n\n    return result\n\n\nprint(partition(\"aab\"))  # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"neetcode150/binary_search/","title":"Binary Search","text":""},{"location":"neetcode150/binary_search/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0704 - Binary Search (Easy)</li> <li>0074 - Search a 2D Matrix (Medium)</li> <li>0875 - Koko Eating Bananas (Medium)</li> <li>0004 - Median of Two Sorted Arrays (Hard)</li> </ol>"},{"location":"neetcode150/binary_search/#704-binary-search","title":"704. Binary Search","text":"<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &gt; target:\n            right = mid - 1\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            return mid\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"neetcode150/binary_search/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        mid_value = matrix[mid // n][mid % n]\n\n        if mid_value == target:\n            return True\n        elif mid_value &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nmatrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\ntarget = 3\nprint(searchMatrix(matrix, target))  # True\n</code></pre>"},{"location":"neetcode150/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"neetcode150/binary_search/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"neetcode150/bit/","title":"Bit Manipulation","text":""},{"location":"neetcode150/bit/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0191 - Number of 1 Bits (Easy)</li> <li>0338 - Counting Bits (Medium)</li> <li>0190 - Reverse Bits (Easy)</li> <li>0268 - Missing Number (Easy)</li> <li>0371 - Sum of Two Integers (Medium)</li> </ol>"},{"location":"neetcode150/bit/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li>Return the number of '1' bits in the binary representation of <code>n</code>.</li> </ul> <pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    count = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        count += 1\n\n    return count\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n</code></pre>"},{"location":"neetcode150/bit/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li>Return an array <code>ans</code> of the number of '1' bits in the binary representation of every number in the range <code>[0, n]</code>.</li> </ul> <pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"neetcode150/bit/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li>Reverse the bits of an unsigned integer.</li> </ul> <pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"neetcode150/bit/#268-missing-number","title":"268. Missing Number","text":"<ul> <li>Return the missing number in the range <code>[0, n]</code>.</li> </ul> <pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre>"},{"location":"neetcode150/bit/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li>Return the sum of two integers <code>a</code> and <code>b</code> without using the operators <code>+</code> and <code>-</code>.</li> </ul> <pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"neetcode150/graphs/","title":"Graphs","text":""},{"location":"neetcode150/graphs/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0200 - Number of Islands (Medium)</li> <li>0695 - Max Area of Island (Medium)</li> <li>0133 - Clone Graph (Medium)</li> <li>0286 - Walls and Gates (Medium)</li> <li>0994 - Rotting Oranges (Medium)</li> <li>0417 - Pacific Atlantic Water Flow (Medium)</li> <li>0130 - Surrounded Regions (Medium)</li> <li>0207 - Course Schedule (Medium)</li> <li>0210 - Course Schedule II (Medium)</li> <li>0261 - Graph Valid Tree (Medium)</li> <li>0323 - Number of Connected Components in an Undirected Graph (Medium)</li> <li>0684 - Redundant Connection (Medium)</li> <li>0127 - Word Ladder (Medium)</li> </ol>"},{"location":"neetcode150/graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == \"0\":\n            return None\n\n        grid[r][c] = \"0\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                ):\n                    continue\n                q.append((nr, nc))\n                grid[nr][nc] = \"0\"\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                grid[r][c] = \"0\"\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"neetcode150/graphs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    visited = set()\n    area = 0\n\n    def dfs(r, c):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return 0\n\n        visited.add((r, c))\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1)\n        )\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"neetcode150/graphs/#133-clone-graph","title":"133. Clone Graph","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre>"},{"location":"neetcode150/graphs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            r in range(m)\n            and c in range(n)\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nrooms = [\n    [2147483647, -1, 0, 2147483647],\n    [2147483647, 2147483647, 2147483647, -1],\n    [2147483647, -1, 2147483647, -1],\n    [0, -1, 2147483647, 2147483647],\n]\nwallsAndGates(rooms)\nprint(rooms)\n# [[3, -1, 0,  1],\n#  [2,  2, 1, -1],\n#  [1, -1, 2, -1],\n#  [0, -1, 3,  4]]\n</code></pre>"},{"location":"neetcode150/graphs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    # 1. Init\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    # 2. Make a queue of rotten oranges and count fresh oranges\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    # 3. BFS\n    while q and fresh &gt; 0:\n        size = len(q)\n\n        for _ in range(size):\n            r, c = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if nr &lt; 0 or nc &lt; 0 or nr &gt;= m or nc &gt;= n or grid[nr][nc] != 1:\n                    continue\n                grid[nr][nc] = 2\n                q.append([nr, nc])\n                fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"neetcode150/graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"neetcode150/graphs/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom typing import List\n\n\n# 1. DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r not in range(m) or c not in range(n) or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# 2. BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and board[nr][nc] == \"O\":\n                    q.append((nr, nc))\n                    board[nr][nc] = \"T\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nboard = [\n    [\"X\", \"X\", \"X\", \"X\"],\n    [\"X\", \"O\", \"O\", \"X\"],\n    [\"X\", \"X\", \"O\", \"X\"],\n    [\"X\", \"O\", \"X\", \"X\"],\n]\nboard1 = deepcopy(board)\nsolveDFS(board1)\npprint(board1)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n\nboard2 = deepcopy(board)\nsolveBFS(board2)\npprint(board2)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n</code></pre>"},{"location":"neetcode150/graphs/#207-course-schedule","title":"207. Course Schedule","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visited = set()\n\n    def dfs(crs):\n        if crs in visited:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visited.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    visited = [0] * numCourses\n\n    def dfs(crs):\n        if visited[crs] == 1:  # cycle detected\n            return False\n        if visited[crs] == 2:\n            return True\n\n        visited[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"neetcode150/graphs/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"neetcode150/graphs/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"neetcode150/graphs/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    parent = [i for i in range(n)]\n    rank = [1 for _ in range(n)]\n\n    def find(node):\n        root = node\n\n        while root != parent[root]:\n            parent[root] = parent[parent[root]]\n            root = parent[root]\n        return root\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if rank[p2] &gt; rank[p1]:\n            parent[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            parent[p2] = p1\n            rank[p1] += rank[p2]\n        return 1\n\n    count = n\n    for n1, n2 in edges:\n        count -= union(n1, n2)\n\n    return count\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))\n</code></pre>"},{"location":"neetcode150/graphs/#684-redundant-connection","title":"684. Redundant Connection","text":"<pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    par = {i: i for i in range(len(edges) + 1)}\n    rank = {i: 1 for i in range(len(edges) + 1)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n        else:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n\n        return True\n\n    for n1, n2 in edges:\n        if not union(n1, n2):\n            return (n1, n2)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"neetcode150/graphs/#127-word-ladder","title":"127. Word Ladder","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # Edge case\n    if endWord not in wordList:\n        return 0\n\n    # Init\n    graph = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    # BFS\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\n# |------------|---------|---------|\n# |  Approach  |  Time   |  Space  |\n# |------------|---------|---------|\n# |    BFS     | O(n*m^2)| O(n*m)  |\n# |------------|---------|---------|\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"neetcode150/greedy/","title":"Greedy","text":""},{"location":"neetcode150/greedy/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0053 - Maximum Subarray (Easy)</li> <li>0055 - Jump Game (Medium)</li> <li>0045 - Jump Game II (Medium)</li> <li>0134 - Gas Station (Medium)</li> <li>0846 - Hand of Straights (Medium)</li> <li>1899 - Merge Triplets to Form Target Triplet (Medium)</li> <li>0763 - Partition Labels (Medium)</li> <li>0678 - Valid Parenthesis String (Medium)</li> </ol>"},{"location":"neetcode150/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"neetcode150/greedy/#55-jump-game","title":"55. Jump Game","text":"<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    reach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= reach:\n        reach = max(reach, i + nums[i])\n        if reach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"neetcode150/greedy/#45-jump-game-ii","title":"45. Jump Game II","text":"<pre><code>from typing import List\n\n\ndef jump(nums: List[int]) -&gt; int:\n    if len(nums) == 1:\n        return 0\n\n    cover = 0\n    count = 0\n    i = 0\n\n    while cover &gt;= 0:\n        for i in range(i, cover + 1):\n            cover = max(cover, nums[i] + i)\n            if cover &gt;= len(nums) - 1:\n                return count + 1\n        count += 1\n\n    return count\n\n\nprint(jump([2, 3, 1, 1, 4]))  # 2\n</code></pre>"},{"location":"neetcode150/greedy/#134-gas-station","title":"134. Gas Station","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre>"},{"location":"neetcode150/greedy/#846-hand-of-straights","title":"846. Hand of Straights","text":""},{"location":"neetcode150/greedy/#1899-merge-triplets-to-form-target-triplet","title":"1899. Merge Triplets to Form Target Triplet","text":"<pre><code>from typing import List\n\n\ndef mergeTriplets(triplets: List[List[int]], target: List[int]) -&gt; bool:\n    can_form = [False, False, False]\n\n    for triplet in triplets:\n        if all(triplet[i] &lt;= target[i] for i in range(3)):\n            for i in range(3):\n                if triplet[i] == target[i]:\n                    can_form[i] = True\n\n    return all(can_form)\n\n\ntriplets = [[2, 5, 3], [1, 8, 4], [1, 7, 5]]\ntarget = [2, 7, 5]\nprint(mergeTriplets(triplets, target))  # True\n</code></pre>"},{"location":"neetcode150/greedy/#763-partition-labels","title":"763. Partition Labels","text":"<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    # Time complexity: O(nlogn)\n    # Space complexity: O(n)\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    result = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            result.append(intervals[i][0])\n\n    result.append(intervals[-1][1] + 1)\n\n    if len(result) == 1:\n        return result\n    else:\n        for i in range(len(result) - 1, 0, -1):\n            result[i] -= result[i - 1]\n        return result\n\n\n# 2. Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    last = {c: i for i, c in enumerate(s)}\n\n    start, end = 0, 0\n    result = []\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if i == end:\n            result.append(end - start + 1)\n            start = i + 1\n\n    return result\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"neetcode150/greedy/#678-valid-parenthesis-string","title":"678. Valid Parenthesis String","text":"<pre><code># Greedy\ndef checkValidString(s: str) -&gt; bool:\n    min_open, max_open = 0, 0\n\n    for char in s:\n        if char == \"(\":\n            min_open += 1\n            max_open += 1\n        elif char == \")\":\n            min_open = max(min_open - 1, 0)\n            max_open -= 1\n        elif char == \"*\":\n            min_open = max(min_open - 1, 0)\n            max_open += 1\n\n        if max_open &lt; 0:\n            return False\n\n    return min_open == 0\n\n\ns = \"(*))\"\nprint(checkValidString(s))  # True\n</code></pre>"},{"location":"neetcode150/heap/","title":"Heap (Priority Queue)","text":""},{"location":"neetcode150/heap/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0703 - Kth Largest Element in a Stream (Easy)</li> <li>1046 - Last Stone Weight (Easy)</li> <li>0973 - K Closest Points to Origin (Medium)</li> <li>0621 - Task Scheduler (Medium)</li> <li>0355 - Design Twitter (Medium)</li> <li>0295 - Find Median from Data Stream (Hard)</li> </ol>"},{"location":"neetcode150/heap/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"neetcode150/heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n    dp = [0 for _ in range(target + 1)]\n\n    for stone in stones:\n        for j in range(target, stone - 1, -1):\n            dp[j] = max(dp[j], dp[j - stone] + stone)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"neetcode150/heap/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"neetcode150/heap/#621-task-scheduler","title":"621. Task Scheduler","text":"<pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"neetcode150/heap/#355-design-twitter","title":"355. Design Twitter","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"neetcode150/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"neetcode150/intervals/","title":"Intervals","text":""},{"location":"neetcode150/intervals/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0057 - Insert Interval (Hard)</li> <li>0056 - Merge Intervals (Medium)</li> <li>0435 - Non-overlapping Intervals (Medium)</li> <li>0252 - Meeting Rooms (Easy)</li> <li>0253 - Meeting Rooms II (Medium)</li> </ol>"},{"location":"neetcode150/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"neetcode150/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<pre><code>from typing import List\n\n\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt;= result[-1][1]:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"neetcode150/intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"neetcode150/intervals/#252-meeting-rooms","title":"252. Meeting Rooms","text":"<pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(canAttendMeetings(intervals))  # False\n</code></pre>"},{"location":"neetcode150/intervals/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    heap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= heap[0]:\n            heapq.heappop(heap)\n        heapq.heappush(heap, intervals[i][1])\n\n    return len(heap)\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(minMeetingRooms(intervals))  # 2\n</code></pre>"},{"location":"neetcode150/linked_list/","title":"Linked List","text":""},{"location":"neetcode150/linked_list/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0206 - Reverse Linked List (Easy)</li> <li>0021 - Merge Two Sorted Lists (Easy)</li> <li>0143 - Reorder List (Medium)</li> <li>0019 - Remove Nth Node From End of List (Medium)</li> <li>0138 - Copy List with Random Pointer (Medium)</li> <li>0002 - Add Two Numbers (Medium)</li> <li>0141 - Linked List Cycle (Easy)</li> </ol>"},{"location":"neetcode150/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li>Reverse a singly linked list.</li> </ul> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# 1. Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# 2. Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"neetcode150/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li>Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.</li> </ul> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre>"},{"location":"neetcode150/linked_list/#143-reorder-list","title":"143. Reorder List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\nhead = ListNode.create([1, 2, 3, 4, 5, 6])\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nreorderList(head)\nprint(head)  # 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n</code></pre>"},{"location":"neetcode150/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))\n# 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"neetcode150/linked_list/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"neetcode150/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val=val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\n\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre>"},{"location":"neetcode150/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"neetcode150/math_geometry/","title":"Math &amp; Geometry","text":""},{"location":"neetcode150/math_geometry/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0048 - Rotate Image (Medium)</li> <li>0054 - Spiral Matrix (Medium)</li> <li>0073 - Set Matrix Zeroes (Medium)</li> <li>0202 - Happy Number (Easy)</li> <li>0066 - Plus One (Easy)</li> <li>0050 - Pow(x, n) (Medium)</li> <li>0043 - Multiply Strings (Medium)</li> <li>0166 - Fraction to Recurring Decimal (Medium)</li> </ol>"},{"location":"neetcode150/math_geometry/#48-rotate-image","title":"48. Rotate Image","text":"<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"neetcode150/math_geometry/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"neetcode150/math_geometry/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre>"},{"location":"neetcode150/math_geometry/#202-happy-number","title":"202. Happy Number","text":"<pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"neetcode150/math_geometry/#66-plus-one","title":"66. Plus One","text":"<pre><code>from typing import List\n\n\n# Math\ndef plusOne(digits: List[int]) -&gt; List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] &lt; 9:\n            digits[i] += 1\n            return digits\n        else:\n            digits[i] = 0\n\n    return [1] + digits\n\n\ndigits = [4, 3, 2, 1]\nprint(plusOne(digits))  # [4, 3, 2, 2]\n</code></pre>"},{"location":"neetcode150/math_geometry/#50-powx-n","title":"50. Pow(x, n)","text":"<pre><code># Iterative\ndef myPowIterative(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    result = 1\n    cur = x\n\n    while n &gt; 0:\n        if n % 2 == 1:\n            result *= cur\n\n        cur *= cur\n        n //= 2\n\n    return result\n\n\n# Recursive\ndef myPowRecursive(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    if n % 2 == 0:\n        return myPowRecursive(x * x, n // 2)\n    else:\n        return x * myPowRecursive(x * x, n // 2)\n\n\nx = 2.00000\nn = 10\nprint(myPowIterative(x, n))  # 1024.0\nprint(myPowRecursive(x, n))  # 1024.0\n</code></pre>"},{"location":"neetcode150/math_geometry/#43-multiply-strings","title":"43. Multiply Strings","text":"<pre><code># Math\ndef multiply(num1: str, num2: str) -&gt; str:\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n\n    m, n = len(num1), len(num2)\n    result = [0 for _ in range(m + n)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            mul = int(num1[i]) * int(num2[j])\n            sum = mul + result[i + j + 1]\n\n            result[i + j + 1] = sum % 10\n            result[i + j] += sum // 10\n\n    result_str = \"\".join(map(str, result)).lstrip(\"0\")\n\n    return result_str if result_str else \"0\"\n\n\nnum1 = \"2\"\nnum2 = \"3\"\nprint(multiply(num1, num2))  # \"6\"\n</code></pre>"},{"location":"neetcode150/math_geometry/#166-fraction-to-recurring-decimal","title":"166. Fraction to Recurring Decimal","text":"<pre><code># Math\ndef fractionToDecimal(numerator: int, denominator: int) -&gt; str:\n    if numerator == 0:\n        return \"0\"\n\n    res = []\n\n    if (numerator &lt; 0) ^ (denominator &lt; 0):\n        res.append(\"-\")\n\n    numerator, denominator = abs(numerator), abs(denominator)\n\n    # Integer part\n    res.append(str(numerator // denominator))\n    remainder = numerator % denominator\n\n    if remainder == 0:\n        return \"\".join(res)\n\n    res.append(\".\")\n\n    # Dictionary to store remainders and their corresponding indices\n    remainder_map = {}\n\n    while remainder != 0:\n        if remainder in remainder_map:\n            res.insert(remainder_map[remainder], \"(\")\n            res.append(\")\")\n            break\n\n        remainder_map[remainder] = len(res)\n        remainder *= 10\n        res.append(str(remainder // denominator))\n        remainder %= denominator\n\n    return \"\".join(res)\n\n\nnumerator = 4\ndenominator = 333\nprint(fractionToDecimal(numerator, denominator))  # 0.(012)\n</code></pre>"},{"location":"neetcode150/sliding_window/","title":"Sliding Window","text":""},{"location":"neetcode150/sliding_window/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0121 - Best Time to Buy and Sell Stock (Easy)</li> <li>0003 - Longest Substring Without Repeating Characters (Medium)</li> <li>0424 - Longest Repeating Character Replacement (Medium)</li> <li>0076 - Minimum Window Substring (Hard)</li> <li>0567 - Permutation in String (Medium)</li> <li>0239 - Sliding Window Maximum (Hard)</li> </ol>"},{"location":"neetcode150/sliding_window/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li>Return the maximum profit you can achieve from buying on one day and selling on another day.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"neetcode150/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li>Return the length of the longest substring without repeating characters.</li> </ul> <pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(len(s)):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"neetcode150/sliding_window/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li>Return the length of the longest substring that contains at most <code>k</code> distinct characters.</li> </ul> <pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"neetcode150/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li>Return the minimum window in <code>s</code> that contains all the characters in <code>t</code>.</li> </ul> <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"neetcode150/sliding_window/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li>Return <code>True</code> if <code>s2</code> contains the permutation of <code>s1</code>, otherwise return <code>False</code>.</li> </ul> <pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"neetcode150/stack/","title":"Stack","text":""},{"location":"neetcode150/stack/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0020 - Valid Parentheses (Easy)</li> <li>0155 - Min Stack (Easy)</li> <li>0150 - Evaluate Reverse Polish Notation (Medium)</li> <li>0022 - Generate Parentheses (Medium)</li> <li>0739 - Daily Temperatures (Medium)</li> <li>0853 - Car Fleet (Medium)</li> <li>0084 - Largest Rectangle in Histogram (Hard)</li> </ol>"},{"location":"neetcode150/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"neetcode150/stack/#155-min-stack","title":"155. Min Stack","text":"<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"neetcode150/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"neetcode150/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<pre><code>from typing import List\n\n\n# Stack\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"neetcode150/stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    result = [0 for _ in range(len(temperatures))]\n    stack = []\n\n    for idx, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, last_index = stack.pop()\n            result[last_index] = idx - last_index\n\n        stack.append([temp, idx])\n\n    return result\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"neetcode150/stack/#853-car-fleet","title":"853. Car Fleet","text":"<pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"neetcode150/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"neetcode150/trees/","title":"Trees","text":""},{"location":"neetcode150/trees/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0226 - Invert Binary Tree (Easy)</li> <li>0104 - Maximum Depth of Binary Tree (Easy)</li> <li>0543 - Diameter of Binary Tree (Easy)</li> <li>0110 - Balanced Binary Tree (Easy)</li> <li>0100 - Same Tree (Easy)</li> <li>0572 - Subtree of Another Tree (Easy)</li> <li>0235 - Lowest Common Ancestor of a Binary Search Tree (Easy)</li> <li>0102 - Binary Tree Level Order Traversal (Medium)</li> <li>0199 - Binary Tree Right Side View (Medium)</li> <li>1448 - Count Good Nodes in Binary Tree (Medium)</li> <li>0098 - Validate Binary Search Tree (Medium)</li> <li>0230 - Kth Smallest Element in a BST (Medium)</li> <li>0105 - Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li>0124 - Binary Tree Maximum Path Sum (Hard)</li> <li>0297 - Serialize and Deserialize Binary Tree (Hard)</li> </ol>"},{"location":"neetcode150/trees/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"neetcode150/trees/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return depth\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    return 1 + max(maxDepthRecursive(root.left), maxDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthRecursive(root))  # 4\n</code></pre>"},{"location":"neetcode150/trees/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# Tree DFS\ndef diameterOfBinaryTree(root: Optional[TreeNode]) -&gt; int:\n    diameter = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left = dfs(node.left)\n        right = dfs(node.right)\n\n        nonlocal diameter\n        diameter = max(diameter, left + right)\n\n        return 1 + max(left, right)\n\n    dfs(root)\n    return diameter\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n)    | O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nprint(diameterOfBinaryTree(root))  # 3\n</code></pre>"},{"location":"neetcode150/trees/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"neetcode150/trees/#100-same-tree","title":"100. Same Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"neetcode150/trees/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre>"},{"location":"neetcode150/trees/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"neetcode150/trees/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"neetcode150/trees/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    right = []\n\n    while q:\n        n = len(q)\n\n        for i in range(n):\n            cur = q.popleft()\n\n            # rightmost element\n            if i == n - 1:\n                right.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n    return right\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"neetcode150/trees/#1448-count-good-nodes-in-binary-tree","title":"1448. Count Good Nodes in Binary Tree","text":"<pre><code>from typing import List\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# Tree\ndef goodNodes(root: TreeNode) -&gt; int:\n    def dfs(node, max_val):\n        if not node:\n            return 0\n\n        good = 1 if node.val &gt;= max_val else 0\n\n        max_val = max(max_val, node.val)\n\n        good += dfs(node.left, max_val)\n        good += dfs(node.right, max_val)\n\n        return good\n\n    return dfs(root, root.val)\n\n\nroot = build([3, 1, 4, 3, None, 1, 5])\nprint(root)\n#     3__\n#    /   \\\n#   1     4\n#  /     / \\\n# 3     1   5\nprint(goodNodes(root))  # 4\n</code></pre>"},{"location":"neetcode150/trees/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"neetcode150/trees/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"neetcode150/trees/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"neetcode150/trees/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"neetcode150/trees/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"neetcode150/tries/","title":"Tries","text":""},{"location":"neetcode150/tries/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0208 - Implement Trie (Prefix Tree) (Medium)</li> <li>0211 - Add and Search Word - Data structure design (Medium)</li> <li>0212 - Word Search II (Hard)</li> </ol>"},{"location":"neetcode150/tries/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"neetcode150/tries/#211-add-and-search-word-data-structure-design","title":"211. Add and Search Word - Data structure design","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"neetcode150/tries/#212-word-search-ii","title":"212. Word Search II","text":"<pre><code>from typing import List\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\n    def addWord(self, word):\n        node = self\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.isWord = True\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for w in words:\n        root.addWord(w)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"neetcode150/two_pointers/","title":"Two Pointers","text":""},{"location":"neetcode150/two_pointers/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0125 - Valid Palindrome (Easy)</li> <li>0167 - Two Sum II - Input array is sorted (Easy)</li> <li>0015 - 3Sum (Medium)</li> <li>0011 - Container With Most Water (Medium)</li> <li>0042 - Trapping Rain Water (Hard)</li> </ol>"},{"location":"neetcode150/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li>Given a string <code>s</code>, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</li> </ul> <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"neetcode150/two_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input array is sorted","text":"<ul> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"neetcode150/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li>Return all the unique triplets that sum up to a specific target.</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# |-----------|---------|---------|\n# | Approach  |   Time  |  Space  |\n# |-----------|---------|---------|\n# | LR Pointer|  O(n^2) |   O(1)  |\n# |-----------|---------|---------|\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))  # [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"neetcode150/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"neetcode150/two_pointers/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li>Return the total amount of water that can be trapped.</li> </ul> <pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n    n = len(height)\n\n    max_left = [0 for _ in range(n)]\n    max_right = [0 for _ in range(n)]\n\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        max_right[i] = max(max_right[i + 1], height[i + 1])\n\n    total = 0\n\n    for i in range(n):\n        min_height = min(max_left[i], max_right[i])\n        if min_height &gt; height[i]:\n            total += min_height - height[i]\n\n    return total\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    total = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            total += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            total += maxR - height[right]\n\n    return total\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | DP         |  O(N)  |  O(N)   |\n# | Left Right |  O(N)  |  O(1)   |\n# | Monotonic  |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"other/","title":"Other","text":""},{"location":"other/bit/","title":"Bit Manipulation","text":""},{"location":"other/linked_list/","title":"Linked List","text":""},{"location":"other/linked_list/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0203 - Remove Linked List Elements (Easy)</li> <li>0707 - Design Linked List (Medium)</li> <li>0206 - Reverse Linked List (Easy)</li> <li>0237 - Delete Node in a Linked List (Easy)</li> <li>2487 - Remove Nodes From Linked List (Medium)</li> <li>0024 - Swap Nodes in Pairs (Medium)</li> <li>0019 - Remove Nth Node From End of List (Medium)</li> <li>0160 - Intersection of Two Linked Lists (Easy)</li> <li>0141 - Linked List Cycle (Easy)</li> <li>0142 - Linked List Cycle II (Medium)</li> <li>2816 - Double a Number Represented as a Linked List (Medium)</li> <li>0002 - Add Two Numbers (Medium)</li> </ol>"},{"location":"other/linked_list/#203-remove-linked-list-elements","title":"203. Remove Linked List Elements","text":"<ul> <li> <p>Remove all elements from a linked list of integers that have value <code>val</code>.</p> </li> <li> <p>Before</p> </li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[6]\nC --&gt; D[3]\nD --&gt; E[4]\nE --&gt; F[5]\nF --&gt; G[6]\nG --&gt; H[None]</code></pre> <ul> <li>After</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB -.-&gt; C[6]\nC -.-&gt; D[3]\nD --&gt; E[4]\nE --&gt; F[5]\nF -.-&gt; G[6]\nB --&gt; D[3]\nF --&gt; I[None]</code></pre> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# Iterative\ndef removeElements(head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    cur = dummy\n\n    while cur.next:\n        if cur.next.val == val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Iterative  |      O(N)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\n\nnums = [1, 2, 6, 3, 4, 5, 6]\nval = 6\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nprint(removeElements(head, val))\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"other/linked_list/#707-design-linked-list","title":"707. Design Linked List","text":"<ul> <li>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</li> </ul> <pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.dummy = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -&gt; int:\n        if index &lt; 0 or index &gt;= self.size:\n            return -1\n\n        current = self.dummy.next\n        for _ in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -&gt; None:\n        self.dummy.next = ListNode(val, self.dummy.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -&gt; None:\n        current = self.dummy\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n        if index &lt; 0 or index &gt; self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n        if index &lt; 0 or index &gt;= self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1\n\n\nll = MyLinkedList()\nll.addAtHead(1)\nll.addAtTail(3)\nll.addAtIndex(1, 2)\n# 1 -&gt; 2 -&gt; 3\nprint(ll.get(1))  # 2\n</code></pre>"},{"location":"other/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[3]\nC --&gt; D[4]\nD --&gt; E[5]</code></pre> <pre><code>graph RL\nE[5] --&gt; D[4]\nD --&gt; C[3]\nC --&gt; B[2]\nB --&gt; A[1]</code></pre> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# 1. Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# 2. Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"other/linked_list/#237-delete-node-in-a-linked-list","title":"237. Delete Node in a Linked List","text":"<ul> <li>Delete a node in a singly linked list. You are given only the node to be deleted.</li> </ul> <pre><code>from helper import ListNode\n\n\ndef deleteNode(node: ListNode) -&gt; None:\n    node.val = node.next.val\n    node.next = node.next.next\n\n\nhead = ListNode.create([4, 5, 1, 9])\nnode = head.next\ndeleteNode(node)\nprint(head)  # 4 -&gt; 1 -&gt; 9\n</code></pre>"},{"location":"other/linked_list/#2487-remove-nodes-from-linked-list","title":"2487. Remove Nodes From Linked List","text":"<ul> <li>Remove all nodes from a linked list that have a value greater than <code>maxValue</code>.</li> </ul> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# 1. Recursive\ndef removeNodesRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    head.next = removeNodesRecursive(head.next)\n\n    if head.next and head.val &lt; head.next.val:\n        return head.next\n\n    return head\n\n\n# 2. Iterative\ndef removeNodesIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    stack = []\n    cur = head\n\n    while cur:\n        # pop all nodes in stack that are smaller than cur\n        while stack and cur.val &gt; stack[-1].val:\n            stack.pop()\n\n        stack.append(cur)\n        cur = cur.next\n\n    # link all nodes in stack\n    dummy = ListNode()\n    cur = dummy\n\n    for node in stack:\n        cur.next = node\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = [5, 2, 13, 3, 8]\nhead1 = ListNode.create(head)\nprint(head1)\n# 5 -&gt; 2 -&gt; 13 -&gt; 3 -&gt; 8\nprint(removeNodesRecursive(head1))\n# 13 -&gt; 8\n\nhead2 = ListNode.create(head)\nprint(removeNodesIterative(head2))\n# 13 -&gt; 8\n</code></pre>"},{"location":"other/linked_list/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<ul> <li>Given a linked list, swap every two adjacent nodes and return its head.</li> </ul> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef swapPairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    cur = dummy\n\n    while cur.next and cur.next.next:\n        temp = cur.next\n        temp1 = cur.next.next.next\n\n        cur.next = cur.next.next\n        cur.next.next = temp\n        temp.next = temp1\n        cur = cur.next.next\n\n    return dummy.next\n\n\nnums = [1, 2, 3, 4, 5]\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(swapPairs(head))\n# 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"other/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))\n# 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"other/linked_list/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<ul> <li>Find the node at which the intersection of two singly linked lists begins.</li> </ul> <pre><code>graph LR\na1((a1)) --&gt; a2((a2))\na2 --&gt; c1((c1))\nb1((b1)) --&gt; b2((b2))\nb2 --&gt; b3((b3))\nb3 --&gt; c1\nc1 --&gt; c2((c2))\nc2 --&gt; c3((c3))</code></pre> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# Hash Set\ndef getIntersectionNodeHash(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    \"\"\"Return the intersection node of two linked lists.\"\"\"\n    if not headA or not headB:\n        return None\n\n    visited = set()\n    cur = headA\n    while cur:\n        visited.add(cur)\n        cur = cur.next\n\n    cur = headB\n    while cur:\n        if cur in visited:\n            return cur\n        cur = cur.next\n\n    return None\n\n\n# Two Pointers\ndef getIntersectionNodeTP(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    \"\"\"Return the intersection node of two linked lists.\"\"\"\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Hash Set  | O(n+m) |  O(n)   |\n# |Two Pointers| O(n+m) |  O(1)   |\n# |------------|--------|---------|\n\n\nlistA = [4, 1, 8, 4, 5]\nlistB = [5, 6, 1, 8, 4, 5]\nheadA = ListNode.create(listA)\nprint(headA)\n# 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\nheadB = ListNode.create(listB)\nprint(headB)\n# 5 -&gt; 6 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\n\nheadA.intersect(headB, 8)\n\nprint(getIntersectionNodeHash(headA, headB))\n# 8 -&gt; 4 -&gt; 5\nprint(getIntersectionNodeTP(headA, headB))\n# 8 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"other/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]</code></pre> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"other/linked_list/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<ul> <li>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>None</code>.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\nhead1 = ListNode.create([3, 2, 0, -4], 1)\nprint(detectCycle(head1).val)  # 2\nhead2 = ListNode.create([3, 2, 0, -4])\nprint(detectCycle(head2))  # None\n</code></pre>"},{"location":"other/linked_list/#2816-double-a-number-represented-as-a-linked-list","title":"2816. Double a Number Represented as a Linked List","text":"<ul> <li>Given a number represented as a linked list, double it and return the resulting linked list.</li> </ul> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef doubleIt(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n    def twice(node):\n        if not node:\n            return 0\n        doubled_value = node.val * 2 + twice(node.next)\n        node.val = doubled_value % 10\n        return doubled_value // 10\n\n    carry = twice(head)\n\n    if carry:\n        head = ListNode(val=carry, next=head)\n\n    return head\n\n\nhead = ListNode.create([1, 2, 3, 4])\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(doubleIt(head))\n# 2 -&gt; 4 -&gt; 6 -&gt; 8\n</code></pre>"},{"location":"other/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li>Represent the sum of two numbers as a linked list.</li> </ul> <pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val=val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\n\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre>"},{"location":"other/math/","title":"Math","text":""},{"location":"other/math/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>1945 - Sum of Digits of String After Convert (Easy)</li> <li>1894 - Find the Student that Will Replace the Chalk (Medium)</li> <li>0007 - Reverse Integer (Medium)</li> </ol>"},{"location":"other/math/#1945-sum-of-digits-of-string-after-convert","title":"1945. Sum of Digits of String After Convert","text":"<pre><code># Math\ndef getLucky(s: str, k: int) -&gt; int:\n    def getSum(n: int) -&gt; int:\n        total = 0\n        while n != 0:\n            n, m = divmod(n, 10)\n            total += m\n        return total\n\n    result = \"\"\n    for i in s:\n        result += str(ord(i) - ord(\"a\") + 1)\n    result = int(result)\n\n    for _ in range(k):\n        result = getSum(result)\n\n    return result\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"iiii\"\nk = 1\n\nprint(getLucky(s, k))  # 36\n</code></pre>"},{"location":"other/math/#1894-find-the-student-that-will-replace-the-chalk","title":"1894. Find the Student that Will Replace the Chalk","text":"<pre><code>from typing import List\n\n\n# Math\ndef chalkReplacer(chalk: List[int], k: int) -&gt; int:\n    total = sum(chalk)\n\n    k %= total\n\n    for i, c in enumerate(chalk):\n        k -= c\n\n        if k &lt; 0:\n            return i\n\n    return -1\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nchalk = [5, 1, 5]\nk = 22\n\nprint(chalkReplacer(chalk, k))  # 0\n</code></pre>"},{"location":"other/math/#7-reverse-integer","title":"7. Reverse Integer","text":"<pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre>"},{"location":"other/simulation/","title":"Simulation","text":""},{"location":"other/simulation/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0874 - Walking Robot Simulation (Medium)</li> </ol>"},{"location":"other/simulation/#874-walking-robot-simulation","title":"874. Walking Robot Simulation","text":"<pre><code>from typing import List\n\n\n# Simulation\ndef robotSim(commands: List[int], obstacles: List[List[int]]) -&gt; int:\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    obstacles_set = set(map(tuple, obstacles))\n\n    x, y, d = 0, 0, 0\n    res = 0\n\n    for command in commands:\n        if command == -2:  # Turn left\n            d = (d - 1) % 4\n        elif command == -1:  # Turn right\n            d = (d + 1) % 4\n        else:\n            dx, dy = dirs[d]\n            for _ in range(command):\n                if (x + dx, y + dy) not in obstacles_set:\n                    x += dx\n                    y += dy\n                    res = max(res, x**2 + y**2)\n                else:\n                    break\n\n    return res\n\n\ncommands = [4, -1, 4, -2, 4]\nobstacles = [[2, 4]]\nprint(robotSim(commands, obstacles))  # 65\n</code></pre>"},{"location":"plan/","title":"Study Plan","text":""},{"location":"plan/blind75/","title":"Blind 75","text":"<ul> <li>Blind 75</li> </ul>"},{"location":"plan/blind75/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0217 - Contains Duplicate (Easy)</li> <li>0242 - Valid Anagram (Easy)</li> <li>0001 - Two Sum (Easy)</li> <li>0049 - Group Anagrams (Medium)</li> <li>0347 - Top K Frequent Elements (Medium)</li> <li>0271 - Encode and Decode Strings (Medium)</li> <li>0238 - Product of Array Except Self (Medium)</li> <li>0128 - Longest Consecutive Sequence (Hard)</li> <li>0125 - Valid Palindrome (Easy)</li> <li>0015 - 3Sum (Medium)</li> <li>0011 - Container With Most Water (Medium)</li> <li>0121 - Best Time to Buy and Sell Stock (Easy)</li> <li>0003 - Longest Substring Without Repeating Characters (Medium)</li> <li>0424 - Longest Repeating Character Replacement (Medium)</li> <li>0076 - Minimum Window Substring (Hard)</li> <li>0020 - Valid Parentheses (Easy)</li> <li>0153 - Find Minimum In Rotated Sorted Array (Medium)</li> <li>0033 - Search In Rotated Sorted Array (Medium)</li> <li>0206 - Reverse Linked List (Easy)</li> <li>0021 - Merge Two Sorted Lists (Easy)</li> <li>0143 - Reorder List (Medium)</li> <li>0019 - Remove Nth Node From End of List (Medium)</li> <li>0141 - Linked List Cycle (Easy)</li> <li>0023 - Merge K Sorted Lists (Hard)</li> <li>0226 - Invert Binary Tree (Easy)</li> <li>0104 - Maximum Depth of Binary Tree (Easy)</li> <li>0100 - Same Tree (Easy)</li> <li>0572 - Subtree of Another Tree (Easy)</li> <li>0235 - Lowest Common Ancestor of a Binary Search Tree (Easy)</li> <li>0102 - Binary Tree Level Order Traversal (Medium)</li> <li>0098 - Validate Binary Search Tree (Medium)</li> <li>0230 - Kth Smallest Element In a Bst (Medium)</li> <li>0105 - Construct Binary Tree From Preorder And Inorder Traversal (Medium)</li> <li>0124 - Binary Tree Maximum Path Sum (Hard)</li> <li>0298 - Serialize And Deserialize Binary Tree (Hard)</li> <li>0295 - Find Median From Data Stream (Hard)</li> <li>0039 - Combination Sum (Medium)</li> <li>0079 - Word Search (Medium)</li> <li>0208 - Implement Trie Prefix Tree (Medium)</li> <li>0212 - Design Add And Search Words Data Structure (Hard)</li> <li>0211 - Word Search II (Hard)</li> <li>0200 - Number of Islands (Medium)</li> <li>0133 - Clone Graph (Medium)</li> <li>0417 - Pacific Atlantic Water Flow (Medium)</li> <li>0207 - Course Schedule (Medium)</li> <li>0261 - Graph Valid Tree (Medium)</li> <li>0323 - Number of Connected Components In An Undirected Graph (Medium)</li> <li>0269 - Alien Dictionary (Hard)</li> <li>0070 - Climbing Stairs (Easy)</li> <li>0198 - House Robber (Easy)</li> <li>0213 - House Robber II (Medium)</li> <li>0005 - Longest Palindromic Substring (Medium)</li> <li>0647 - Palindromic Substrings (Medium)</li> <li>0091 - Decode Ways (Medium)</li> <li>0322 - Coin Change (Medium)</li> <li>0152 - Maximum Product Subarray (Medium)</li> <li>0139 - Word Break (Medium)</li> <li>0300 - Longest Increasing Subsequence (Medium)</li> <li>0062 - Unique Paths (Medium)</li> <li>1143 - Longest Common Subsequence (Medium)</li> <li>0053 - Maximum Subarray (Easy)</li> <li>0055 - Jump Game (Medium)</li> <li>0057 - Insert Interval (Hard)</li> <li>0056 - Merge Intervals (Medium)</li> <li>0252 - Non Overlapping Intervals (Medium)</li> <li>0253 - Meeting Rooms (Easy)</li> <li>0254 - Meeting Rooms II (Medium)</li> <li>0048 - Rotate Image (Medium)</li> <li>0054 - Spiral Matrix (Medium)</li> <li>0073 - Set Matrix Zeroes (Medium)</li> <li>0191 - Number of 1 Bits (Easy)</li> <li>0338 - Counting Bits (Medium)</li> <li>0190 - Reverse Bits (Easy)</li> <li>0268 - Missing Number (Easy)</li> <li>0371 - Sum of Two Integers (Medium)</li> </ol>"},{"location":"plan/blind75/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"plan/blind75/#242-valid-anagram","title":"242. Valid Anagram","text":"<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"plan/blind75/#1-two-sum","title":"1. Two Sum","text":"<pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = dict()  # {val: idx}\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n        hashmap[val] = idx\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Hashmap    |      O(n)       |    O(n)      |\n# |-------------|-----------------|--------------|\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nprint(twoSum(nums, target))  # [1, 2]\n</code></pre>"},{"location":"plan/blind75/#49-group-anagrams","title":"49. Group Anagrams","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"plan/blind75/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# 1. Heap + Counter\ndef topKFrequent1(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, count in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (count, val))\n        else:\n            heapq.heappushpop(minHeap, (count, val))\n\n    return [i for (_, i) in minHeap]\n\n\n# 2. Heap + Dict\ndef topKFrequent2(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    counts = dict()\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for val, count in counts.items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (count, val))\n        else:\n            heapq.heappushpop(minHeap, (count, val))\n\n    return [i for (_, i) in minHeap]\n\n\n# 3. Counter - Most Common\ndef topKFrequent3(nums: List[int], k: int) -&gt; List[int]:\n    common = Counter(nums).most_common(k)\n    return [i for i, _ in common]\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Heap      |    O(n)     |    O(n)      |\n# |   Counter   |    O(n)     |    O(n)      |\n# |-------------|-------------|--------------|\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent1(nums, k))  # [2, 1]\nprint(topKFrequent2(nums, k))  # [2, 1]\nprint(topKFrequent3(nums, k))  # [1, 2]\n</code></pre>"},{"location":"plan/blind75/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"plan/blind75/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<pre><code>from typing import List\n\n\n# 1. Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# 2. Prefix - Optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |    Prefix   |    O(n)     |    O(n)      |\n# |Prefix - Opt |    O(n)     |    O(1)      |\n# |-------------|-------------|--------------|\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"plan/blind75/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"plan/blind75/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"plan/blind75/#15-3sum","title":"15. 3Sum","text":"<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# |-----------|---------|---------|\n# | Approach  |   Time  |  Space  |\n# |-----------|---------|---------|\n# | LR Pointer|  O(n^2) |   O(1)  |\n# |-----------|---------|---------|\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))  # [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"plan/blind75/#11-container-with-most-water","title":"11. Container With Most Water","text":"<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"plan/blind75/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"plan/blind75/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(len(s)):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"plan/blind75/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"plan/blind75/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"plan/blind75/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"plan/blind75/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum In Rotated Sorted Array","text":""},{"location":"plan/blind75/#33-search-in-rotated-sorted-array","title":"33. Search In Rotated Sorted Array","text":""},{"location":"plan/blind75/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# 1. Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# 2. Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"plan/blind75/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre>"},{"location":"plan/blind75/#143-reorder-list","title":"143. Reorder List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\nhead = ListNode.create([1, 2, 3, 4, 5, 6])\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nreorderList(head)\nprint(head)  # 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n</code></pre>"},{"location":"plan/blind75/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))\n# 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"plan/blind75/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"plan/blind75/#23-merge-k-sorted-lists","title":"23. Merge K Sorted Lists","text":"<pre><code>import heapq\nfrom typing import List, Optional\n\nfrom helper import ListNode\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    heap = []\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(heap, (head.val, idx, head))\n\n    while heap:\n        _, idx, node = heapq.heappop(heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(heap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nprint(mergeKLists(lists))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"plan/blind75/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"plan/blind75/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return depth\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    return 1 + max(maxDepthRecursive(root.left), maxDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthRecursive(root))  # 4\n</code></pre>"},{"location":"plan/blind75/#100-same-tree","title":"100. Same Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"plan/blind75/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre>"},{"location":"plan/blind75/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"plan/blind75/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"plan/blind75/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"plan/blind75/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element In a Bst","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"plan/blind75/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree From Preorder And Inorder Traversal","text":"<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"plan/blind75/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"plan/blind75/#298-serialize-and-deserialize-binary-tree","title":"298. Serialize And Deserialize Binary Tree","text":""},{"location":"plan/blind75/#295-find-median-from-data-stream","title":"295. Find Median From Data Stream","text":"<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"plan/blind75/#39-combination-sum","title":"39. Combination Sum","text":"<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"plan/blind75/#79-word-search","title":"79. Word Search","text":"<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"plan/blind75/#208-implement-trie-prefix-tree","title":"208. Implement Trie Prefix Tree","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"plan/blind75/#212-design-add-and-search-words-data-structure","title":"212. Design Add And Search Words Data Structure","text":""},{"location":"plan/blind75/#211-word-search-ii","title":"211. Word Search II","text":""},{"location":"plan/blind75/#200-number-of-islands","title":"200. Number of Islands","text":"<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == \"0\":\n            return None\n\n        grid[r][c] = \"0\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                ):\n                    continue\n                q.append((nr, nc))\n                grid[nr][nc] = \"0\"\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                grid[r][c] = \"0\"\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"plan/blind75/#133-clone-graph","title":"133. Clone Graph","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre>"},{"location":"plan/blind75/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"plan/blind75/#207-course-schedule","title":"207. Course Schedule","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visited = set()\n\n    def dfs(crs):\n        if crs in visited:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visited.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    visited = [0] * numCourses\n\n    def dfs(crs):\n        if visited[crs] == 1:  # cycle detected\n            return False\n        if visited[crs] == 2:\n            return True\n\n        visited[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"plan/blind75/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"plan/blind75/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components In An Undirected Graph","text":"<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    parent = [i for i in range(n)]\n    rank = [1 for _ in range(n)]\n\n    def find(node):\n        root = node\n\n        while root != parent[root]:\n            parent[root] = parent[parent[root]]\n            root = parent[root]\n        return root\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if rank[p2] &gt; rank[p1]:\n            parent[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            parent[p2] = p1\n            rank[p1] += rank[p2]\n        return 1\n\n    count = n\n    for n1, n2 in edges:\n        count -= union(n1, n2)\n\n    return count\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))\n</code></pre>"},{"location":"plan/blind75/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"plan/blind75/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"plan/blind75/#198-house-robber","title":"198. House Robber","text":"<pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 12\n</code></pre>"},{"location":"plan/blind75/#213-house-robber-ii","title":"213. House Robber II","text":"<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre>"},{"location":"plan/blind75/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n    print(dp)\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"plan/blind75/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"plan/blind75/#91-decode-ways","title":"91. Decode Ways","text":"<pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre>"},{"location":"plan/blind75/#322-coin-change","title":"322. Coin Change","text":"<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"plan/blind75/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"plan/blind75/#139-word-break","title":"139. Word Break","text":"<pre><code>from typing import List\n\n\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    wordSet = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[len(s)]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"plan/blind75/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<pre><code>from typing import List\n\n\n# DP - LIS\ndef lengthOfLIS(nums: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(n)\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # 4\n</code></pre>"},{"location":"plan/blind75/#62-unique-paths","title":"62. Unique Paths","text":"<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"plan/blind75/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n            if res &lt; dp[i][j]:\n                res = dp[i][j]\n\n    return res\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"plan/blind75/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"plan/blind75/#55-jump-game","title":"55. Jump Game","text":"<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    reach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= reach:\n        reach = max(reach, i + nums[i])\n        if reach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"plan/blind75/#57-insert-interval","title":"57. Insert Interval","text":"<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"plan/blind75/#56-merge-intervals","title":"56. Merge Intervals","text":"<pre><code>from typing import List\n\n\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt;= result[-1][1]:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"plan/blind75/#252-non-overlapping-intervals","title":"252. Non Overlapping Intervals","text":""},{"location":"plan/blind75/#253-meeting-rooms","title":"253. Meeting Rooms","text":""},{"location":"plan/blind75/#254-meeting-rooms-ii","title":"254. Meeting Rooms II","text":""},{"location":"plan/blind75/#48-rotate-image","title":"48. Rotate Image","text":"<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"plan/blind75/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"plan/blind75/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre>"},{"location":"plan/blind75/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    count = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        count += 1\n\n    return count\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n</code></pre>"},{"location":"plan/blind75/#338-counting-bits","title":"338. Counting Bits","text":"<pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"plan/blind75/#190-reverse-bits","title":"190. Reverse Bits","text":"<pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"plan/blind75/#268-missing-number","title":"268. Missing Number","text":"<pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre>"},{"location":"plan/blind75/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"plan_graph_study/","title":"Study Plan - Graph Theory","text":"<ul> <li> <p>\u56fe\u8bba\u30fb\u4ece\u5165\u95e8\u5230\u7cbe\u901a</p> </li> <li> <p>Standard Traversal</p> <ol> <li>0547 - Number of Provinces (Medium)</li> <li>0802 - Find Eventual Safe States (Medium)</li> <li>0841 - Keys and Rooms (Medium)</li> <li>1129 - Shortest Path with Alternating Colors (Medium)</li> <li>1376 - Time Needed to Inform All Employees (Medium)</li> <li>1466 - Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li>0797 - All Paths From Source to Target (Medium)</li> <li>1192 - Critical Connections in a Network (Hard)</li> </ol> </li> <li>BFS<ol> <li>1926 - Nearest Exit from Entrance in Maze (Medium)</li> <li>0934 - Shortest Bridge (Medium)</li> <li>0433 - Minimum Genetic Mutation (Medium)</li> <li>0127 - Word Ladder (Hard)</li> <li>1306 - Jump Game III (Medium)</li> <li>0542 - 01 Matrix (Medium)</li> <li>1091 - Shortest Path in Binary Matrix (Medium)</li> <li>0863 - All Nodes Distance K in Binary Tree (Medium)</li> <li>0864 - Shortest Path to Get All Keys (Hard)</li> </ol> </li> <li>Matrix Graphs<ol> <li>0200 - Number of Islands (Medium)</li> <li>1020 - Number of Enclaves (Medium)</li> <li>1254 - Number of Closed Islands (Medium)</li> <li>0695 - Max Area of Island (Medium)</li> <li>0417 - Pacific Atlantic Water Flow (Medium)</li> </ol> </li> <li>Graph Theory<ol> <li>0997 - Find the Town Judge (Easy)</li> <li>1557 - Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li>1615 - Maximal Network Rank (Medium)</li> <li>0785 - Is Graph Bipartite? (Medium)</li> <li>0261 - Graph Valid Tree (Medium)</li> </ol> </li> <li>Union Find / DSU<ol> <li>0721 - Accounts Merge (Medium)</li> <li>0990 - Satisfiability of Equality Equations (Medium)</li> <li>1061 - Lexicographically Smallest Equivalent String (Medium)</li> <li>0839 - Similar String Groups (Hard)</li> </ol> </li> <li>Topological Sort<ol> <li>0207 - Course Schedule (Medium)</li> <li>0210 - Course Schedule II (Medium)</li> <li>0269 - Alien Dictionary (Hard)</li> <li>1203 - Sort Items by Groups Respecting Dependencies (Hard)</li> <li>1857 - Largest Color Value in a Directed Graph (Hard)</li> </ol> </li> <li>Dijkstra's<ol> <li>0787 - Cheapest Flights Within K Stops (Medium)</li> <li>1514 - Path with Maximum Probability (Medium)</li> <li>0505 - The Maze II (Medium)</li> <li>0499 - The Maze III (Hard)</li> </ol> </li> <li>MST<ol> <li>1135 - Connecting Cities With Minimum Cost (Medium)</li> <li>1584 - Min Cost to Connect All Points (Medium)</li> <li>1168 - Optimize Water Distribution in a Village (Hard)</li> <li>1489 - Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> </ol> </li> </ul>"},{"location":"plan_graph_study/bfs/","title":"BFS","text":""},{"location":"plan_graph_study/bfs/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>1926 - Nearest Exit from Entrance in Maze (Medium)</li> <li>0934 - Shortest Bridge (Medium)</li> <li>0433 - Minimum Genetic Mutation (Medium)</li> <li>0127 - Word Ladder (Medium)</li> <li>1306 - Jump Game III (Medium)</li> <li>0542 - 01 Matrix (Medium)</li> <li>1091 - Shortest Path in Binary Matrix (Medium)</li> <li>0863 - All Nodes Distance K in Binary Tree (Medium)</li> <li>0864 - Shortest Path to Get All Keys (Hard)</li> </ol>"},{"location":"plan_graph_study/bfs/#1926-nearest-exit-from-entrance-in-maze","title":"1926. Nearest Exit from Entrance in Maze","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef nearestExit(maze: List[List[str]], entrance: List[int]) -&gt; int:\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque([(entrance[0], entrance[1], 0)])\n    maze[entrance[0]][entrance[1]] = \"+\"\n\n    while q:\n        r, c, steps = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and maze[nr][nc] == \".\":\n                if nr in [0, m - 1] or nc in [0, n - 1]:\n                    return steps + 1\n                q.append((nr, nc, steps + 1))\n                maze[nr][nc] = \"+\"\n\n    return -1\n\n\nmaze = [[\"+\", \"+\", \".\", \"+\"], [\".\", \".\", \".\", \"+\"], [\"+\", \"+\", \"+\", \".\"]]\nentrance = [1, 2]\nprint(nearestExit(maze, entrance))  # 1\n</code></pre>"},{"location":"plan_graph_study/bfs/#934-shortest-bridge","title":"934. Shortest Bridge","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS + DFS; Coloring\ndef shortestBridge(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c, queue):\n        grid[r][c] = 2\n        queue.append((r, c))\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr in range(n) and nc in range(n) and grid[nr][nc] == 1:\n                dfs(nr, nc, queue)\n\n    q = deque()\n    found = False\n    for r in range(n):\n        if found:\n            break\n        for c in range(n):\n            if grid[r][c] == 1:\n                dfs(r, c, q)\n                found = True\n                break\n\n    steps = 0\n    while q:\n        m = len(q)\n        for _ in range(m):\n            r, c = q.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if nr in range(n) and nc in range(n):\n                    if grid[nr][nc] == 1:\n                        return steps\n                    elif grid[nr][nc] == 0:\n                        grid[nr][nc] = 2\n                        q.append((nr, nc))\n        steps += 1\n\n    return -1\n\n\ngrid = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1],\n]\nprint(shortestBridge(grid))  # 1\n</code></pre>"},{"location":"plan_graph_study/bfs/#433-minimum-genetic-mutation","title":"433. Minimum Genetic Mutation","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef minMutation(startGene: str, endGene: str, bank: List[str]) -&gt; int:\n    if endGene not in bank:\n        return -1\n\n    bank = set(bank)\n    q = deque([(startGene, 0)])\n\n    while q:\n        gene, step = q.popleft()\n        if gene == endGene:\n            return step\n\n        for i in range(8):\n            for c in \"ACGT\":\n                if gene[i] == c:\n                    continue\n                newGene = gene[:i] + c + gene[i + 1 :]\n                if newGene in bank:\n                    bank.remove(newGene)\n                    q.append((newGene, step + 1))\n    return -1\n\n\nstartGene = \"AACCGGTT\"\nendGene = \"AAACGGTA\"\nbank = [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\nprint(minMutation(startGene, endGene, bank))  # 2\n</code></pre>"},{"location":"plan_graph_study/bfs/#127-word-ladder","title":"127. Word Ladder","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # Edge case\n    if endWord not in wordList:\n        return 0\n\n    # Init\n    graph = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    # BFS\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\n# |------------|---------|---------|\n# |  Approach  |  Time   |  Space  |\n# |------------|---------|---------|\n# |    BFS     | O(n*m^2)| O(n*m)  |\n# |------------|---------|---------|\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"plan_graph_study/bfs/#1306-jump-game-iii","title":"1306. Jump Game III","text":"<ul> <li>Return <code>True</code> if you can reach the end of the array starting at index <code>start</code> and <code>False</code> otherwise.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef canReach(arr: List[int], start: int) -&gt; bool:\n    n = len(arr)\n    visited = [False for _ in range(n)]\n    q = deque([start])\n\n    while q:\n        i = q.popleft()\n\n        if arr[i] == 0:\n            return True\n\n        visited[i] = True\n\n        for j in [i - arr[i], i + arr[i]]:\n            if j in range(n) and not visited[j]:\n                q.append(j)\n\n    return False\n\n\narr = [4, 2, 3, 0, 3, 1, 2]\nstart = 5\nprint(canReach(arr, start))  # True\n</code></pre>"},{"location":"plan_graph_study/bfs/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li>Return the distance of the nearest 0 for each cell in the matrix.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre>"},{"location":"plan_graph_study/bfs/#1091-shortest-path-in-binary-matrix","title":"1091. Shortest Path in Binary Matrix","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    if n == 1:\n        return 1\n\n    directions = [\n        (0, 1),\n        (1, 0),\n        (0, -1),\n        (-1, 0),\n        (1, 1),\n        (-1, -1),\n        (1, -1),\n        (-1, 1),\n    ]\n    q = deque([(0, 0, 1)])  # (row, column, distance)\n    grid[0][0] = 1\n\n    while q:\n        r, c, d = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                if nr == nc == n - 1:\n                    return d + 1\n                q.append((nr, nc, d + 1))\n                grid[nr][nc] = 1\n\n    return -1\n\n\ngrid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]]\nprint(shortestPathBinaryMatrix(grid))  # 4\n</code></pre>"},{"location":"plan_graph_study/bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre>"},{"location":"plan_graph_study/bfs/#864-shortest-path-to-get-all-keys","title":"864. Shortest Path to Get All Keys","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathAllKeys(grid: List[str]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    q = deque()\n    visited = set()\n    total = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"@\":\n                q.append((r, c, 0, 0))\n                visited.add((r, c, 0))\n            if grid[r][c].islower():\n                total += 1\n\n    while q:\n        r, c, keys, steps = q.popleft()\n\n        if keys == (1 &lt;&lt; total) - 1:\n            return steps\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                cell = grid[nr][nc]\n\n                if cell == \"#\":\n                    continue\n\n                new_keys = keys\n                if cell.islower():\n                    new_keys |= 1 &lt;&lt; (ord(cell) - ord(\"a\"))\n\n                if cell.isupper() and not (\n                    keys &amp; (1 &lt;&lt; (ord(cell) - ord(\"A\")))\n                ):\n                    continue\n\n                if (nr, nc, new_keys) not in visited:\n                    visited.add((nr, nc, new_keys))\n                    q.append((nr, nc, new_keys, steps + 1))\n\n    return -1\n\n\ngrid = [\"@.a..\", \"###.#\", \"b.A.B\"]\nprint(shortestPathAllKeys(grid))  # 8\n</code></pre>"},{"location":"plan_graph_study/dijkstra/","title":"Dijkstra's Algorithm","text":""},{"location":"plan_graph_study/dijkstra/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0787 - Cheapest Flights Within K Stops (Medium)</li> <li>1514 - Path with Maximum Probability (Medium)</li> <li>0505 - The Maze II (Medium)</li> <li>0499 - The Maze III (Hard)</li> </ol>"},{"location":"plan_graph_study/dijkstra/#0787-cheapest-flights-within-k-stops","title":"0787. Cheapest Flights Within K Stops","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\")] * n\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n\n        for s, d, p in flights:\n            if prices[s] == float(\"inf\"):\n                continue\n            if prices[s] + p &lt; temp_prices[d]:\n                temp_prices[d] = prices[s] + p\n\n        prices = temp_prices\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"plan_graph_study/dijkstra/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"plan_graph_study/dijkstra/#0505-the-maze-ii","title":"0505. The Maze II","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"plan_graph_study/dijkstra/#0499-the-maze-iii","title":"0499. The Maze III","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"plan_graph_study/graph_theory/","title":"Graph Theory","text":""},{"location":"plan_graph_study/graph_theory/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0997 - Find the Town Judge (Easy)</li> <li>1557 - Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li>1615 - Maximal Network Rank (Medium)</li> <li>0785 - Is Graph Bipartite? (Medium)</li> <li>0261 - Graph Valid Tree (Medium)</li> </ol>"},{"location":"plan_graph_study/graph_theory/#0997-find-the-town-judge","title":"0997. Find the Town Judge","text":"<ul> <li>Return the label of the town judge if the town has a judge.</li> </ul> <pre><code>from typing import List\n\n\n# Graph\ndef findJudge(n: int, trust: List[List[int]]) -&gt; int:\n    indegree = {i: 0 for i in range(1, n + 1)}\n    outdegree = {i: 0 for i in range(1, n + 1)}\n\n    for a, b in trust:\n        outdegree[a] += 1\n        indegree[b] += 1\n\n    for i in range(1, n + 1):\n        if indegree[i] == n - 1 and outdegree[i] == 0:\n            return i\n\n    return -1\n\n\nn = 3\ntrust = [[1, 3], [2, 3]]\nprint(findJudge(n, trust))  # 3\n</code></pre>"},{"location":"plan_graph_study/graph_theory/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for a, b in edges:\n        indegree[b] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(findSmallestSetOfVertices(n, edges))  # [0, 3]\n</code></pre>"},{"location":"plan_graph_study/graph_theory/#1615-maximal-network-rank","title":"1615. Maximal Network Rank","text":"<ul> <li>Return the maximal network rank.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef maximalNetworkRank(n: int, roads: List[List[int]]) -&gt; int:\n    degree = defaultdict(int)\n    roads_set = set(map(tuple, roads))\n\n    for a, b in roads_set:\n        degree[a] += 1\n        degree[b] += 1\n\n    rank = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (i, j) in roads_set or (j, i) in roads_set:\n                rank = max(rank, degree[i] + degree[j] - 1)\n            else:\n                rank = max(rank, degree[i] + degree[j])\n\n    return rank\n\n\nn = 4\nroads = [[0, 1], [0, 3], [1, 2], [1, 3]]\nprint(maximalNetworkRank(n, roads))  # 4\n</code></pre>"},{"location":"plan_graph_study/graph_theory/#0785-is-graph-bipartite","title":"0785. Is Graph Bipartite?","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"plan_graph_study/graph_theory/#0261-graph-valid-tree","title":"0261. Graph Valid Tree","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"plan_graph_study/matrix_graphs/","title":"Matrix Graphs","text":""},{"location":"plan_graph_study/matrix_graphs/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0200 - Number of Islands (Medium)</li> <li>1020 - Number of Enclaves (Medium)</li> <li>1254 - Number of Closed Islands (Medium)</li> <li>0695 - Max Area of Island (Medium)</li> <li>0417 - Pacific Atlantic Water Flow (Medium)</li> </ol>"},{"location":"plan_graph_study/matrix_graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == \"0\":\n            return None\n\n        grid[r][c] = \"0\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                ):\n                    continue\n                q.append((nr, nc))\n                grid[nr][nc] = \"0\"\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                grid[r][c] = \"0\"\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"plan_graph_study/matrix_graphs/#1020-number-of-enclaves","title":"1020. Number of Enclaves","text":"<pre><code>from typing import List\n\n\n# DFS\ndef numEnclaves(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 0\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 1\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    count = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                count += 1\n\n    return count\n\n\ngrid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nprint(numEnclaves(grid))  # 3\n</code></pre>"},{"location":"plan_graph_study/matrix_graphs/#1254-number-of-closed-islands","title":"1254. Number of Closed Islands","text":"<pre><code>from typing import List\n\n\n# DFS\ndef closedIsland(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 1\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 1\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 0\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    island = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 0 and (r, c) not in visited:\n                island += 1\n                dfs(r, c)\n\n    return island\n\n\ngrid = [\n    [1, 1, 1, 1, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 1, 0, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0],\n]\nprint(closedIsland(grid))  # 2\n</code></pre>"},{"location":"plan_graph_study/matrix_graphs/#0695-max-area-of-island","title":"0695. Max Area of Island","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    visited = set()\n    area = 0\n\n    def dfs(r, c):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return 0\n\n        visited.add((r, c))\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1)\n        )\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"plan_graph_study/matrix_graphs/#0417-pacific-atlantic-water-flow","title":"0417. Pacific Atlantic Water Flow","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"plan_graph_study/mst/","title":"MST","text":""},{"location":"plan_graph_study/mst/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>1135 - Connecting Cities With Minimum Cost (Medium)</li> <li>1584 - Min Cost to Connect All Points (Medium)</li> <li>1168 - Optimize Water Distribution in a Village (Hard)</li> <li>1489 - Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> </ol>"},{"location":"plan_graph_study/mst/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"plan_graph_study/mst/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"plan_graph_study/mst/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"plan_graph_study/mst/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"plan_graph_study/standard_traversal/","title":"Standard Traversal","text":""},{"location":"plan_graph_study/standard_traversal/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0547 - Number of Provinces (Medium)</li> <li>0802 - Find Eventual Safe States (Medium)</li> <li>0841 - Keys and Rooms (Medium)</li> <li>1129 - Shortest Path with Alternating Colors (Medium)</li> <li>1376 - Time Needed to Inform All Employees (Medium)</li> <li>1466 - Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li>0797 - All Paths From Source to Target (Medium)</li> <li>1192 - Critical Connections in a Network (Hard)</li> </ol>"},{"location":"plan_graph_study/standard_traversal/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li>Return the number of provinces.</li> </ul> <pre><code>from typing import List\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    parent = list(range(n))\n    rank = [1 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    provinces = len(set(find(i) for i in range(n)))\n\n    return provinces\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNum(isConnected))  # 2\n</code></pre>"},{"location":"plan_graph_study/standard_traversal/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li>Return an array containing all the safe nodes.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre>"},{"location":"plan_graph_study/standard_traversal/#841-keys-and-rooms","title":"841. Keys and Rooms","text":"<ul> <li>Return <code>True</code> if you can enter every room.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef canVisitAllRoomsDFS(rooms: List[List[int]]) -&gt; bool:\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n\n    def dfs(room):\n        visited[room] = True\n        for key in rooms[room]:\n            if not visited[key]:\n                dfs(key)\n\n    dfs(0)\n\n    return all(visited)\n\n\n# BFS\ndef canVisitAllRoomsBFS(rooms):\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n    q = deque([0])\n    visited[0] = True\n\n    while q:\n        room = q.popleft()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                q.append(key)\n\n    return all(visited)\n\n\nrooms = [[1, 3], [3, 0, 1], [2], [0]]\nprint(canVisitAllRoomsDFS(rooms))  # False\nprint(canVisitAllRoomsBFS(rooms))  # False\n</code></pre>"},{"location":"plan_graph_study/standard_traversal/#1129-shortest-path-with-alternating-colors","title":"1129. Shortest Path with Alternating Colors","text":"<ul> <li>Return the shortest path from <code>start</code> to <code>end</code> with alternating colors.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef shortestAlternatingPaths(\n    n: int, redEdges: List[List[int]], blueEdges: List[List[int]]\n) -&gt; List[int]:\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n\n    for u, v in redEdges:\n        red_graph[u].append(v)\n    for u, v in blueEdges:\n        blue_graph[u].append(v)\n\n    answer = [-1 for _ in range(n)]\n    q = deque([(0, 0, 0), (0, 0, 1)])  # (node, distance, color)\n    visited = set()\n\n    while q:\n        node, dist, color = q.popleft()\n        if (node, color) in visited:\n            continue\n        visited.add((node, color))\n        if answer[node] == -1:\n            answer[node] = dist\n        if color == 0:\n            for neighbor in blue_graph[node]:\n                q.append((neighbor, dist + 1, 1))\n        else:\n            for neighbor in red_graph[node]:\n                q.append((neighbor, dist + 1, 0))\n\n    return answer\n\n\nn = 3\nred_edges = [[0, 1], [1, 2]]\nblue_edges = []\nprint(shortestAlternatingPaths(n, red_edges, blue_edges))  # [0, 1, -1]\n</code></pre>"},{"location":"plan_graph_study/standard_traversal/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li>Return the time needed to inform all employees.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre>"},{"location":"plan_graph_study/standard_traversal/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li>Return the minimum number of connections needed to make all paths lead to the city zero.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"plan_graph_study/standard_traversal/#797-all-paths-from-source-to-target","title":"797. All Paths From Source to Target","text":"<ul> <li>Return all possible paths from <code>source</code> to <code>target</code>.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS - Backtracking\ndef allPathsSourceTargetDFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    result = []\n    n = len(graph)\n\n    def dfs(node, path):\n        if node == n - 1:\n            result.append(path.copy())\n            return None\n\n        for nei in graph[node]:\n            path.append(nei)\n            dfs(nei, path)\n            path.pop()\n\n    dfs(0, [0])\n\n    return result\n\n\n# BFS\ndef allPathsSourceTargetBFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    n = len(graph)\n    result = []\n    q = deque([(0, [0])])\n\n    while q:\n        node, path = q.popleft()\n\n        if node == n - 1:\n            result.append(path)\n\n        for nei in graph[node]:\n            q.append((nei, path + [nei]))\n\n    return result\n\n\ngraph = [[1, 2], [3], [3], []]\nprint(allPathsSourceTargetDFS(graph))  # [[0, 1, 3], [0, 2, 3]]\nprint(allPathsSourceTargetBFS(graph))  # [[0, 1, 3], [0, 2, 3]]\n</code></pre>"},{"location":"plan_graph_study/standard_traversal/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li>Return all critical connections in the network.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"plan_graph_study/topological_sort/","title":"Union Find / DSU","text":""},{"location":"plan_graph_study/topological_sort/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0207 - Course Schedule (Medium)</li> <li>0210 - Course Schedule II (Medium)</li> <li>0269 - Alien Dictionary (Hard)</li> <li>1203 - Sort Items by Groups Respecting Dependencies (Hard)</li> <li>1857 - Largest Color Value in a Directed Graph (Hard)</li> </ol>"},{"location":"plan_graph_study/topological_sort/#0207-course-schedule","title":"0207. Course Schedule","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visited = set()\n\n    def dfs(crs):\n        if crs in visited:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visited.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    visited = [0] * numCourses\n\n    def dfs(crs):\n        if visited[crs] == 1:  # cycle detected\n            return False\n        if visited[crs] == 2:\n            return True\n\n        visited[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visited[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"plan_graph_study/topological_sort/#0210-course-schedule-ii","title":"0210. Course Schedule II","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"plan_graph_study/topological_sort/#0269-alien-dictionary","title":"0269. Alien Dictionary","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"plan_graph_study/topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"plan_graph_study/topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"plan_graph_study/union_find_dsu/","title":"Union Find / DSU","text":""},{"location":"plan_graph_study/union_find_dsu/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0721 - Accounts Merge (Medium)</li> <li>0990 - Satisfiability of Equality Equations (Medium)</li> <li>1061 - Lexicographically Smallest Equivalent String (Medium)</li> <li>0839 - Similar String Groups (Hard)</li> </ol>"},{"location":"plan_graph_study/union_find_dsu/#721-accounts-merge","title":"721. Accounts Merge","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"plan_graph_study/union_find_dsu/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"plan_graph_study/union_find_dsu/#1061-lexicographically-smallest-equivalent-string","title":"1061. Lexicographically Smallest Equivalent String","text":"<pre><code># Union Find\ndef smallestEquivalentString(s1: str, s2: str, baseStr: str) -&gt; str:\n    parent = {chr(i): chr(i) for i in range(ord(\"a\"), ord(\"z\") + 1)}\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if p1 &lt; p2:\n                parent[p2] = p1\n            else:\n                parent[p1] = p2\n\n    for i in range(len(s1)):\n        union(s1[i], s2[i])\n\n    result = []\n    for c in baseStr:\n        result.append(find(c))\n\n    return \"\".join(result)\n\n\ns1 = \"parker\"\ns2 = \"morris\"\nbaseStr = \"parser\"\nprint(smallestEquivalentString(s1, s2, baseStr))  # \"makkek\"\n</code></pre>"},{"location":"plan_graph_study/union_find_dsu/#839-similar-string-groups","title":"839. Similar String Groups","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"python/","title":"Python","text":""},{"location":"python/python_collections/","title":"<code>collections</code> Module","text":""},{"location":"python/python_collections/#counter","title":"Counter","text":"<pre><code>from collections import Counter\n\n# 1. Basic\ndata = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"]\ncounter = Counter(data)\nprint(counter)\n# Counter({'apple': 3, 'banana': 2, 'orange': 1})\n\n\n# 2. Create\nc1 = Counter()  # Empty\nprint(c1)  # Counter()\nc2 = Counter(\"aabbc\")  # String\nprint(c2)  # Counter({'a': 2, 'b': 2, 'c': 1})\nc3 = Counter({\"a\": 2, \"b\": 1})  # Dictionary\nprint(c3)  # Counter({'a': 2, 'b': 1})\nc4 = Counter(a=2, b=1)  # Keyword arguments\nprint(c4)  # Counter({'a': 2, 'b': 1})\n\n\n# 3. Update\ncounter = Counter([\"a\", \"b\", \"c\"])\nprint(counter)\n# Counter({'a': 1, 'b': 1, 'c': 1})\ncounter.update([\"a\", \"b\", \"c\", \"a\"])  # &lt;--\nprint(counter)\n# Counter({'a': 3, 'b': 2, 'c': 2})\n\n\n# 4.Subtract\ncounter.subtract([\"a\"])\nprint(counter)\n# Counter({'a': 2, 'b': 2, 'c': 2})\n\n\n# 5. Access\nprint(counter[\"a\"])  # 2\n\n\n# 6. Delete\ndel counter[\"a\"]\nprint(counter)\n# Counter({'b': 2, 'c': 2})\n\n\n# 7. Existence\nprint(\"a\" in counter)  # False\nprint(\"b\" in counter)  # True\n\n\n# 8. Elements\ncounter = Counter(a=2, b=1, c=3)\nprint(list(counter.elements()))  # ['a', 'a', 'b', 'c', 'c', 'c']\n\n\n# 9. Most common\nprint(counter.most_common(2))  # [('c', 3), ('a', 2)]\n</code></pre>"},{"location":"stack_queue/","title":"Stack &amp; Queue","text":""},{"location":"stack_queue/queue/","title":"Queue","text":""},{"location":"stack_queue/queue/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0232 - Implement Queue using Stacks (Easy)</li> <li>0225 - Implement Stack using Queues (Easy)</li> </ol>"},{"location":"stack_queue/queue/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li>Implement the following operations of a queue using stacks.<ul> <li><code>push(x)</code> - Push element x to the back of queue.</li> <li><code>pop()</code> - Removes the element from in front of queue.</li> <li><code>peek()</code> - Get the front element.</li> <li><code>empty()</code> - Return whether the queue is empty.</li> </ul> </li> </ul> <pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"stack_queue/queue/#225-implement-stack-using-queues","title":"225. Implement Stack using Queues","text":""},{"location":"stack_queue/queue_monotonic/","title":"Monotonic Queue","text":""},{"location":"stack_queue/queue_monotonic/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0918 - Maximum Sum Circular Subarray (Medium)</li> <li>0239 - Sliding Window Maximum (Hard)</li> <li>2398 - Maximum Number of Robots Within Budget (Hard)</li> </ol>"},{"location":"stack_queue/queue_monotonic/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"stack_queue/queue_monotonic/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"stack_queue/queue_monotonic/#2398-maximum-number-of-robots-within-budget","title":"2398. Maximum Number of Robots Within Budget","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maximumRobots(\n    chargeTimes: List[int], runningCosts: List[int], budget: int\n) -&gt; int:\n    ans = sum_cost = left = 0\n    q = deque()\n\n    for right, (time, cost) in enumerate(zip(chargeTimes, runningCosts)):\n        # 1. Add\n        while q and time &gt;= chargeTimes[q[-1]]:\n            q.pop()\n        q.append(right)\n        sum_cost += cost\n\n        # 2. Remove\n        while q and chargeTimes[q[0]] + (right - left + 1) * sum_cost &gt; budget:\n            if q[0] == left:\n                q.popleft()\n            sum_cost -= runningCosts[left]\n            left += 1\n\n        # 3. Update\n        ans = max(ans, right - left + 1)\n    return ans\n\n\nchargeTimes = [3, 6, 1, 3, 4]\nrunningCosts = [2, 1, 3, 4, 5]\nbudget = 25\nprint(maximumRobots(chargeTimes, runningCosts, budget))  # 3\n</code></pre>"},{"location":"stack_queue/stack/","title":"Stack","text":""},{"location":"stack_queue/stack/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>2390 - Removing Stars From a String (Medium)</li> <li>1544 - Make The String Great (Easy)</li> <li>0020 - Valid Parentheses (Easy)</li> <li>0155 - Min Stack (Easy)</li> <li>0150 - Evaluate Reverse Polish Notation (Medium)</li> <li>0394 - Decode String (Medium)</li> <li>0022 - Generate Parentheses (Medium)</li> <li>0853 - Car Fleet (Medium)</li> <li>0224 - Basic Calculator (Hard)</li> <li>227 - Basic Calculator II (Medium)</li> <li>0772 - Basic Calculator III (Hard)</li> <li>0770 - Basic Calculator IV (Hard)</li> </ol>"},{"location":"stack_queue/stack/#2390-removing-stars-from-a-string","title":"2390. Removing Stars From a String","text":"<ul> <li>Remove all <code>*</code> characters and their adjacent characters from the string.</li> </ul> <pre><code># Stack\ndef removeStars(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char == \"*\":\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"leet**cod*e\"\nprint(removeStars(s))  # \"lecoe\"\n</code></pre>"},{"location":"stack_queue/stack/#1544-make-the-string-great","title":"1544. Make The String Great","text":"<ul> <li>Remove all adjacent characters that are the same and have different cases.</li> </ul> <pre><code># Stack\ndef makeGood(s: str) -&gt; str:\n    stack = []\n\n    for i in range(len(s)):\n        if stack and stack[-1] == s[i].swapcase():\n            stack.pop()\n        else:\n            stack.append(s[i])\n    return \"\".join(stack)\n\n\nprint(makeGood(\"leEeetcode\"))  # \"leetcode\"\n</code></pre>"},{"location":"stack_queue/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li>Determine if the input string is valid.</li> </ul> <pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"stack_queue/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> <pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"stack_queue/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"stack_queue/stack/#394-decode-string","title":"394. Decode String","text":"<pre><code># Stack\ndef decodeString(s: str) -&gt; str:\n    stack = []  # (str, int)\n    num = 0\n    res = \"\"\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == \"[\":\n            stack.append((res, num))\n            res, num = \"\", 0\n        elif c == \"]\":\n            top = stack.pop()\n            res = top[0] + res * top[1]\n        else:\n            res += c\n\n    return res\n\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # accaccacc\n</code></pre>"},{"location":"stack_queue/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<pre><code>from typing import List\n\n\n# Stack\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"stack_queue/stack/#853-car-fleet","title":"853. Car Fleet","text":"<pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"stack_queue/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"stack_queue/stack/#227-basic-calculator-ii","title":"227. Basic Calculator II","text":"<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    num = 0\n    sign = \"+\"\n\n    for index, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n\n        if char in \"+-*/\" or index == len(s) - 1:\n            if sign == \"+\":\n                stack.append(num)\n            elif sign == \"-\":\n                stack.append(-num)\n            elif sign == \"*\":\n                stack.append(stack.pop() * num)\n            elif sign == \"/\":\n                stack.append(int(stack.pop() / num))\n            sign = char\n            num = 0\n\n    return sum(stack)\n\n\ns = \"3+2*2\"\nprint(calculate(s))  # 7\n</code></pre>"},{"location":"stack_queue/stack/#772-basic-calculator-iii","title":"772. Basic Calculator III","text":"<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre>"},{"location":"stack_queue/stack/#770-basic-calculator-iv","title":"770. Basic Calculator IV","text":""},{"location":"stack_queue/stack_monotonic/","title":"Monotonic Stack","text":"<ol> <li>0739 - Daily Temperatures (Medium)</li> <li>0496 - Next Greater Element I (Easy)</li> <li>0503 - Next Greater Element II (Medium)</li> <li>0084 - Largest Rectangle in Histogram (Hard)</li> <li>0085 - Maximal Rectangle (Hard)</li> <li>0042 - Trapping Rain Water (Hard)</li> <li>0901 - Online Stock Span (Medium)</li> <li>0316 - Remove Duplicate Letters (Medium)</li> <li>0456 - 132 Pattern (Medium)</li> <li>2281 - Sum of Total Strength of Wizards (Hard)</li> </ol>"},{"location":"stack_queue/stack_monotonic/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    result = [0 for _ in range(len(temperatures))]\n    stack = []\n\n    for idx, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, last_index = stack.pop()\n            result[last_index] = idx - last_index\n\n        stack.append([temp, idx])\n\n    return result\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"stack_queue/stack_monotonic/#496-next-greater-element-i","title":"496. Next Greater Element I","text":"<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElement(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    next_greater = {}\n    stack = []\n    result = []\n\n    for num in nums2:\n        while stack and num &gt; stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    for num in nums1:\n        result.append(next_greater.get(num, -1))\n\n    return result\n\n\nnums1 = [4, 1, 2]\nnums2 = [1, 3, 4, 2]\nprint(nextGreaterElement(nums1, nums2))  # [3, -1, -1]\n</code></pre>"},{"location":"stack_queue/stack_monotonic/#503-next-greater-element-ii","title":"503. Next Greater Element II","text":"<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElements(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] &lt; nums[i % n]:\n            result[stack.pop()] = nums[i % n]\n        if i &lt; n:\n            stack.append(i)\n\n    return result\n\n\nnums = [1, 2, 1]\nprint(nextGreaterElements(nums))  # [2, -1, 2]\n</code></pre>"},{"location":"stack_queue/stack_monotonic/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"stack_queue/stack_monotonic/#85-maximal-rectangle","title":"85. Maximal Rectangle","text":"<ul> <li>Return the area of the largest rectangle that can be formed within a rectangle of 1's.</li> </ul> <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef maximalRectangle(matrix: List[List[str]]) -&gt; int:\n    if not matrix or not matrix[0]:\n        return 0\n\n    n = len(matrix[0])\n    heights = [0] * (n + 1)\n    max_area = 0\n\n    for row in matrix:\n        for i in range(n):\n            if row[i] == \"1\":\n                heights[i] += 1\n            else:\n                heights[i] = 0\n\n        stack = [-1]\n        for i in range(n + 1):\n            while heights[i] &lt; heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n\n    return max_area\n\n\nmatrix = [\n    [\"1\", \"0\", \"1\", \"0\", \"0\"],\n    [\"1\", \"0\", \"1\", \"1\", \"1\"],\n    [\"1\", \"1\", \"1\", \"1\", \"1\"],\n    [\"1\", \"0\", \"0\", \"1\", \"0\"],\n]\nprint(maximalRectangle(matrix))  # 6\n</code></pre>"},{"location":"stack_queue/stack_monotonic/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n    n = len(height)\n\n    max_left = [0 for _ in range(n)]\n    max_right = [0 for _ in range(n)]\n\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        max_right[i] = max(max_right[i + 1], height[i + 1])\n\n    total = 0\n\n    for i in range(n):\n        min_height = min(max_left[i], max_right[i])\n        if min_height &gt; height[i]:\n            total += min_height - height[i]\n\n    return total\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    total = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            total += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            total += maxR - height[right]\n\n    return total\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | DP         |  O(N)  |  O(N)   |\n# | Left Right |  O(N)  |  O(1)   |\n# | Monotonic  |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"stack_queue/stack_monotonic/#901-online-stock-span","title":"901. Online Stock Span","text":"<ul> <li>Design a class <code>StockSpanner</code> to return the number of consecutive days (including the current day) the price of the stock has been less than or equal to the current price.</li> </ul> <pre><code>from typing import List\n\n\n# Monotonic Stack\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = [(-1, float(\"inf\"))]\n        self.cur_day = -1\n\n    def next(self, price: int) -&gt; int:\n        while price &gt;= self.stack[-1][1]:\n            self.stack.pop()\n        self.cur_day += 1\n        self.stack.append((self.cur_day, price))\n        return self.cur_day - self.stack[-2][0]\n\n\nobj = StockSpanner()\nprices = [100, 80, 60, 70, 60, 75, 85]\nprint([obj.next(price) for price in prices])  # [1, 1, 1, 2, 1, 4, 6]\n</code></pre>"},{"location":"stack_queue/stack_monotonic/#316-remove-duplicate-letters","title":"316. Remove Duplicate Letters","text":""},{"location":"stack_queue/stack_monotonic/#456-132-pattern","title":"456. 132 Pattern","text":"<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre>"},{"location":"stack_queue/stack_monotonic/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":""},{"location":"string/","title":"String","text":""},{"location":"string/string/","title":"String","text":""},{"location":"string/string/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0344 - Reverse String (Easy)</li> <li>0541 - Reverse String II (Easy)</li> <li>0151 - Reverse Words in a String (Medium)</li> <li>0058 - Length of Last Word (Easy)</li> <li>0844 - Backspace String Compare (Easy)</li> <li>2185 - Counting Words With a Given Prefix (Easy)</li> <li>2000 - Reverse Prefix of Word (Easy)</li> </ol>"},{"location":"string/string/#344-reverse-string","title":"344. Reverse String","text":"<ul> <li>Reverse a string in-place.</li> </ul> <pre><code>from typing import List\n\n\ndef reverseString(s: List[str]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n\n\ns = [\"h\", \"e\", \"l\", \"l\", \"o\"]\nreverseString(s)\nprint(s)  # ['o', 'l', 'l', 'e', 'h']\n</code></pre>"},{"location":"string/string/#541-reverse-string-ii","title":"541. Reverse String II","text":"<ul> <li>Reverse the first <code>k</code> characters for every <code>2k</code> characters.</li> </ul> <pre><code>def reverseStr(s: str, k: int) -&gt; str:\n    def reverse_substring(text):\n        left, right = 0, len(text) - 1\n        while left &lt; right:\n            text[left], text[right] = text[right], text[left]\n            left += 1\n            right -= 1\n        return text\n\n    result = list(s)\n\n    for i in range(0, len(s), 2 * k):\n        result[i : i + k] = reverse_substring(result[i : i + k])\n\n    return \"\".join(result)\n\n\ns = \"abcdefg\"\nk = 2\nprint(reverseStr(s, k))  # \"bacdfeg\"\n</code></pre>"},{"location":"string/string/#151-reverse-words-in-a-string","title":"151. Reverse Words in a String","text":"<ul> <li>Reverse the order of words in a string.</li> </ul> <pre><code>def reverseWords(s: str) -&gt; str:\n    words = s.split()\n\n    left, right = 0, len(words) - 1\n\n    while left &lt; right:\n        words[left], words[right] = words[right], words[left]\n        left += 1\n        right -= 1\n\n    return \" \".join(words)\n\n\ns = \"the sky is blue\"\nprint(reverseWords(s))  # \"blue is sky the\"\n</code></pre>"},{"location":"string/string/#58-length-of-last-word","title":"58. Length of Last Word","text":"<ul> <li>Find the length of the last word in a string.</li> </ul> <pre><code>def lengthOfLastWord(s: str) -&gt; int:\n    n = 0\n\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] != \" \":\n            n += 1\n        if s[i] == \" \" and n &gt; 0:\n            return n\n\n    return n\n\n\nprint(lengthOfLastWord(\"Hello World\"))  # 5\n</code></pre>"},{"location":"string/string/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li>Compare two strings that contain backspace characters.</li> </ul> <pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre>"},{"location":"string/string/#2185-counting-words-with-a-given-prefix","title":"2185. Counting Words With a Given Prefix","text":"<ul> <li>Count the number of words with a given prefix.</li> </ul> <pre><code>from typing import List\n\n\n# 1\ndef prefixCount1(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        if word.startswith(pref):\n            count += 1\n\n    return count\n\n\n# 2\ndef prefixCount2(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        n = len(pref)\n\n        if len(word) &lt; n:\n            continue\n\n        if word[:n] == pref:\n            count += 1\n\n    return count\n\n\nwords = [\"pay\", \"attention\", \"practice\", \"attend\"]\npref = \"at\"\nprint(prefixCount1(words, pref))  # 2\nprint(prefixCount2(words, pref))  # 2\n</code></pre>"},{"location":"string/string/#2000-reverse-prefix-of-word","title":"2000. Reverse Prefix of Word","text":"<ul> <li>Reverse the prefix of a word.</li> </ul> <pre><code>def reversePrefix(word: str, ch: str) -&gt; str:\n    if ch not in word:\n        return word\n\n    wordList = list(word)\n    left, right = 0, 0\n\n    for i in range(len(wordList)):\n        if wordList[i] == ch:\n            right = i\n            break\n\n    while left &lt; right:\n        wordList[left], wordList[right] = wordList[right], wordList[left]\n        left += 1\n        right -= 1\n\n    return \"\".join(wordList)\n\n\nword = \"abcdefd\"\nch = \"d\"\nprint(reversePrefix(word, ch))  # \"dcbaefd\"\n</code></pre>"},{"location":"string/string_kmp/","title":"String - KMP","text":""},{"location":"string/string_kmp/#knuth-morris-pratt-algorithm","title":"Knuth-Morris-Pratt Algorithm","text":"<pre><code>from typing import List\n\n\ndef LPS(pattern: str) -&gt; List[int]:\n    n = len(pattern)\n    lps = [0 for _ in range(n)]\n    j = 0\n\n    for i in range(1, n):\n        while j &gt; 0 and pattern[i] != pattern[j]:\n            j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n            j += 1\n        lps[i] = j\n\n    return lps\n</code></pre>"},{"location":"string/string_kmp/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0028 - Find the Index of the First Occurrence in a String (Easy)</li> <li>0459 - Repeated Substring Pattern (Easy)</li> <li>0686 - Repeated String Match (Medium)</li> <li>1392 - Longest Happy Prefix (Hard)</li> <li>0214 - Shortest Palindrome (Hard)</li> </ol>"},{"location":"string/string_kmp/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li>Find the index of the first occurrence of a substring in a string.</li> </ul> <pre><code>from helper import LPS\n\n\n# 1. Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    # TC: O((m - n) * n)\n    # SC: O(1)\n\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# 2. KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    # TC: O(m + n)\n    # SC: O(n)\n\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre>"},{"location":"string/string_kmp/#459-repeated-substring-pattern","title":"459. Repeated Substring Pattern","text":"<ul> <li>Check if a string can be constructed by repeating a substring.</li> </ul> <pre><code>from helper import LPS\n\n\ndef repeatedSubstringPattern(s: str) -&gt; bool:\n    lps = LPS(s)\n    length = len(s)\n\n    if lps[-1] != 0 and length % (length - lps[-1]) == 0:\n        return True\n\n    return False\n\n\ns = \"abab\"\nprint(repeatedSubstringPattern(s))  # True\n</code></pre>"},{"location":"string/string_kmp/#686-repeated-string-match","title":"686. Repeated String Match","text":"<ul> <li>Find the minimum number of times a string must be repeated to make another string a substring of it.</li> </ul> <pre><code>import math\n\n\ndef repeatedStringMatch(a: str, b: str) -&gt; int:\n    min_repeat = math.ceil(len(b) / len(a))\n\n    def LPS(pattern):\n        lps = [0] * len(pattern)\n        j = 0\n\n        for i in range(1, len(pattern)):\n            while j &gt; 0 and pattern[i] != pattern[j]:\n                j = lps[j - 1]\n            if pattern[i] == pattern[j]:\n                j += 1\n            lps[i] = j\n\n        return lps\n\n    def kmp(text, pattern):\n        n, m = len(text), len(pattern)\n        lps = LPS(pattern)\n        j = 0\n\n        for i in range(n):\n            while j &gt; 0 and text[i] != pattern[j]:\n                j = lps[j - 1]\n            if text[i] == pattern[j]:\n                j += 1\n            if j == m:\n                return i - j + 1\n        return -1\n\n    for i in range(min_repeat, min_repeat + 2):\n        if kmp(a * i, b) != -1:\n            return i\n    return -1\n\n\nprint(repeatedStringMatch(\"abcd\", \"cdabcdab\"))  # 3\n</code></pre>"},{"location":"string/string_kmp/#1392-longest-happy-prefix","title":"1392. Longest Happy Prefix","text":"<ul> <li>Find the longest prefix that is also a suffix.</li> </ul> <pre><code>def longestPrefix(s: str) -&gt; str:\n    if len(s) &lt;= 1:\n        return \"\"\n\n    def LPS(pattern):\n        lps = [0 for _ in range(len(pattern))]\n        j = 0\n\n        for i in range(1, len(pattern)):\n            while j &gt; 0 and pattern[i] != pattern[j]:\n                j = lps[j - 1]\n            if pattern[i] == pattern[j]:\n                j += 1\n            lps[i] = j\n\n        return lps\n\n    lps = LPS(s)\n\n    return s[: lps[-1]]\n\n\nprint(longestPrefix(\"ababab\"))  # abab\n</code></pre>"},{"location":"string/string_kmp/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li>Find the shortest palindrome that can be constructed by adding characters to the beginning of a string.</li> </ul> <pre><code>def shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    def LPS(pattern):\n        lps = [0] * len(pattern)\n        j = 0\n\n        for i in range(1, len(pattern)):\n            while j &gt; 0 and pattern[i] != pattern[j]:\n                j = lps[j - 1]\n            if pattern[i] == pattern[j]:\n                j += 1\n            lps[i] = j\n        return lps\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre>"},{"location":"top_interview_150/","title":"Top Interview 150","text":""},{"location":"tree/","title":"Tree","text":""},{"location":"tree/tree_bfs/","title":"Binary Tree - BFS (Level Order Traversal)","text":"<p>Level Order Traversal Template</p> <pre><code>from collections import deque\n\nfrom binarytree import TreeNode\n\n\ndef treeBFS(root: TreeNode):\n    if not root:\n        return\n\n    q = deque([root])\n\n    while q:\n        n = len(q)\n\n        for i in range(n):\n            node = q.popleft()\n\n            # Do something here\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n</code></pre>"},{"location":"tree/tree_bfs/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0199 - Binary Tree Right Side View (Medium)</li> <li>0111 - Minimum Depth of Binary Tree (Easy)</li> <li>0104 - Maximum Depth of Binary Tree (Easy)</li> <li>0637 - Average of Levels in Binary Tree (Easy)</li> <li>0429 - N-ary Tree Level Order Traversal (Medium)</li> <li>0515 - Find Largest Value in Each Tree Row (Medium)</li> <li>0116 - Populating Next Right Pointers in Each Node (Medium)</li> <li>0117 - Populating Next Right Pointers in Each Node II (Medium)</li> <li>0513 - Find Bottom Left Tree Value (Medium)</li> <li>0863 - All Nodes Distance K in Binary Tree (Medium)</li> </ol>"},{"location":"tree/tree_bfs/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<pre><code>    ____1       &lt;---\n   /     \\\n  2__     2     &lt;--- Look at the rightmost node at each level\n /   \\     \\\n3     4     3   &lt;---\n     /\n    5           &lt;---\n</code></pre> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    right = []\n\n    while q:\n        n = len(q)\n\n        for i in range(n):\n            cur = q.popleft()\n\n            # rightmost element\n            if i == n - 1:\n                right.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n    return right\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"tree/tree_bfs/#111-minimum-depth-of-binary-tree","title":"111. Minimum Depth of Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            if not node.left and not node.right:\n                return depth\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root):\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre>"},{"location":"tree/tree_bfs/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return depth\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    return 1 + max(maxDepthRecursive(root.left), maxDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthRecursive(root))  # 4\n</code></pre>"},{"location":"tree/tree_bfs/#637-average-of-levels-in-binary-tree","title":"637. Average of Levels in Binary Tree","text":"<pre><code>from collections import deque\nfrom statistics import mean\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n        result.append(mean(level))\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(averageOfLevels(root))  # [1, 2, 3.5, 5]\n</code></pre>"},{"location":"tree/tree_bfs/#429-n-ary-tree-level-order-traversal","title":"429. N-ary Tree Level Order Traversal","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\n\ndef levelOrder(root: Optional[Node]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            for child in node.children:\n                queue.append(child)\n\n        result.append(level)\n\n    return result\n\n\nroot = Node(\n    1,\n    [\n        Node(\n            3,\n            [\n                Node(5, []),\n                Node(6, []),\n            ],\n        ),\n        Node(2, []),\n        Node(4, []),\n    ],\n)\nprint(levelOrder(root))  # [[1], [3, 2, 4], [5, 6]]\n</code></pre>"},{"location":"tree/tree_bfs/#515-find-largest-value-in-each-tree-row","title":"515. Find Largest Value in Each Tree Row","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef largestValues(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        levelMax = float(\"-inf\")\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            levelMax = max(levelMax, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(levelMax)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(largestValues(root))  # [1, 2, 4, 5]\n</code></pre>"},{"location":"tree/tree_bfs/#116-populating-next-right-pointers-in-each-node","title":"116. Populating Next Right Pointers in Each Node","text":"<ul> <li>Perfect Binary Tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return root\n\n\n# Perfect binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n#     __1__\n#    /     \\\n#   2__     3\n#  /   \\   / \\\n# 4     5 6   7\n\n\n# Connect the nodes\nconnect(root)\n#      __1__ -&gt; None\n#     /     \\\n#   _2_ -&gt;  3 -&gt; None\n#  /   \\   / \\\n# 4 -&gt; 5-&gt;6-&gt; 7 -&gt; None\n\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.left\nassert root.right.left.next == root.right.right\nassert root.right.right.next is None\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"tree/tree_bfs/#117-populating-next-right-pointers-in-each-node-ii","title":"117. Populating Next Right Pointers in Each Node II","text":"<pre><code>from collections import deque\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Node\") -&gt; \"Node\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n    return root\n\n\n# Binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(7)\n#       1\n#      / \\\n#     2   3\n#    / \\   \\\n#   4   5   7\n\n# Connect the nodes\nconnect(root)\n#       1 -&gt; None\n#      / \\\n#     2 -&gt; 3 -&gt; None\n#    / \\    \\\n#   4 -&gt; 5 -&gt; 7 -&gt; None\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.right.next is None\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.right\nassert root.right.right.next is None\n\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"tree/tree_bfs/#513-find-bottom-left-tree-value","title":"513. Find Bottom Left Tree Value","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findBottomLeftValue(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    result = 0\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\n\nprint(findBottomLeftValue(root))  # 5\n</code></pre>"},{"location":"tree/tree_bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre>"},{"location":"tree/tree_bst/","title":"Binary Search Tree (BST)","text":""},{"location":"tree/tree_bst/#binary-search-tree","title":"Binary Search Tree","text":"<ol> <li>Binary Tree</li> <li>Left subtree of a node contains only nodes with keys less than the node's key</li> <li>Right subtree of a node contains only nodes with keys greater than the node's key</li> <li>The left and right subtree each must also be a binary search tree</li> <li>There must be no duplicate nodes</li> <li>Inorder traversal of a BST gives a sorted list of keys</li> </ol> <pre><code>graph TD\n4((4)) --- 2((2))\n4 --- 7((7))\n2 --- 1((1))\n2 --- 3((3))</code></pre>"},{"location":"tree/tree_bst/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0700 - Search in a Binary Search Tree (Easy)</li> <li>0098 - Validate Binary Search Tree (Medium)</li> <li>0530 - Minimum Absolute Difference in BST (Easy)</li> <li>0501 - Find Mode in Binary Search Tree (Easy)</li> <li>0235 - Lowest Common Ancestor of a Binary Search Tree (Easy)</li> <li>0701 - Insert into a Binary Search Tree (Medium)</li> <li>0450 - Delete Node in a BST (Medium)</li> <li>0669 - Trim a Binary Search Tree (Medium)</li> <li>0108 - Convert Sorted Array to Binary Search Tree (Easy)</li> <li>0109 - Convert Sorted List to Binary Search Tree (Medium)</li> <li>0538 - Convert BST to Greater Tree (Easy)</li> <li>0230 - Kth Smallest Element in a BST (Medium)</li> <li>0173 - Binary Search Tree Iterator (Medium)</li> <li>1586 - Binary Search Tree Iterator II (Medium)</li> </ol>"},{"location":"tree/tree_bst/#700-search-in-a-binary-search-tree","title":"700. Search in a Binary Search Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef searchBSTRecursive(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if root.val &gt; val:\n        return searchBSTRecursive(root.left, val)\n\n    elif root.val &lt; val:\n        return searchBSTRecursive(root.right, val)\n\n    else:\n        return root\n\n\n# 2. Iterative\ndef searchBSTIterative(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    while root:\n        if root.val &gt; val:\n            root = root.left\n        elif root.val &lt; val:\n            root = root.right\n        else:\n            return root\n    return None\n\n\nroot = [4, 2, 7, 1, 3]\nval = 2\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     7\n#  / \\\n# 1   3\nprint(searchBSTRecursive(root, val))\n#   2\n#  / \\\n# 1   3\nprint(searchBSTIterative(root, val))\n#   2\n#  / \\\n# 1   3\n</code></pre>"},{"location":"tree/tree_bst/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"tree/tree_bst/#530-minimum-absolute-difference-in-bst","title":"530. Minimum Absolute Difference in BST","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n\n    inorder = []\n    result = float(\"inf\")\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        result = min(result, abs(inorder[i] - inorder[i - 1]))\n\n    return result\n\n\nroot = [4, 2, 6, 1, 3]\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\nprint(getMinimumDifference(root))  # 1\n</code></pre>"},{"location":"tree/tree_bst/#501-find-mode-in-binary-search-tree","title":"501. Find Mode in Binary Search Tree","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findMode(root: Optional[TreeNode]) -&gt; List[int]:\n    hashmap = dict()\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        if node.val not in hashmap:\n            hashmap[node.val] = 1\n        else:\n            hashmap[node.val] += 1\n        dfs(node.right)\n\n    dfs(root)\n    max_counts = max(hashmap.values())\n    result = []\n\n    for key, value in hashmap.items():\n        if value == max_counts:\n            result.append(key)\n\n    return result\n\n\nroot = [1, None, 2, None, None, 2]\nroot = build(root)\nprint(root)\n# 1__\n#    \\\n#     2\n#    /\n#   2\nprint(findMode(root))  # [2]\n</code></pre>"},{"location":"tree/tree_bst/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"tree/tree_bst/#701-insert-into-a-binary-search-tree","title":"701. Insert into a Binary Search Tree","text":"<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef insertIntoBST(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return TreeNode(val)\n\n    if root.val &gt; val:\n        root.left = insertIntoBST(root.left, val)\n    if root.val &lt; val:\n        root.right = insertIntoBST(root.right, val)\n\n    return root\n\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\n\ninsertIntoBST(root, 5)\n#     __4\n#    /   \\\n#   2     6\n#  / \\   /\n# 1   3 5\n</code></pre>"},{"location":"tree/tree_bst/#450-delete-node-in-a-bst","title":"450. Delete Node in a BST","text":"<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef deleteNode(root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return root\n\n    if root.val == key:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            cur = root.right\n            while cur.left is not None:\n                cur = cur.left\n            cur.left = root.left\n            return root.right\n\n    if root.val &gt; key:\n        root.left = deleteNode(root.left, key)\n    if root.val &lt; key:\n        root.right = deleteNode(root.right, key)\n\n    return root\n\n\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.right = TreeNode(7)\n#     __5\n#    /   \\\n#   3     6\n#  / \\     \\\n# 2   4     7\n\ndeleteNode(root, 3)\n#     __5\n#    /   \\\n#   4     6\n#  /       \\\n# 2         7\n</code></pre>"},{"location":"tree/tree_bst/#669-trim-a-binary-search-tree","title":"669. Trim a Binary Search Tree","text":"<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef trimBST(\n    root: Optional[TreeNode], low: int, high: int\n) -&gt; Optional[TreeNode]:\n    if root is None:\n        return None\n\n    if root.val &lt; low:\n        return trimBST(root.right, low, high)\n    if root.val &gt; high:\n        return trimBST(root.left, low, high)\n\n    root.left = trimBST(root.left, low, high)\n    root.right = trimBST(root.right, low, high)\n\n    return root\n\n\nroot = TreeNode(3)\nroot.left = TreeNode(0)\nroot.right = TreeNode(4)\nroot.left.right = TreeNode(2)\nroot.left.right.left = TreeNode(1)\n#     __3\n#    /   \\\n#   0     4\n#    \\\n#     2\n#    /\n#   1\n\ntrimBST(root, 1, 3)\n#     __3\n#    /\n#   2\n#  /\n# 1\n</code></pre>"},{"location":"tree/tree_bst/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"tree/tree_bst/#109-convert-sorted-list-to-binary-search-tree","title":"109. Convert Sorted List to Binary Search Tree","text":"<pre><code>from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedListToBST(head: Optional[ListNode]) -&gt; Optional[TreeNode]:\n    if not head:\n        return None\n\n    def find_mid(head: ListNode) -&gt; ListNode:\n        prev = None\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if prev:\n            prev.next = None\n\n        return slow\n\n    mid = find_mid(head)\n\n    node = TreeNode(mid.val)\n\n    if head == mid:\n        return node\n\n    node.left = sortedListToBST(head)\n    node.right = sortedListToBST(mid.next)\n\n    return node\n\n\nhead = ListNode(-10)\nhead.next = ListNode(-3)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(5)\nhead.next.next.next.next = ListNode(9)\n\nroot = sortedListToBST(head)\nassert root.val == 0\nassert root.left.val == -3\nassert root.left.left.val == -10\nassert root.right.val == 9\nassert root.right.left.val == 5\nprint(\"All passed\")\n\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"tree/tree_bst/#538-convert-bst-to-greater-tree","title":"538. Convert BST to Greater Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef convertBST(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    prev = 0\n\n    def dfs(node):\n        if not node:\n            return None\n        nonlocal prev\n\n        dfs(node.right)\n\n        node.val += prev\n        prev = node.val\n\n        dfs(node.left)\n\n    dfs(root)\n\n    return root\n\n\nroot = [4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8]\nroot = build(root)\nprint(root)\n#     ____4__\n#    /       \\\n#   1         6\n#  / \\       / \\\n# 0   2     5   7\n#      \\         \\\n#       3         8\ngreater_tree = convertBST(root)\nprint(greater_tree)\n#      _______30___\n#     /            \\\n#   _36            _21\n#  /   \\          /   \\\n# 36    35       26    15\n#         \\              \\\n#          33             8\n</code></pre>"},{"location":"tree/tree_bst/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"tree/tree_bst/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre>"},{"location":"tree/tree_bst/#1586-binary-search-tree-iterator-ii","title":"1586. Binary Search Tree Iterator II","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\nfrom helper import TreeNode\n\n\n# BST\nclass BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.nodes = self._inorder(root)\n        self.index = -1\n        self.size = len(self.nodes)\n\n    def _inorder(self, node):\n        if not node:\n            return []\n        return (\n            self._inorder(node.left) + [node.val] + self._inorder(node.right)\n        )\n\n    def hasNext(self) -&gt; bool:\n        return self.index &lt; self.size - 1\n\n    def next(self) -&gt; int:\n        self.index += 1\n        return self.nodes[min(self.index, self.size - 1)]\n\n    def hasPrev(self) -&gt; bool:\n        return self.index &gt; 0\n\n    def prev(self) -&gt; int:\n        self.index -= 1\n        return self.nodes[max(self.index, 0)]\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\nprint(obj.prev())  # 3\nprint(obj.prev())  # None\n</code></pre>"},{"location":"tree/tree_common_ancestor/","title":"Common Ancestor of a Binary Tree","text":"<ol> <li>0235 - Lowest Common Ancestor of a Binary Search Tree (Easy)</li> <li>0236 - Lowest Common Ancestor of a Binary Tree (Medium)</li> </ol>"},{"location":"tree/tree_common_ancestor/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"tree/tree_common_ancestor/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre>"},{"location":"tree/tree_feature/","title":"Tree - Feature","text":""},{"location":"tree/tree_feature/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0101 - Symmetric Tree (Easy)</li> <li>0222 - Count Complete Tree Nodes (Medium)</li> <li>0110 - Balanced Binary Tree (Easy)</li> <li>0257 - Binary Tree Paths (Easy)</li> <li>0404 - Sum of Left Leaves (Easy)</li> <li>0112 - Path Sum (Easy)</li> <li>2331 - Evaluate Boolean Binary Tree (Easy)</li> <li>0100 - Same Tree (Easy)</li> </ol>"},{"location":"tree/tree_feature/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef isSymmetricRecursive(root: Optional[TreeNode]) -&gt; bool:\n    \"\"\"Determine if a tree is symmetric.\"\"\"\n    if not root:\n        return True\n\n    def compare(left, right):\n        if left is None and right is not None:\n            return False\n        elif left is not None and right is None:\n            return False\n        elif left is None and right is None:\n            return True\n        elif left.val != right.val:\n            return False\n\n        outside = compare(left.left, right.right)\n        inside = compare(left.right, right.left)\n\n        return outside and inside\n\n    return compare(root.left, root.right)\n\n\n# Iterative\ndef isSymmetricIterative(root: Optional[TreeNode]) -&gt; bool:\n    \"\"\"Determine if a tree is symmetric.\"\"\"\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        leftNode = q.popleft()\n        rightNode = q.popleft()\n\n        if not leftNode and not rightNode:\n            continue\n\n        if not leftNode or not rightNode or leftNode.val != rightNode.val:\n            return False\n\n        q.append(leftNode.left)\n        q.append(rightNode.right)\n        q.append(leftNode.right)\n        q.append(rightNode.left)\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |   O(n)  |\n# | Iterative  |  O(n)  |   O(n)  |\n# |------------|--------|---------|\n\n\nroot = [1, 2, 2, 3, 4, 4, 3]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       2\n#  / \\     / \\\n# 3   4   4   3\nprint(isSymmetricRecursive(root))  # True\nprint(isSymmetricIterative(root))  # True\n</code></pre>"},{"location":"tree/tree_feature/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre>"},{"location":"tree/tree_feature/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"tree/tree_feature/#257-binary-tree-paths","title":"257. Binary Tree Paths","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef binaryTreePaths(root: Optional[TreeNode]) -&gt; List[str]:\n    if not root:\n        return []\n\n    path = []\n    paths = []\n\n    def dfs(node, path):\n        if not node:\n            return None\n\n        path.append(str(node.val))\n\n        if not node.left and not node.right:\n            paths.append(\"-&gt;\".join(path))\n\n        dfs(node.left, path[:])\n        dfs(node.right, path[:])\n\n    dfs(root, path)\n\n    return paths\n\n\nroot = build([1, 2, 3, None, 5])\nprint(root)\n#   __1\n#  /   \\\n# 2     3\n#  \\\n#   5\nprint(binaryTreePaths(root))  # ['1-&gt;2-&gt;5', '1-&gt;3']\n</code></pre>"},{"location":"tree/tree_feature/#404-sum-of-left-leaves","title":"404. Sum of Left Leaves","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef sumOfLeftLeaves(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    stack = [root]\n    sumLL = 0\n\n    while stack:\n        node = stack.pop()\n\n        if node.left and not node.left.left and not node.left.right:\n            sumLL += node.left.val\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return sumLL\n\n\n# Left Leave None:\n#   - node.left is not None\n#   - node.left.left is None\n#   - node.left.right is None\n\nroot = build([3, 9, 20, None, None, 15, 7])\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(sumOfLeftLeaves(root))  # 24\n</code></pre>"},{"location":"tree/tree_feature/#112-path-sum","title":"112. Path Sum","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(\n        root.right, targetSum\n    )\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre>"},{"location":"tree/tree_feature/#2331-evaluate-boolean-binary-tree","title":"2331. Evaluate Boolean Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef evaluateTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root.left and not root.right:\n        return root.val\n\n    left = evaluateTree(root.left)\n    right = evaluateTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    elif root.val == 3:\n        return left and right\n\n\nroot = build([2, 1, 3, None, None, 0, 1])\nprint(root)\n#   2__\n#  /   \\\n# 1     3\n#      / \\\n#     0   1\nboolTree = build([\"OR\", \"True\", \"AND\", None, None, \"False\", \"True\"])\nprint(boolTree)\n#    __OR_______\n#   /           \\\n# True        __AND_\n#            /      \\\n#         False     True\nprint(evaluateTree(root))  # 1\n</code></pre>"},{"location":"tree/tree_feature/#100-same-tree","title":"100. Same Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"tree/tree_modification/","title":"Binary Tree Modification","text":"<ol> <li>0226 - Invert Binary Tree (Easy)</li> <li>0105 - Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li>0106 - Construct Binary Tree from Inorder and Postorder Traversal (Medium)</li> <li>0654 - Maximum Binary Tree (Medium)</li> <li>0617 - Merge Two Binary Trees (Easy)</li> </ol>"},{"location":"tree/tree_modification/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"tree/tree_modification/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"tree/tree_modification/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"tree/tree_modification/#654-maximum-binary-tree","title":"654. Maximum Binary Tree","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef constructMaximumBinaryTree(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    maximum = max(nums)\n    rootIndex = nums.index(maximum)\n\n    root = TreeNode(maximum)\n\n    left_nums = nums[:rootIndex]\n    right_nums = nums[rootIndex + 1 :]\n\n    root.left = constructMaximumBinaryTree(left_nums)\n    root.right = constructMaximumBinaryTree(right_nums)\n\n    return root\n\n\nnums = [3, 2, 1, 6, 0, 5]\nroot = constructMaximumBinaryTree(nums)\n#     __6__\n#    /     \\\n#   3       5\n#    \\     /\n#     2   0\n#      \\\n#       1\n</code></pre>"},{"location":"tree/tree_modification/#617-merge-two-binary-trees","title":"617. Merge Two Binary Trees","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef mergeTrees(\n    root1: Optional[TreeNode], root2: Optional[TreeNode]\n) -&gt; Optional[TreeNode]:\n\n    if not root1:\n        return root2\n    if not root2:\n        return root1\n\n    root = TreeNode()\n\n    root.val += root1.val + root2.val\n    root.left = mergeTrees(root1.left, root2.left)\n    root.right = mergeTrees(root1.right, root2.right)\n\n    return root\n\n\nroot1 = TreeNode(1)\nroot1.left = TreeNode(3)\nroot1.right = TreeNode(2)\nroot1.left.left = TreeNode(5)\n#     1\n#    / \\\n#   3   2\n#  /\n# 5\n\nroot2 = TreeNode(2)\nroot2.left = TreeNode(1)\nroot2.right = TreeNode(3)\nroot2.left.right = TreeNode(4)\nroot2.right.right = TreeNode(7)\n#     2\n#    / \\\n#   1   3\n#    \\   \\\n#     4   7\n\nroot = mergeTrees(root1, root2)\n#     3\n#    / \\\n#   4   5\n#  / \\   \\\n# 5   4   7\n</code></pre>"},{"location":"tree/tree_traversal/","title":"Binary Tree Traversal","text":""},{"location":"tree/tree_traversal/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0144 - Binary Tree Preorder Traversal (Easy)</li> <li>0094 - Binary Tree Inorder Traversal (Easy)</li> <li>0145 - Binary Tree Postorder Traversal (Easy)</li> <li>0102 - Binary Tree Level Order Traversal (Medium)</li> <li>0107 - Binary Tree Level Order Traversal II (Medium)</li> <li>0103 - Binary Tree Zigzag Level Order Traversal (Medium)</li> </ol>"},{"location":"tree/tree_traversal/#144-binary-tree-preorder-traversal","title":"144. Binary Tree Preorder Traversal","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef preorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    preorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        preorder.append(node.val)\n        dfs(node.left)\n        dfs(node.right)\n\n    dfs(root)\n\n    return preorder\n\n\n# Iterative\ndef preorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = [root]\n    preorder = []\n\n    while stack:\n        node = stack.pop()\n        preorder.append(node.val)\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return preorder\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(preorderTraversalRecursive(tree))  # [0, 1, 3, 4, 2, 5, 6]\nprint(preorderTraversalIterative(tree))  # [0, 1, 3, 4, 2, 5, 6]\n</code></pre>"},{"location":"tree/tree_traversal/#94-binary-tree-inorder-traversal","title":"94. Binary Tree Inorder Traversal","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    inorder = []\n    current = root\n\n    while current or stack:\n        if current:\n            stack.append(current)\n            current = current.left\n        else:\n            current = stack.pop()\n            inorder.append(current.val)\n            current = current.right\n\n    return inorder\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre>"},{"location":"tree/tree_traversal/#145-binary-tree-postorder-traversal","title":"145. Binary Tree Postorder Traversal","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef postorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    postorder = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        dfs(node.right)\n        postorder.append(node.val)\n\n    dfs(root)\n\n    return postorder\n\n\n# Iterative\ndef postorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    postorder = []\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n        postorder.append(node.val)\n\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return postorder[::-1]\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(postorderTraversalRecursive(tree))  # [3, 4, 1, 5, 6, 2, 0]\nprint(postorderTraversalIterative(tree))  # [3, 4, 1, 5, 6, 2, 0]\n</code></pre>"},{"location":"tree/tree_traversal/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"tree/tree_traversal/#107-binary-tree-level-order-traversal-ii","title":"107. Binary Tree Level Order Traversal II","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrderBottom(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    res = []\n    q = deque([root])\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res[::-1]\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrderBottom(tree))  # [[15, 7], [9, 20], [3]]\n</code></pre>"},{"location":"tree/tree_traversal/#103-binary-tree-zigzag-level-order-traversal","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level if len(res) % 2 == 0 else level[::-1])\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(zigzagLevelOrder(tree))  # [[3], [20, 9], [15, 7]]\n</code></pre>"},{"location":"tree/tree_traversal/#appendix","title":"Appendix","text":""},{"location":"tree/tree_traversal/#traversal-methods","title":"Traversal Methods","text":"<p>Example 1</p> <pre><code>graph TD\nA(( ))\nB(( ))\nC(( ))\nD(( ))\nE(( ))\nF(( ))\nG(( ))\nA --- B\nA --- E\nB --- C\nB --- D\nE --- F\nE --- G</code></pre> <p>Preorder Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 4\n1 --- 2\n1 --- 3\n4 --- 5\n4 --- 6</code></pre> <p>Inorder Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n3 --- 1\n3 --- 5\n1 --- 0\n1 --- 2\n5 --- 4\n5 --- 6</code></pre> <p>Postorder Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n6 --- 2\n6 --- 5\n2 --- 0\n2 --- 1\n5 --- 3\n5 --- 4</code></pre> <p>Level Order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((1))\n3((2))\n4((2))\n5((2))\n6((2))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre> <p>Example 2</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre> Traversal Order Method Result Preorder Root, Left, Right DFS or Stack <code>[0, 1, 3, 4, 2, 5, 6]</code> Inorder Left, Root, Right DFS or Stack <code>[3, 1, 4, 0, 5, 2, 6]</code> Postorder Left, Right, Root DFS or Stack <code>[3, 4, 1, 5, 6, 2, 0]</code> Level Order Level by Level BFS with Queue <code>[[0], [1, 2], [3, 4, 5, 6]]</code>"},{"location":"tree/tree_trie/","title":"Trie (Prefix Tree)","text":""},{"location":"tree/tree_trie/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre>"},{"location":"tree/tree_trie/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0208 - Implement Trie (Prefix Tree) (Medium)</li> <li>0211 - Add and Search Word - Data structure design (Medium)</li> <li>0212 - Word Search II (Hard)</li> </ol>"},{"location":"tree/tree_trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"tree/tree_trie/#211-add-and-search-word-data-structure-design","title":"211. Add and Search Word - Data structure design","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"tree/tree_trie/#212-word-search-ii","title":"212. Word Search II","text":"<pre><code>from typing import List\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\n    def addWord(self, word):\n        node = self\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.isWord = True\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for w in words:\n        root.addWord(w)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"}]}